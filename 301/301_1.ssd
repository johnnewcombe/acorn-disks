	LD	B,C
fblk3:	RRA
	JR	C,fblk2
	INC	HL
	DJNZ	fblk3
fblk5:	INC	IX
	DEC	DE
	LD	A,E
	OR	D
	JP	NZ,fblk4

;NOT found at all so retry starting at block zero

	POP	HL
	LD	(HL),A
	INC	HL
	LD	(HL),A
	DEC	HL
	DEC	HL
	JP	fstart



;Found it

fblk2:	EX	DE,HL
	POP	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	POP	HL
	PUSH	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	CP	A
	LD	E,A
	JP	fblk12

;Find how many free & allocate them

fblk7:	INC	IX
	LD	E,(IX+0)
	LD	B,C
fblk9:	CP	A
	RR	E
	JR	NC,HL		;Get next chars
	INC	DE
	DJNZ	cmplop

notcmd:	CALL	getcmd		;Move onto command number
	BIT	7,(HL)		;Finished ?
	JR	nxtcmd		;Loop {zf used @ nxtcmd}

trymat:	DEC	B		;End of string => match
	JR	Z,gotcmd
	INC	DE		;Get next charcter
	LD	A,(DE)
	AND	05FH		;Caps it
	CP	'A'		;Non alpha => match
	JR	C,skpsp2
	CP	'Z'+1		;Alpha => no match
	JR	C,notcmd

skpsp2:	LD	A,(DE)		;Get character
	CP	' '		;Skip spaces
	JR	NZ,gotcmd
gotdot:	INC	DE		;Point to next character
	DJNZ	skpsp2		;Dec length & stfblk11
fblk12:	DEC	HL
	LD	A,H
	OR	L
	JR	Z,fblk11
	DJNZ	fblk9
	RR	E
	LD	(IX+0),E
	JP	fblk7

;Wind up

fblk11:	RR	E		;Allocate out of last byte
	DJNZ	fblk11
	LD	(IX+0),E
	EX	DE,HL

	POP	HL		;Fill in blocks found
	LD	(HL),E
	INC	HL
	LD	(HL),D

	POP	IX
	RET
;
; ****** END OF MAPMAN ******
;




	COMMON	/debug/

mesflg:	DEFS	1


	COMMON	/error/

errloc:	DEFS	1

	COMMON	/freebl/

dsksiz:	DEFS	maxdrv * 2


	DSEG

cacmap:	DEFS	noblks*4	;Cache sector map

page:	DEFS	1ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее		;Current cache page

rwpage:	DEFS	1		;Parameter to rwdisk

csize:	DEFS	1		;Number of usable blocks in cache.

dsflag:	DEFS	1		;Double sided bit map

;	******* MAPMAN AREAS *********

lstadr:	DEFS	2		;Address of last block found

mapptr:	DEFS	maxdrv*4	;( length (2) + mapptr (2) ) * maxdrv

myheap:	DEFS	heapln


	END
 
loc:	DEFS	1

	COMMON	/freebl/

dsksiz:	DEFS	maxdrv * 2


	DSEG

cacmap:	DEFS	noblks*4	;Cache sector map

page:	DEFS	1E),A
	RET	Z		;Stop if zero

	LD	C,B		;Move the end to the beginning
	LD	B,0
	INC	DE
	LDIR
	RET





;FUNCTION hi (n: WORD): BYTE
;
;This returns the hi byte of N

hi:	POP	HL		;Return address
	POP	AF		;Hi_n (A) Lo_n (F)
	JP	(HL)		;Return





;FUNCTION lo (n: WORD): BYTE
;
;This returns the lo byte of N

lo:	POP	HL		;Return address
	POP	DE		;n
	LD	A,E		;Get lo byte
	JP	(HL)		;Return





;FUNCTION cli (VAR cmd: STRING 255): BYTE
;
;This looks up the command in <cmd> inialise messag,debug.

chario:	LD	HL,0
	LD	(sersp),HL
	LD	(serptr),HL
	LD	A,1		; Cache bank number
	LD	(serptr+2),A
	LD	(sersp+2),A

	LD	A,(07EH)
	LD	(mess),A
	LD	A,(07FH)
	LD	(debu),A

	RET



; Routine to wait for & read byte from 6502
; Value returned in A, all other regs preserved.
;
; NB.	the 6502 is now a Z80 !

wait65:	IN	A,(status)
	BIT	6,A
	JR	Z,wait65
	IN	A,(Jlatch)
	RET





	COMMON	/prispa/
space:	DS	4

	COMMON	/priptr/
ptr:	DS	4

	COMMON	/messag/
mess:	DS	ry
	ADC	HL,DE
	LD	(serptr),HL
;	RET	NC		;No carry into hi byte so not off end of cache
exitNZ:	XOR	A		;We have done something - return NZ
	INC	A
	RET			;64K buffer, so no wrap-round code




;
; Routine to poll front pannel switches
;
; If switch is 'Off' then exit FS & kill power.
; If rear pannel reset is pushed AND front switch is in sys_priv position,
; then exit to maintainance mode.


chksw:	IN	A,(status)
	BIT	1,A
	JR	Z,chk1		;Front sw is in syst position
	BIT	2,A
	RET	NZ		;Fron1

	COMMON	/debug/
debu:	DS	1


	DSEG
sersp:	DS	3

serptr:	DS	3

	END
ersp+2),A

	LD	A,(07EH)
	LD	(mess),A
	LD	A,(07FH)
	LD	(debu),A

	RET



; Routine to wait for & read byte from 6502
; Value returned in A, all other regs preserved.
;
; NB.	the 6502 is now a Z80 !

wait65:	IN	A,(status)
	BIT	6,A
	JR	Z,wait65
	IN	A,(Jlatch)
	RET





	COMMON	/prispa/
space:	DS	4

	COMMON	/priptr/
ptr:	DS	4

	COMMON	/messag/
mess:	DS	t sw is in Secure position

	CALL	emptyC		;Power off pos of switch
	LD	A,12		;Turn off relay
	CALL	to6502
chk3:	JR	chk3		;wait for end of world

chk1:	BIT	3,A		;In syst pos., so check for back pannel reset
	RET	NZ
	CALL	emptyC
	JP	fsexit

;
; FUNCTION Syst_sw:Boolean;
;
; Return condition of key switch.

systsw:	IN	A,(status)
	CPL			;Bit is active LOW
	AND	2
	RRCA			;return 0 (False) or 1 (True)
	RET

;
; PROCEDURE Char_io;
; Initialise character i/o (i not supported !)
; Also init	D,hour
setcl4:	INC	HL		;1st time round points to new hours
	CALL	write		;(HL) in decimal
	DEC	D
	JP	P,setcl4	;stops when D=-1 ie just written secs reg

;now start clock - NB D=0FFH ie select status register

	LD	A,1
	JP	writck		;and finish

	IF	option

setcl3:

;noclock present so set hms to zero

	LD	HL,rhour
	LD	B,3
	JP	filzer

	ENDIF

writea:	LD	(HL),A
write:	PUSH	BC

;convert to BCD

	XOR	A
	RLD			;top nibble to A lo

	LD	B,4
write1:	ADD	A,A
	DAA
	DJNZ	write1

	LD	B,T	quote,C
	JR	gsnext

noquot:	CP	'|'		;Char a bar ?
	JR	NZ,nobar2
	SET	bar,C
	JR	gsnext

nobar2:	CP	','		;Char a comma or space
	JR	Z,gsendq
	CP	' '
	JR	NZ,inschr
gsendq:	BIT	quoted,C
	JR	NZ,inschr
	BIT	stop,C
	JR	NZ,gsend
	JR	inschr

inschr:	BIT	barpln,C	;Check for |! flag
	JR	Z,noset
	SET	7,A
	RES	barpln,C

noset:	LD	(DE),A		;Put char into out string
	INC	DE
	INC	(IY+0)

gsnext:	INC	HL		;Check if run out of chars & loop
	DJNZ	gsloop

	INC	B		;Adjust B & HL for later
	DEC	HLA
	XOR	A
	RLD			;A=lo nibble of 
	ADD	A,B
	DAA			;A now in BCD
	POP	BC


;WRITCK
;write an RTC register
;
;On entry:
; D	register to write
; A	value to write
;
;On exit:
; A	naff
; rest	OK

writck:	PUSH	BC

	LD	B,A
	CALL	w3000
	OUT	(C),D
	LD	A,B

	RRCA
	RRCA
	RRCA
	RRCA			;top nibble in A
	OUT	(C),A
	OUT	(C),B		;lo nibble

	POP	BC
	RET



	COMMON	/now/

rdate:	DS	1		;date origin 1
rmonth:	DS	1		;month (LO,origin 1) and year (HI, origin 1981)
rhour:	DS	1
rmin:	DS	1

	BIT	quoted,C	;Check string terminated correctly wrt quotes
	JR	Z,gsend
	BIT	quote,C
	JR	Z,dufstr

gsend:	BIT	bar,C		;Check no bar flags still active
	JR	NZ,dufstr
	BIT	barpln,C
	JR	NZ,dufstr

	JR	gsskp4		;Start by checking if any bytes left

gsskp2:	LD	A,(HL)		;Skip trailing spaces
	CP	' '
	JR	NZ,gsskp3
gsskp4:	INC	HL
	DJNZ	gsskp2
	JR	gsmove

gsskp3:	CP	','		;And one trailing comma
	JR	NZ,gsmove
	INC	HL
	DEC	B

gsmove:	POP	DE		;Fill in new length of string
	LD	A,B
	OR	A
	LD	(D
rsec:	DS	1

	COMMON	/error/

errloc:	DS	1



	END

; D	register to write
; A	value to write
;
;On exit:
; A	naff
; rest	OK

writck:	PUSH	BC

	LD	B,A
	CALL	w3000
	OUT	(C),D
	LD	A,B

	RRCA
	RRCA
	RRCA
	RRCA			;top nibble in A
	OUT	(C),A
	OUT	(C),B		;lo nibble

	POP	BC
	RET



	COMMON	/now/

rdate:	DS	1		;date origin 1
rmonth:	DS	1		;month (LO,origin 1) and year (HI, origin 1981)
rhour:	DS	1
rmin:	DS	1
;On entry:
; D	register number
; HL	RAM address
;
;On exit:
; A,(HL) register contents IN HEX
; C	points to clock port
; rest	preserved

read:	CALL	readck
	LD	A,(HL)

;tohex
;On entry:
; A	BCD number
;
;On exit:
; A,(HL) hex number
; rest	preserved

tohex:	PUSH	BC
	LD	C,A
	RRCA
	RRCA
	RRCA
	RRCA
	AND	15
	ADD	A,A		;*2
	LD	B,A
	ADD	A,A		;*4
	ADD	A,A		;*8
	ADD	A,B		;*10
	LD	B,A
	LD	A,C		;this contains some of the hi-nibble set
	AND	15
	ADD	A,B		;and add lo-nibble
	POP	BC




	END


	LD	A,B

	RRCA
	RRCA
	RRCA
	RRCA			;top nibble in A
	OUT	(C),A
	OUT	(C),B		;lo nibble
	EI

	LD	B,40		;Delay so that next write succeeds
	DJNZ	$

	POP	BC
	RET



	COMMON	/now/

now1:	DS	5

	DSEG

rdate:	DS	1		;date origin 1
rmonth:	DS	1		;month (LO,origin 1) and year (HI, origin 1981)
rhour:	DS	1
rmin:	DS	1
rsec:	DS	1

	COMMON	/error/

errloc:	DS	1	LD	(HL),A
	RET


;READCK
;Read a register from RTC
;
;On entry:
; D	register to be read
; HL	points to 1-byte block where reg will be stored

readck:	CALL	w3000
	OUT	(C),D
	IN	A,(C)
	LD	(HL),A
	IN	A,(C)
	RLD
	RET


w3000:	LD	C,clock
w3001:	IN	A,(C)
	OR	0F0H
	INC	A
	JR	Z,w3001

;There is a bug in the M3000 st at the end of an update cycle the device goes
;not busy 32us before it actually goes ready, so we have to wait 32us....

	LD	A,32*6/(4+12)+1		;32us at 6MHz
w3002:	DEC	A
	ameter block RDATE

;check for M3000

	IF	option

	IN	A,(idle)
	BIT	1,A
	JR	NZ,setcl3

	ENDIF

;now set time: stop clock

	LD	D,status
	LD	A,0
	CALL	writck		;writes A unmodified

	LD	D,date
	CALL	write		;writes (HL) in decimal
	INC	HL
	INC	D		;month reg
	LD	B,(HL)
	LD	A,(HL)
	AND	15
	CALL	writea		;write the months out
	INC	D		;year reg
	XOR	A
	LD	(HL),B
	RLD			;year to A low-nibble, 0 to hi
	ADD	A,81		;year was origin 81
	CALL	writea

;hms can go straight out to M3000

	LDJR	NZ,w3002

;but by this time it may have gone busy again...

	IN	A,(C)
	OR	0F0H
	INC	A
	JR	Z,w3001

	RET				;Not busy!




;PROCEDURE SetClk(address_of_new_time:Word);
;returns error=90H if date is invalid.
;If there is no RTC then the date & month/year is stored, but the
;hours/mins/secs are zeroed to indicate that they are not meaningful

setclk:	POP	BC
	POP	DE		;DE=pointer to new date/time
	PUSH	BC

	LD	HL,errloc
	LD	(HL),90H	;set error initially

;now range check

	LD	A,(DEer
;
;On exit:
; A	Byte with bit set
; B	1 - 8 => Bit number
; DE	Points to low byte of address in MAPPTR (length @(DE-2))
; HL	Address of byte

getblk:	PUSH	HL

	CP	maxdrv
	JP	NC,maperr

	ADD	A,A
	ADD	A,A
	LD	C,A
	LD	B,0
	LD	HL,mapptr+3
	ADD	HL,BC
	EX	(SP),HL

	LD	A,L		;HL/8, A=Remainder
	AND	7
	SRL	H
	RR	L
	SRL	H
	RR	L
	SRL	H
	RR	L

	LD	B,A		;Set bit A in A
	INC	B
	LD	C,B
	SUB	A
	SCF
getbl1:	RLA
	DJNZ	getbl1

	POP	DE
	PUSH	BC
	EX	DE,HL
	LD	B,(HL)		;BC:= address of C
	DJNZ	fblk0
fblk1:	LD	B,C
	PUSH	AF
	PUSH	BC
	PUSH	HL
	EX	DE,HL
	INC	HL
	LD	D,(HL)
	DEC	HL
	LD	E,(HL)
	DEC	HL
	LD	B,(HL)
	DEC	HL
	LD	C,(HL)
	EX	DE,HL
	ADD	HL,BC
	POP	BC
	PUSH	BC
	POP	IX
	CP	A
	SBC	HL,BC
	EX	DE,HL
	POP	BC
	POP	AF
	POP	HL
	LD	C,8
	JP	fblk3

;Main find loop
;
;On entry:
; BC	8
; DE	number of bytes to search before giving up
; HL	start block number
; IX	pointer to current byte to search

fblk4:	LD	A,(IX+0)
	OR	A
	JR	NZ,fblk6
	ADD	HL,BC
	JP	fblk5
fblk6:map
	DEC	HL
	LD	C,(HL)

	IF	c.on		;** Range check block **

	PUSH	AF		;Check map exists
	LD	A,B
	AND	C
	INC	A
	JP	Z,maperr

	PUSH	HL		;Check valid block number
	DEC	HL
	LD	A,(HL)
	DEC	HL
	LD	L,(HL)
	LD	H,A
	CP	A
	SBC	HL,DE
	JP	C,ranerr

	POP	HL
	POP	AF

	ENDIF			;** End of range check **

	EX	DE,HL
	ADD	HL,BC
	POP	BC
	LD	B,C
	RET


	IF	c.on

;Bad map number / map not initialized

maperr:	error	'map no?'

;Block number out of range

ranerr:	error	'Bad block number'




	END


	LD	A,B

	RRCA
	RRCA
	RRCA
	RRCA			;top nibble in A
	OUT	(C),A
	OUT	(C),B		;lo nibble
	EI

	LD	B,40		;Delay so that next write succeeds
	DJNZ	$

	POP	BC
	RET



	COMMON	/now/

now1:	DS	5

	DSEG

rdate:	DS	1		;date origin 1
rmonth:	DS	1		;month (LO,origin 1) and year (HI, origin 1981)
rhour:	DS	1
rmin:	DS	1
rsec:	DS	1

	COMMON	/error/

errloc:	DS	1
	ENDIF




;PROCEDURE fblk (VAR block: block_descrip; VAR no_block: WORD);
;
;Attempt to find up to no_block blocks starting from block_descrip

fblk:	POP	HL		;Return address
	POP	BC		;no_block
	EX	(SP),HL		;block_descrip
	PUSH	IX
	PUSH	BC

fstart:	LD	A,(HL)		;Drive
	INC	HL
	PUSH	HL		;Save address of block number
	LD	E,(HL)		;get block number
	INC	HL
	LD	D,(HL)

	EX	DE,HL
	PUSH	HL
	CALL	getblk
	LD	C,8
	CP	A		;Clear carry for RRA
	DEC	B
	LD	A,(HL)
	JR	Z,fblk1
fblk0:	RRA
	DEC	 no match
	JR	Z,notmat

	LD	B,(HL)		;Check change string not null
	LD	A,B
	OR	A
	JR	NZ,try4it

	LD	A,illnam	;Bad string if so
	JP	tsterr

try4it:	EXX			;Get hash & star table pointers
	LD	HL,hshtbl
	LD	DE,statbl
	EXX

chalop:	INC	HL
	LD	A,(HL)		;Get char from change string
	CP	'*'		;Star ?
	JR	NZ,notsta

	PUSH	DE
	EXX
	DEC	B		;Got any star fields left ?
	JP	M,dufwlx
	EX	(SP),HL
	EX	DE,HL
	PUSH	BC
	LD	C,(HL)		;Get address and length of replace string
	INC	HL
	LD	B,(HL)
	INC	HLsettle time
	CALL	outcom
	LD	HL,secbuf	;Set address to R/W to/from
	LD	D,0FCH

write1:	OUT	(C),E
write0:	LD	A,(HL)
	CPL
	LD	B,A
write2:	IN	A,(status)
	RRCA
	JR	C,write4
	RRCA
	JR	C,write2
	LD	A,B
	OUT	(data),A
	INC	L
	JP	NZ,write0
	INC	E
	JP	write1

write4:	PUSH	AF		;Write finished so wait for tunnel erase to end
	LD	BC,3700/29	; 1ms minus allowance for shortest code to
write5:	DEC	BC		; next call of OUTCOM
	LD	A,B		; 29 is the no. of T states in the loop.
	OR	C
	JR	NZ,write5
	POP
	LD	A,(HL)
	INC	HL
	PUSH	HL
	LD	L,C		;HL:= replace string
	LD	H,B
	OR	A		;Does string exist ?
	JR	Z,chast0
	LD	B,0		;BC:= len
	LD	C,A
	ADD	A,(IY+0)	;Update string length
	LD	(IY+0),A
	LDIR			;Move string
chast0:	POP	HL		;Restore regs
	POP	BC
	EX	DE,HL
	EX	(SP),HL
	EXX
	POP	DE
	JR	nxtchr		;Go round again

notsta:	CP	'#'		;Check hash
	JR	NZ,nothsh

	EXX
	LD	A,(HL)		;Get replace char
	INC	HL		;Update pointer
	DEC	C		;Dec number
	EXX
	JP	M,dufwld	;Out of hash fields ?

nothsh:	LD		AF		;useful instruction as A has been PUSHed before

;drop through

;Return from Read or Write

rwret:	RLCA			;Move byte back the way it came
	OUT	(pagoff),A	;Turn off cache memory
	CPL			;Data bus all inverted !
	AND	D		;Mask out silly bits
	LD	C,A		;Save error number in case we want to retry
	JR	Z,giveup	;OK ?

; Not Ready,Write prot,Write fault,Lost data are all fatal

	AND	0E7H
	JR	NZ,giveup

	LD	A,(rcount)	;How many goes have we had at this sector ?
	CP	maxtry		;Too many ?
	JR	NC,g(DE),A		;Insert char
	INC	(IY+0)
	INC	DE

nxtchr:	DJNZ	chalop		;Go round loop again

	EXX			;Check all wild fields exhausted
	LD	A,B
	OR	C
	EXX
	JR	NZ,dufwld
	JR	allok

dufwlx:	POP	HL		;Error return from star
	EXX
dufwld:	LD	A,badwld	;Error return - bad string match
tsterr:	LD	(err),A

allok:	LD	A,1

notmat:	LD	HL,(retsav)	;Get return address
	JP	(HL)







	COMMON	/error/

err:	DEFS	1


	DSEG


hshtbl:	DEFS	maxlen
statbl:	DEFS	maxlen*3

retsav:	DEFS	2



	END
 DO $(A:=TRUE;cf=0$)
	CP	A
insgo:	POP	HL		;addr of go_on flag
	PUSH	AF

	LD	(HL),0		;Insert Go_on flag
	RL	(HL)
	EX	AF,AF'		;IF wilds DO go_on:= TRUE
	OR	(HL)
	LD	(HL),A

	POP	AF
	EX	AF,AF'
	POP	AF
	EX	AF,AF'

	RET


;match1
;
;On exit:
; cf	set if go_on (ie 'master' string after test in alpha order)
; zf	set if match
; AF'	1 if significant wild before match failed (undef if match worked)

match1:	LD	A,(DE)
	CP	'*'
	JR	Z,wildm
	INC	C
	DEC	C
	SCF			;'Test' string is too short, 	AF,AF'

	INC	DE
	DEC	B		;Test for * @ EOL
	JR	NZ,wildm1

	LD	A,C		;Fill in length in * table
	EXX
	INC	A
	LD	(HL),A
	EXX
	CP	A		;Set zf; Reset cf
	RET

wildm1:	PUSH	BC
	PUSH	DE
	PUSH	HL
	EXX
	PUSH	BC
	PUSH	DE
	PUSH	HL
	EXX
	CALL	match1
	EXX
	POP	HL
	POP	DE
	JR	NZ,wildm2	;If matched then BC is vaild
	INC	SP
	INC	SP
	JR	wildm3
wildm2:	POP	BC
wildm3:	EXX
	POP	HL
	POP	DE
	POP	BC
	RET	Z
	INC	HL
	EXX			;Increment string len in * table
	INC	(HL)
	EXX
	DEC	C
	SCF
	RET	M
	so DO go on
	RET	M

	CP	'#'		;Match any charcter
	JR	NZ,match3

	LD	A,(HL)		;Get char it really is
	EXX
	LD	(DE),A		;Save char in table
	EX	AF,AF'
	INC	DE		;Inc #table pointer
	INC	C		;Inc number of #s
	LD	A,1		;Set wild flag
	EXX
	EX	AF,AF'
	JR	match2


match3:	PUSH	BC
	LD	C,A
	AND	5FH		;Knock out case bit
	CP	'A'		;Alpha ?
	JR	C,nalpha
	CP	'Z'+1
	JR	NC,nalpha
	LD	C,A		;Store case equated version
nalpha:	LD	A,(HL)
	AND	5FH
	CP	'A'		;Alpha ?
	JR	C,nalph1
	CP	'Z'+1
	JR	C,cpmatJR	wildm1








;FUNCTION tstren (VAR change_str: min_string; VAR new_name: min_string;
;		  VAR fname: min_string; addr: INTEGER;
;		  VAR go_on: BOOLEAN): BOOLEAN;

tstren:	SUB	A		;No errors to start with
	LD	(err),A
	POP	HL		;Save return address
	LD	(retsav),HL

	CALL	match		;Do match operation

	POP	DE		;Get start of string into DE
	PUSH	DE
	POP	IY		;Save start of string in IY
	LD	(IY+0),0	;Zero length of string initially
 	INC	DE		;Point to text
	POP	HL
	OR	A		;return now if

nalph1:	LD	A,(HL)		;Get back character
cpmat:	CP	C		;Compare
	POP	BC
	RET	NZ

match2:	INC	DE
	DEC	C
	INC	HL
	DJNZ	match1		;Count chars in master string
	CP	A		;cf=0
	INC	C
	RET

wildm:	EX	AF,AF'
	LD	A,1		;Set wild flag
	PUSH	HL
	EXX
	EX	DE,HL		;Get HL into DE' and save old DE'
	EX	(SP),HL
	EX	DE,HL
	INC	HL		;Put pointer into *table
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),0		;Set length to zero
	INC	B		;Inc * counter
	POP	DE		;Restore DE'
	EXX			;Back to old reg set
	EX ^, < ! or > }
;Also converts .s to *s
;
;Puts chain number of filename into <chain_no>

legal:	POP	HL		;Return addr
	POP	IY		;wild flag
	POP	DE		;Chain number
	EX	(SP),HL		;Filename

	XOR	A
	LD	(IY+0),A	;Clear wild flag

; Check for zero length string

	CP	(HL)
	JR	NZ,long1	; (HL) is length, A is zero

	LD	(DE),A		; Chain no. 0
	INC	A		; Return value - True
	RET

long1:	PUSH	HL
	INC	HL
	LD	A,(HL)
	AND	5FH
	SUB	'A'
	JR	C,chs0
	CP	26
	JR	NC,chs0
	SRL	A
	INC	A
	JR	chs1
chs0:	L;Now we have
; HL	Master string (Length followed by bytes)
; DE	Test string (Terminated by <cr>)
; BC	Go on flag address

; *** FUDGE FOR ZERO LENGTH STRINGS FOLLOWS ***
	LD	A,(HL)		;Length
	OR	A
	JR	NZ,long		;Not zero length, so do everything

	LD	(BC),A		;Don't go on ever
	LD	A,(DE)
	CP	13		;Check for CR
	LD	A,1
	RET	Z
	DEC	A
	RET

; Here for normal length

long:	EXX			;Set Wild count to zero
	LD	BC,0
	LD	DE,hshtbl	;Set up pointers to #table & *table
	LD	HL,statbl-1
	EXX

	SUB	A	D	A,(HL)
	CP	'A'
	LD	A,9
	JR	NC,chs1
	SUB	A
chs1:	LD	(DE),A
	POP	HL

	LD	A,(HL)		;Check not zero length
	PUSH	AF

	LD	B,A
	LD	C,0

vloop:	INC	HL
	LD	A,(HL)
	CP	'.'
	JR	NZ,vlop1
	LD	A,'*'
	LD	(HL),A
vlop1:	CP	'*'
	JR	Z,vlop0
	INC	C
	CP	'#'
	JR	NZ,vlop2
vlop0:	LD	(IY+0),1
vlop2:	CP	127
	JR	NC,dufstr
	CP	'!'
	JR	C,dufstr
	CP	'$'
	JR	Z,dufstr
	CP	'^'
	JR	Z,dufstr
	CP	'%'
	JR	Z,dufstr
	CP	':'
	JR	Z,dufstr
	DJNZ	vloop
	LD	A,C		;Check string not too long
	CP	maxlen+1
	JR	NC	;Set AF' to zero and save old AF'
	EX	AF,AF'		; note mixed ' terms in above comment
	PUSH	AF		; also that we end up with regs swopped

	PUSH	BC
	LD	A,(HL)		;String length
	INC	HL
	LD	B,A
	PUSH	HL
	PUSH	BC

	LD	A,cr
	LD	H,D
	LD	L,E
	LD	BC,11
	CPIR
	LD	A,9
	SUB	C		;a=(length of 'test' string)-1

	POP	BC		;string length
	POP	HL		;pointer to 'master' string
	LD	C,A

	EX	DE,HL
	CALL	match1		;On entry, HL -> test, DE -> master
	LD	A,0		;A = 0 => nomatch
	JR	NZ,insgo
	INC	A		;IF {match},dufstr
	POP	AF
	SUB	C		;Get number of *s
	CP	maxlen+1	;Too many ?
	JR	NC,dufst2
	LD	A,1		;Return TRUE
	RET

dufstr:	POP	AF		;Duf string => return false
dufst2:	SUB	A
	RET







;MATCH
;FUNCTION match (VAR fname: min_string; addr: INTEGER;
;		 VAR go_on: BOOLEAN): BOOLEAN;
;
;Routine to compare two strings - both are assumed real & no error
; checking is done

match:	POP	HL		;Return address
	POP	BC		;Go on flag
	POP	DE		;Dir string
	EX	(SP),HL		;HL=String addr, (SP)=Ret addr


	LD	A,(HL)
	INC	HL
	PUSH	HL
	LD	L,C		;HL:= replace string
	LD	H,B
	OR	A		;Does string exist ?
	JR	Z,chast0
	LD	B,0		;BC:= len
	LD	C,A
	ADD	A,(IY+0)	;Update string length
	LD	(IY+0),A
	LDIR			;Move string
chast0:	POP	HL		;Restore regs
	POP	BC
	EX	DE,HL
	EX	(SP),HL
	EXX
	POP	DE
	JR	nxtchr		;Go round again

notsta:	CP	'#'		;Check hash
	JR	NZ,nothsh

	EXX
	LD	A,(HL)		;Get replace char
	INC	HL		;Update pointer
	DEC	C		;Dec number
	EXX
	JP	M,dufwld	;Out of hash fields ?

nothsh:	LDat latch
makes that 1K byte physical block appear at &F000. Writing anything to
<pagoff> disables the cache again. Page numbers are in terms of 256 byte
pages - the two low bits are ignored by the hardware.

HOW THE CACHE WORKS

The cache stores 1K blocks, up to 64 in all. Each block is held in 4 physical
pages, and all page numbers are in this form - ie. 0,4,8,12 are successive
pages. (page) holds the current page number and also acts as a head of
chain pointer. The map has 4 bytes per entry (hen	(DE),A		;Insert char
	INC	(IY+0)
	INC	DE

nxtchr:	DJNZ	chalop		;Go round loop again

	EXX			;Check all wild fields exhausted
	LD	A,B
	OR	C
	EXX
	JR	NZ,dufwld
	JR	allok

dufwlx:	POP	HL		;Error return from star
	EXX
dufwld:	LD	A,badwld	;Error return - bad string match
tsterr:	LD	(err),A

allok:	LD	A,1

notmat:	LD	HL,(retsav)	;Get return address
	JP	(HL)







	COMMON	/error/

err:	DEFS	1


	DSEG


hshtbl:	DEFS	maxlen
statbl:	DEFS	maxlen*3

retsav:	DEFS	2



	END
.Z80
TITLE	Name matcher for ARGO FS
NAME	('Match')

PUBLIC	match, legal, tstren

;Changes:

; 2/10/84	ARG - MATCH only case equates if both strings alpha


;Error numbers

illnam	EQU	0CCH
badwld	EQU	2		;Duf wild carding in rename



;Misc

maxlen	EQU	10		;Max filename length (legal)

cr	EQU	13




;LEGAL
;FUNCTION legal (VAR fname: min_string; VAR chain_no: byte;
;		 VAR wild: BOOLEAN): BOOLEAN;
;
;Check for silliness in filename - >10 chars (-*s)
;Duf characters are %, :, $,False	; Normal RM version
large	EQU	FALSE	;8"disc version ?
nascom	EQU	True	;Nascom 2 version



	.COMMENT	*

HOW NASCOM PAGING WORKS

Port 0FFH divided into two groups of 4 bits

bits 0..3 control read enable
bits 4..7 control write enable

one bit per card in each group.

Main ram	bits 0,4
Our 2nd card	bits 1,5

On reset, latch set to 00, but fudge makes main RAM work until latch updated


HOW 380Z PAGING WORKS

<pagon> is the port address of the paging latch. Writing a byte to thso DO go on
	RET	M

	CP	'#'		;Match any charcter
	JR	NZ,match3

	LD	A,(HL)		;Get char it really is
	EXX
	LD	(DE),A		;Save char in table
	EX	AF,AF'
	INC	DE		;Inc #table pointer
	INC	C		;Inc number of #s
	LD	A,1		;Set wild flag
	EXX
	EX	AF,AF'
	JR	match2


match3:	PUSH	BC
	LD	C,A
	AND	5FH		;Knock out case bit
	CP	'A'		;Alpha ?
	JR	C,nalpha
	CP	'Z'+1
	JR	NC,nalpha
	LD	C,A
	LD	A,(HL)
	AND	5FH
	CP	'A'		;Alpha ?
	JR	C,nalpha
	CP	'Z'+1
	JR	C,cpmat		;Only case equate if BOTH are alpha	JR	wildm1








;FUNCTION tstren (VAR change_str: min_string; VAR new_name: min_string;
;		  VAR fname: min_string; addr: INTEGER;
;		  VAR go_on: BOOLEAN): BOOLEAN;

tstren:	SUB	A		;No errors to start with
	LD	(err),A
	POP	HL		;Save return address
	LD	(retsav),HL

	CALL	match		;Do match operation

	POP	DE		;Get start of string into DE
	PUSH	DE
	POP	IY		;Save start of string in IY
	LD	(IY+0),0	;Zero length of string initially
 	INC	DE		;Point to text
	POP	HL
	OR	A		;return now i

nalpha:	LD	A,(HL)		;Get back character
cpmat:	CP	C		;Compare
	POP	BC
	RET	NZ

match2:	INC	DE
	DEC	C
	INC	HL
	DJNZ	match1		;Count chars in master string
	CP	A		;cf=0
	INC	C
	RET

wildm:	EX	AF,AF'
	LD	A,1		;Set wild flag
	PUSH	HL
	EXX
	EX	DE,HL		;Get HL into DE' and save old DE'
	EX	(SP),HL
	EX	DE,HL
	INC	HL		;Put pointer into *table
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),0		;Set length to zero
	INC	B		;Inc * counter
	POP	DE		;Restore DE'
	EXX			;Back to old reg set
	Ef no match
	JR	Z,notmat

	LD	B,(HL)		;Check change string not null
	LD	A,B
	OR	A
	JR	NZ,try4it

	LD	A,illnam	;Bad string if so
	JP	tsterr

try4it:	EXX			;Get hash & star table pointers
	LD	HL,hshtbl
	LD	DE,statbl
	EXX

chalop:	INC	HL
	LD	A,(HL)		;Get char from change string
	CP	'*'		;Star ?
	JR	NZ,notsta

	PUSH	DE
	EXX
	DEC	B		;Got any star fields left ?
	JP	M,dufwlx
	EX	(SP),HL
	EX	DE,HL
	PUSH	BC
	LD	C,(HL)		;Get address and length of replace string
	INC	HL
	LD	B,(HL)
	INC	HLX	AF,AF'

	INC	DE
	DEC	B		;Test for * @ EOL
	JR	NZ,wildm1

	LD	A,C		;Fill in length in * table
	EXX
	INC	A
	LD	(HL),A
	EXX
	CP	A		;Set zf; Reset cf
	RET

wildm1:	PUSH	BC
	PUSH	DE
	PUSH	HL
	EXX
	PUSH	BC
	PUSH	DE
	PUSH	HL
	EXX
	CALL	match1
	EXX
	POP	HL
	POP	DE
	JR	NZ,wildm2	;If matched then BC is vaild
	INC	SP
	INC	SP
	JR	wildm3
wildm2:	POP	BC
wildm3:	EXX
	POP	HL
	POP	DE
	POP	BC
	RET	Z
	INC	HL
	EXX			;Increment string len in * table
	INC	(HL)
	EXX
	DEC	C
	SCF
	RET	M
D	A,(HL)
	CP	'A'
	LD	A,9
	JR	NC,chs1
	SUB	A
chs1:	LD	(DE),A
	POP	HL

	LD	A,(HL)		;Check not zero length
	PUSH	AF

	LD	B,A
	LD	C,0

vloop:	INC	HL
	LD	A,(HL)
	CP	'.'
	JR	NZ,vlop1
	LD	A,'*'
	LD	(HL),A
vlop1:	CP	'*'
	JR	Z,vlop0
	INC	C
	CP	'#'
	JR	NZ,vlop2
vlop0:	LD	(IY+0),1
vlop2:	CP	127
	JR	NC,dufstr
	CP	'!'
	JR	C,dufstr
	CP	'$'
	JR	Z,dufstr
	CP	'^'
	JR	Z,dufstr
	CP	'%'
	JR	Z,dufstr
	CP	':'
	JR	Z,dufstr
	DJNZ	vloop
	LD	A,C		;Check string not too long
	CP	maxlen+1
	JR	NC	;Set AF' to zero and save old AF'
	EX	AF,AF'		; note mixed ' terms in above comment
	PUSH	AF		; also that we end up with regs swopped

	PUSH	BC
	LD	A,(HL)		;String length
	INC	HL
	LD	B,A
	PUSH	HL
	PUSH	BC

	LD	A,cr
	LD	H,D
	LD	L,E
	LD	BC,11
	CPIR
	LD	A,9
	SUB	C		;a=(length of 'test' string)-1

	POP	BC		;string length
	POP	HL		;pointer to 'master' string
	LD	C,A

	EX	DE,HL
	CALL	match1		;On entry, HL -> test, DE -> master
	LD	A,0		;A = 0 => nomatch
	JR	NZ,insgo
	INC	A		;IF {match},dufstr
	POP	AF
	SUB	C		;Get number of *s
	CP	maxlen+1	;Too many ?
	JR	NC,dufst2
	LD	A,1		;Return TRUE
	RET

dufstr:	POP	AF		;Duf string => return false
dufst2:	SUB	A
	RET







;MATCH
;FUNCTION match (VAR fname: min_string; addr: INTEGER;
;		 VAR go_on: BOOLEAN): BOOLEAN;
;
;Routine to compare two strings - both are assumed real & no error
; checking is done

match:	POP	HL		;Return address
	POP	BC		;Go on flag
	POP	DE		;Dir string
	EX	(SP),HL		;HL=String addr, (SP)=Ret addr

 DO $(A:=TRUE;cf=0$)
	CP	A
insgo:	POP	HL		;addr of go_on flag
	PUSH	AF

	LD	(HL),0		;Insert Go_on flag
	RL	(HL)
	EX	AF,AF'		;IF wilds DO go_on:= TRUE
	OR	(HL)
	LD	(HL),A

	POP	AF
	EX	AF,AF'
	POP	AF
	EX	AF,AF'

	RET


;match1
;
;On exit:
; cf	set if go_on (ie 'master' string after test in alpha order)
; zf	set if match
; AF'	1 if significant wild before match failed (undef if match worked)

match1:	LD	A,(DE)
	CP	'*'
	JR	Z,wildm
	INC	C
	DEC	C
	SCF			;'Test' string is too short, ;Now we have
; HL	Master string (Length followed by bytes)
; DE	Test string (Terminated by <cr>)
; BC	Go on flag address

; *** FUDGE FOR ZERO LENGTH STRINGS FOLLOWS ***
	LD	A,(HL)		;Length
	OR	A
	JR	NZ,long		;Not zero length, so do everything

	LD	(BC),A		;Don't go on ever
	LD	A,(DE)
	CP	13		;Check for CR
	LD	A,1
	RET	Z
	DEC	A
	RET

; Here for normal length

long:	EXX			;Set Wild count to zero
	LD	BC,0
	LD	DE,hshtbl	;Set up pointers to #table & *table
	LD	HL,statbl-1
	EXX

	SUB	A	ec+1

	ENDM			;of REPT sectrk

	gap	300		;Final gap (gap 4) large to compensate
				; for variations in disk speed

	ELSE

; 5" disque

fordat:	DEFW	-1,-1,-1,-1,-1,-1,-1,-1
sec	DEFL	0

	REPT	sectrk

begblk	DEFL	$

	sync
	DEFB	0FEH

	IF	sec EQ 0
trknum	EQU	$
	ENDIF

	DEFB	0,0
	DEFB	sec,2,0F7H

	gap	11
	sync
	DEFB	0FBH

	do	512,0E5H

	DEFB	0F7H

	gap	74

endblk	DEFL	$
sec	DEFL	sec+1

	ENDM		;of REPT sectrk

	gap	160

	ENDIF		;of Large/small



blklen	EQU	endblk.Z80
TITLE	Name matcher for ARGO FS
NAME	('Match')

PUBLIC	match, legal, tstren

;Changes:

; 2/10/84	ARG - MATCH only case equates if both strings alpha


;Error numbers

illnam	EQU	0CCH
badwld	EQU	2		;Duf wild carding in rename



;Misc

maxlen	EQU	10		;Max filename length (legal)

cr	EQU	13




;LEGAL
;FUNCTION legal (VAR fname: min_string; VAR chain_no: byte;
;		 VAR wild: BOOLEAN): BOOLEAN;
;
;Check for silliness in filename - >10 chars (-*s)
;Duf characters are %, :, $,-begblk





	COMMON	/debug/

mesflg:	DEFS	1


	COMMON	/error/

errloc:	DEFS	1

	COMMON	/freebl/

dsksiz:	DEFS	maxdrv * 2

	COMMON	/cache/

cache1:	DEFS	1024		;Actually longer than this

	COMMON	/twosid/

dsflag:	DS	1

	DSEG


secsav:	DS	1		;Disk, track & sector saves for retry
trksav:	DS	1
drvsav:	DS	1
rdfsav:	DS	1

rcount:	DS	1

curtrk:	DEFS	2		;This points to something. Why no comment?

DMA:	DEFS	2		;Parameter to RWDISC

trkno:	DEFS	maxdrv		;Current tracks of drvs ^, < ! or > }
;Also converts .s to *s
;
;Puts chain number of filename into <chain_no>

legal:	POP	HL		;Return addr
	POP	IY		;wild flag
	POP	DE		;Chain number
	EX	(SP),HL		;Filename

	XOR	A
	LD	(IY+0),A	;Clear wild flag

; Check for zero length string

	CP	(HL)
	JR	NZ,long1	; (HL) is length, A is zero

	LD	(DE),A		; Chain no. 0
	INC	A		; Return value - True
	RET

long1:	PUSH	HL
	INC	HL
	LD	A,(HL)
	AND	5FH
	SUB	'A'
	JR	C,chs0
	CP	26
	JR	NC,chs0
	SRL	A
	INC	A
	JR	chs1
chs0:	L 0..4

rwmask:	DEFS	1		;Contains either FF or mask for settle time bit

lmask:	DEFS	1		;Mask for latch on RM disc ctrlr board


	END




secsav:	DS	1		;Disk, track & sector saves for retry
trksav:	DS	1
drvsav:	DS	1
rdfsav:	DS	1

rcount:	DS	1

curtrk:	DEFS	2		;This points to something. Why no comment?

DMA:	DEFS	2		;Parameter to RWDISC

trkno:	DEFS	maxdrv		;Current tracks of drvsight
; top bit =0 indicates read or write => use side sel ELSE use direction
;
;On entry:
; A	command byte
;
;On exit:
; A	knackered
; Rest	preserved

outcom:	PUSH	AF
 	RLCA
	LD	A,(lmask)
	RES	5,A		;b5=0 gives SSel
	JR	NC,outcm0
	SET	5,A
outcm0:	LD	(lmask),A
	OUT	(latch),A
	POP	AF
	OUT	(comand),A	;Send command
	LD	A,20		;100 microsecond delay
outcm2:	DEC	A		; for WD to have valid status
	JR	NZ,outcm2	; and side sel to take effect on drive
	RET



;Seek track zero - waits for compls go round all the time

	IN	A,(ctc0)	;Glowing anyway ?
	CP	0A0H
	JR	Z,sta0
	LD	A,(lmask)

	ENDIF

	OUT	(latch),A
	RET

sta0:	LD	A,(lmask)	;Set drive glowing
	OUT	(latch),A
sta1:	IN	A,(ctc0)	;Wait 16*64mS so it can get up speed
	CP	90H
	JR	NC,sta1
	RET



;
;
; *** DATA TABLES FOR FORMAT ***
;



do	MACRO	numb,byte
	REPT	numb/4
	DEFB	byte,byte,byte,byte
	ENDM
	REPT	numb MOD 4
	DEFB	byte
	ENDM
	ENDM

sync	MACRO
	DEFB	0,0,0,0,0,0
	ENDM

gap	MACRO	numb
	do	numb,0
	ENDetion
;
;On exit:
; A	zero
; Rest	preserved

seekz:	PUSH	HL
	LD	A,getzer	;with verify

; NB verifying operations are generally dangerous since SideSel is
; multiplexd with StepDirection: but on a 'Restore' cmd, Dir is defined
; before any step pulses are sent, such as to select side 0.

	CALL	outcom
	CALL	wairdy
	LD	HL,(curtrk)
	SUB	A
	LD	(HL),A
	POP	HL
	RET	


;Wait for not busy
;
;On exit:
; A	status

wairdy:	IN	A,(status)
	BIT	0,A
	JR	Z,wairdy
	RET


;Set up final motor oM

	IF	large

sec	DEFL	0		;Set start sector to zero

fordat:
	gap	40		;Pre-index gap (gap 5)
	sync
	DEFB	0FCH		;Index mark
	gap	26		;Post index gap (gap 1)

	REPT	sectrk

begblk	DEFL	$

	sync
	DEFB	0FEH		;ID address mark

	IF	sec EQ 0
trknum:
	ENDIF

	DEFB	0,0		;Sector info (inc CRC)
	DEFB	sec,2,0F7H

	gap	11		;Post ID field gap (gap 2)
	sync
	DEFB	0FBH		;Data address mark

	do	512,0E5H	;Data
	DEFB	0F7H		;Data CRC

	gap	90		;Post data gap (gap 3)

endblk	DEFL	$
sec	DEFL	sff

drvoff:
	IFF	large

	LD	A,047H		;Reset CTC to 0A0H
	OUT	(ctc0),A
	LD	A,0A0H
	OUT	(ctc0),A

	ENDIF

	LD	A,(lmask)	;Motor select hold off
	OR	40H
	LD	(lmask),A
	OUT	(latch),A
	RET


;Start drive in A
;Only used by format - similar code in-line for normal r/w
;(gross inefficiency)

stadrv:	LD	B,A
	AND	2
	RLCA
	RLCA
	RLCA
	LD	C,A
	LD	A,89H		;Drv 1 + Drv 4 + Dint |
	BIT	0,B
	JR	Z,sta2
	LD	A,8AH		;Drv 2 + Drv 4 + Dint |
sta2:	OR	C		;SSel
	LD	(lmask),A

	IFF	large		;8" driveking

retrys:	LD	A,H		;Save R/W flag
	LD	HL,rwmask	;Address of mask containing settle time bit
	OR	A
	JR	Z,write

;Read a sector

read:	LD	A,rdsec
	AND	(HL)		;Insert settle time
	CALL	outcom
	LD	HL,(DMA)	;Set address to R/W to/from
	LD	D,9CH		;mask for relevant error bits

read0:	IN	A,(status)
	RRCA
	JR	C,rwret
	RRCA
	JR	C,read0
	IN	A,(data)
	CPL
	LD	(HL),A
	INC	HL
	JP	read0




;Write out a sector

write:	LD	A,wrsec
	AND	(HL)		;Insert settle time
	CALL	outcom
	LD	HL,(DMA)	A,C
	CALL	cahex

;print 1771 Trk, Sec registers

	IN	A,(track)
	CPL
	CALL	cahex
	IN	A,(sector)
	CPL
	CALL	cahex

; and expected Trk, Sec values

	LD	A,(trksav)
	CALL	cahex
	LD	A,(secsav)
	CALL	cahex

	LD	A,(mesflg)
	OR	A
	JR	Z,debug1

;set HLD bit for next time around

	LD	A,settle
	LD	(rwmask),A

	emt	kywait		;doesn't zap registers
debug1:
	ENDIF

	LD	DE,(secsav)	;Reload HL,DE
	LD	HL,(drvsav)
	BIT	4,C		;T/S not found ?
	JP	Z,retrys	;No => CRC error only => No reseek
	CAL;Set address to R/W to/from
	LD	D,0FCH

write0:	LD	A,(HL)
	CPL
	LD	B,A
write2:	IN	A,(status)
	RRCA
	JR	C,write4
	RRCA
	JR	C,write2
	LD	A,B
	OUT	(data),A
	INC	HL
	JP	write0

write4:	PUSH	AF		;Write finished so wait for tunnel erase to end
	LD	BC,3700/29	; 1ms minus allowance for shortest code to
write5:	DEC	BC		; next call of OUTCOM
	LD	A,B		; 29 is the no. of T states in the loop.
	OR	C
	JR	NZ,write5
	POP	AF		;useful instruction as A has been PUSHed before

;drop through

;Return fL	seekz		;If T/S not found reseek trk zero
	JP	retryt


; NB this is not necessarily an error return
;
; On entry, C=error code (=0 for OK)

giveup:
	LD	A,C
	OR	A
	JR	Z,timrt0
	LD	HL,errloc
	LD	(HL),199

	IF	t.on
	PUSH	BC
	mess	errmsg		;'Fatal error' message
	POP	BC
	PUSH	BC
	LD	A,C
	CALL	cahex
	CALL	pcrlf
	POP	BC
	ENDIF
timrt0:

	CALL	drvoff		;Turn of drive motor after ~10 secs

	EI

	RET			;C=error number




;outcom
;Output command - getting the SSel/Dir multiplexor rrom Read or Write

rwret:	RLCA			;Move byte back the way it came
	OUT	(pagoff),A	;Turn off cache memory
	CPL			;Data bus all inverted !
	AND	D		;Mask out silly bits
	LD	C,A		;Save error number in case we want to retry
	JR	Z,giveup	;OK ?

; Not Ready,Write prot,Write fault,Lost data are all fatal

	AND	0E7H
	JR	NZ,giveup

	LD	A,(rcount)	;How many goes have we had at this sector ?
	CP	maxtry		;Too many ?
	JR	NC,giveup
	INC	A
	LD	(rcount),A

	IF	t.on
	PUSH	BC
	mess	rtrmsg

	POP	BC
	LD		ELSE

;Divide by five - Leaves result in A & remainder 

	LD	DE,-500H
tscon1:	ADD	HL,DE
	JR	C,tscon0
	SBC	HL,DE
tscon0:	RLA
	SRA	D
	RR	E
	JP	NC,tscon1

	LD	D,A		;Swap regs - so correct for output
	LD	E,L

	ENDIF

	POP	HL		;drive now in L (0..3)


;Convert drive number into drive bits

	SUB	A
	LD	B,L
	INC	B		;As drive numbers start at 0
	SCF
cdrnol:	RLA
	DJNZ	cdrnol
	LD	L,A		;has a single bit set in it.

;Start drive in A and select the correct side

	LD	A,(dsflag)	;Double sPOP	HL
	POP	DE
l4:	POP	AF
	ENDIF


;On entry to here:
; D	track
; E	sector
; H	read flag

	LD	(secsav),DE	;Save in case of retrys
	LD	(drvsav),HL

retryt:	LD	BC,(curtrk)	;Get pointer to current track
	LD	A,(BC)
	CP	D		;Already there?
	PUSH	AF		;Save Z flag in particular
	LD	A,-1
	JR	Z,nosetl
	LD	A,settle	;Settle time mask for read or write command
nosetl:	LD	(rwmask),A	;Save for read/write command

	LD	A,D		;Dest track
	LD	(BC),A		;Update track store
	CPL
	OUT	(data),A	; And preparided ?
	OR	A
	LD	A,L		;Drive bits
	JR	Z,stadr2
	SRL	D		;Modify track number (/2)
	JR	NC,stadr2
	OR	10H		;Other side
stadr2:	LD	L,A		;Save for trace
	OR	88H		;Drv4 + Dint |

	PUSH	HL
	LD	(lmask),A

	IN	A,(status)	;Ready ?
	BIT	7,A

	PUSH	AF
	LD	A,(lmask)
	OUT	(latch),A	;Set drive glowing
	AND	1		;Use as offset for track store
	LD	C,A		; WON'T WORK ON >2 DRIVES ***************
	POP	AF

	IFF	large		;8" drives go round all the time

	JR	NZ,stadr3	;Ready => going round

stadr1:	IN	A,(ce to seek

	LD	A,seek
	CALL	outcom		;Do it
	CALL	wairdy		;Seek with no verify can cause no errors

;wait for head to load (=output from CTC)

headld:	IN	A,(status)
	AND	020H		;Test head load (=0 for loaded)
	JR	NZ,headld

	POP	AF		;NZ if we have done a real seek, so insert
	JR	Z,nowait	;RML-style wait

	LD	A,4
headl2:	LD	B,0
	DJNZ	$		;15*256*4=15000T,4 ms.
	DEC	A
	JR	NZ,headl2

nowait:	LD	A,E		;Fill in sector
	CPL
	OUT	(sector),A
	DI			;Stop interrupts

;retry sector without re-seetc0)	;Wait 16*64mS so it can get up speed
	CP	90H
	JR	NC,stadr1

	ENDIF

stadr3:	LD	HL,trkno	;Work out track address
	LD	B,0
	ADD	HL,BC
	LD	A,(HL)
	LD	(curtrk),HL	;Save address of current track store
	OR	A
	CALL	M,seekz		;-ve => not used before so seek track zero
	CPL
	OUT	(track),A	;update track register
	POP	HL

	IF	t.on
trace:	mcond	l4
	PUSH	AF
	PUSH	DE
	PUSH	HL
	PUSH	DE
	PUSH	HL
	mess	dtsmsg
	POP	HL
	CALL	dhxout
	POP	HL
	CALL	dhxout
	mess	atmsg
	LD	HL,(DMA)
	CALL	dhxout
	0:	LD	(HL),A
 	ADD	HL,DE
	DJNZ	form0

	LD	A,writrk
	CALL	outcom
	LD	HL,fordat
	LD	C,data


form2:	LD	A,(HL)
	CPL
	LD	B,A
	INC	HL
form6:	IN	A,(status)
	RRCA
	RET	C
	RRCA
	JR	C,form6
	OUT	(C),B
	JR	form2




;vtrk
;Verify a track
;
;On entry:
; A	track number

vtrk:	CPL
	OUT	(data),A
	LD	A,seek
	CALL	outcom
	CALL	wairdy

	LD	BC,sectrk*256

vtrk0:	CALL	vsec
	INC	C
	CPL
	RLCA
	AND	0FCH
	JR	Z,vsecok

;Sector was duff so print status

	PUSH	BC
	PUSH	AF
	mess	vererhave =0 for read, =FF for write
	CPL			; =FF for read, =0 for write
	LD	D,A

	ADD	HL,HL		;Block * 2 = Sector

	PUSH	HL
	PUSH	DE
	CALL	rwdisc		;Get first
	POP	DE
	POP	HL
	INC	C		;Error => return now
	DEC	C
	RET	NZ

	LD	A,(DMA+1)	;Hi byte of memory address
	ADD	A,2		;Sector is 2 pages long
	LD	(DMA+1),A
	INC	HL		;Next sector
	CALL	rwdisc

	IF	t.on
	LD	A,(mesflg)
	OR	A
	CALL	NZ,pcrlf
	ENDIF

	RET




;RWDISC
;Read/Write sector to/from disk
;
;On entry:
;    (DMA)	memory addrr
	POP	AF
 	CALL	CAHEX
	mess	atmsg
	IN	A,(track)
	CPL
	CALL	CAHEX
	mess	secmsg
	IN	A,(sector)
	CPL
	CALL	CAHEX
	POP	BC

vsecok:	DJNZ	vtrk0
	RET


;vsec
;Verify a sector on current track
;
;On entry:
; C	sector number
;
;On exit:
; A	WD error number
; rest	preserved

vsec:	LD	A,C
	OR	A		;ZF on sector 0 which needs settle time
	CPL
	OUT	(sector),A

	LD	A,rdsec		;read 1 sector with no settle time
	JR	NZ,setlof
	AND	settle
setlof:	CALL	outcom

reed0:	IN	A,(status)
	RRCA
	Ress to write to/get from
;	 D	Read flag (FF-read,0-write)
;	 E	Disk number
;	 HL	sector no.
;
;On exit:
; C	Error code (0 = OK)
;	(errloc) also updated


rwdisc:	SUB	A
	LD	(rcount),A	;Set retry count to zero

	PUSH	DE		;Save disk & read flag

;Convert sector number (HL) into track/sector (DE)

	IF	large

;Divide by eight

	LD	A,L
	AND	7		;Remainder MOD 8
	LD	E,A
	ADD	HL,HL		;*2
	ADD	HL,HL		;*4
	ADD	HL,HL		;*8
	ADD	HL,HL		;*16
	ADD	HL,HL		;*32
	LD	D,H		; div 8 <=> *32 DIV 256

ET	C
	RRCA
	JR	C,reed0
	IN	A,(data)
	JP	reed0







; PROCEDURE Rw_blk(read:Boolean; VAR buffer:C_ent; disc:Byte; blkno:Word);
;
; Write out 1k block to disc from main memory <buffer>.

rwblk:	XOR	A		;No error yet
	LD	(errloc),A

	POP	BC		;Return addr
	POP	HL		;blockno.
	POP	AF		;Disc no.
	POP	DE		;Memory address of buffer
	
	LD	(DMA),DE	;Entry param for RWDISC
	LD	E,A		;Drive

	POP	AF		;read flag
	PUSH	BC		;Return addr.

				;Initially =1 for read, =0 for write
	DEC	A		;now on stack for <rwblk>

chkSJ:	LD	A,1		;Read flag (=True)
	PUSH	AF
	LD	HL,cache1	;Read into 1st cache entry
	PUSH	HL
	XOR	A		;Drive no.
	PUSH	AF
	LD	HL,0		;Block no.
	PUSH	HL
	CALL	rwblk

	LD	A,(errloc)	;Had error ?
	OR	A
	RET	NZ		; Give up


iniok:	LD	HL,cache1+sjoff	;Where we put the block + Offset of SJ string
	LD	DE,sjmess	;Check it's an SJ disk
	LD	B,23		;B:= len SJstring

csjlop:	LD	A,(DE)
	CP	(HL)
	JR	NZ,inierr
	INC	HL
	INC	DE
	DJNZ	csjlop

;	Set/reset dsflag according to fl


form5:	LD	BC,4000/29	;1ms Delay for Tunnel Erase
deloop:	DEC	BC		;Loop is 29 T-states (assuming wait states)
	LD	A,B
	OR	C
	JR	NZ,deloop

	POP	AF		;Loop counter/track no.
	POP	DE		;notracks in D
	INC	A
	CP	D
	JR	Z,exitf
	PUSH	DE
	PUSH	AF
	LD	A,trkinc
	CALL	outcom
	CALL	wairdy
	POP	AF
	JR	form3


;
; PROCEDURE Verify(drive,notracks);
;
;Verify all tracks
;

verify:	POP	HL		;Return addr
	POP	DE		; D:=notracks
	POP	AF		;drive
	PUSH	HL
	PUSH	DE

	CALL	stadrv
	CALL	seekz

ag in blk 0

	LD	A,(cache1+dsfoff)	;double sidedness
	AND	1			;leave relevant bit
	LD	(dsflag),A

	RET

;	Error exit. iabort is entry if errloc already set.

inierr:	LD	A,1		;Duff data in blk 0
	LD	(errloc),A
	RET


;
; PROCEDURE Format(drive,notracks:Byte);
;
; Format specified drive - drive nos 0..3 give sides separately
;


format:	DI
	POP	HL
	POP	DE		;notracks to D, junk to E
	POP	AF		;drive
	LD	E,A
	PUSH	HL		;Return address
	PUSH	DE

;	Stack holds DE - D=notracks=maxtrack+	SUB	A		;start at Trk 0
ver1:	PUSH	AF	
	CALL	vtrk
	POP	AF		;Loop counter
	POP	DE		;notracks,drive
	PUSH	DE
	INC	A
	CP	D		;notracks
	JR	NZ,ver1

	POP	DE		;Discard

; done all the tracks

exitf:	CALL	drvoff
	EI
	CALL	dkinit		;Track stores are junk due to step commands
				;so Zap them.
	RET			;return to external caller



;fortrk
;Format a track
;
;On entry:
; A	track number
;
;On exit:
; A	WD status

fortrk:	LD	B,sectrk	;Fill in track numbers
	LD	HL,trknum
	LD	DE,blklen
form1, E=driveno.

	ADD	A,'A'
	LD	(drvmsg),A	;Poke part of format drive message

	LD	DE,formsg	;Now print it
	CALL	pmess

	POP	DE		;notracks,drivE
	PUSH	DE
	LD	A,E

	CALL	stadrv		;start drive A
	CALL	seekz		;restore

form7:	SUB	A

form3:	PUSH	AF
	CALL	fortrk
	CPL
	RLCA
	AND	0FCH
	JR	Z,form5

	PUSH	AF
	LD	DE,forerr
	CALL	pmess
	POP	AF
 	CALL	CAHEX
	LD	DE,atmsg
	CALL	pmess
	IN	A,(track)
	CPL
	CALL	CAHEX
	POP	DE		;Discard notracks
	POP	AF		;Discard track no.
	JR	exitf		;Give upck:	DB	0
dsec:	DB	0
	DB	022H		;2* 256 byte sector
derror:	DB	0		;=0 on exit if no error



	COMMON	/debug/

mesflg:	DEFS	1


	COMMON	/error/

errloc:	DEFS	1

	COMMON	/freebl/

dsksiz:	DEFS	maxdrv * 2


	DSEG

cacmap:	DEFS	noblks*4	;Cache sector map


page:	DEFS	1		;Current cache page

rwpage:	DEFS	1		;Parameter to RWDISC

csize:	DEFS	1		;Number of usable blocks in cache.

dsflag:	DEFS	1		;Double sided bit map

zeros:	DEFS	1024		;Contains 0s !!

;	******* MAPMAN AREAS ****
	AND	03H		;Now back in right place
	LD	E,A

	PUSH	HL
	PUSH	DE
	CALL	rwdisc		;Get first
	POP	DE
	POP	HL
	INC	C		;Error => return now
	DEC	C
	JR	Z,nxtsec

blkdud:	DEC	D		;Test for read operation
	RET	Z		;Write, so no need to zap blockno.
	LD	(IY+2),0FFH
	LD	(IY+3),0FFH	;Mark as empty since contains junk
	RET

nxtsec:	LD	A,(rwpage)
	ADD	A,2		;Sector is 2 pages long
	LD	(rwpage),A
	INC	HL		;Next sector
	CALL	rwdisc
	INC	C
	DEC	C
	JR	NZ,blkdud

	IF	t.on
	mcond	blkm
	CALL	pcrlf
	PU*****

lstadr:	DEFS	2		;Address of last block found

mapptr:	DEFS	maxdrv*4	;( length (2) + mapptr (2) ) * maxdrv

myheap:	DEFS	heapln


	END
 ache sector map


page:	DEFS	1		;Current cache page

rwpage:	DEFS	1		;Parameter to RWDISC

csize:	DEFS	1		;Number of usable blocks in cache.

dsflag:	DEFS	1		;Double sided bit map

zeros:	DEFS	1024		;Contains 0s !!

;	******* MAPMAN AREAS ****SH	AF		;To allow for the compulsory POP following
blkm:	POP	AF		;Jumped to from mcond.
	ENDIF

	RET




;RWDISC
;Read/Write sector to/from disk
;
;On entry:
;    (rwpage)	Page number to write to/get from
;	 D	Read flag (FF-read,0-write)
;	 E	Disk number
;	 HL	sector no.
;
;On exit:
; C	Error code (0 = OK)
;	(errloc) also updated


	IF nascom

rwdisc:	
	IF	t.on
	LD	A,(rwpage)
	tmess	<dtsmsg,HL,atmsg,AF>
	ENDIF

	LD	C,D		;Save r/w flag
	LD	A,E		;Test for drive 1
	OR	A
	JR	Z,d= OK)
;	(errloc) also updated
; (IY)	Needs writing flag cleared always. Blockno zapped if read error

rwblk:	LD	(IY+1),0FFH	;Clear needs writing flag

	PUSH	IY
	POP	HL		;Calculate page no. from table offset
	LD	BC,cacmap	;Start of table
	OR	A		;Clear carry
	SBC	HL,BC
	LD	A,L		;the answer

	LD	(rwpage),A	;Entry param for RWDISC

	LD	L,(IY+2)	;blockno.
	LD	A,(IY+3)	; Hi byte also holds drive
	AND	3FH		;not any more
	LD	H,A
	ADD	HL,HL		;Block * 2 = Sector

	LD	A,(IY+3)	;Drive
	RLCA
	RLCAHL)
	LD	H,A
	CP	A
	SBC	HL,DE
	JP	C,ranerr

	POP	HL
	POP	AF

	ENDIF			;** End of range check **

	EX	DE,HL
	ADD	HL,BC
	POP	BC
	LD	B,C
	RET


	IF	c.on

;Bad map number / map not initialized

maperr:	error	'Bad map number'

;Block number out of range

ranerr:	error	'Duf block number'

	ENDIF




;PROCEDURE fblk (VAR block: block_descrip; VAR no_block: WORD);
;
;Attempt to find up to no_block blocks starting from block_descrip

fblk:	POP	HL		;Return address
	POP	BC		;no_blo,A
	DEC	HL
	DEC	HL
	JP	fstart



;Found it

fblk2:	EX	DE,HL
	POP	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	POP	HL
	PUSH	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	CP	A
	LD	E,A
	JP	fblk12

;Find how many free & allocate them

fblk7:	INC	IX
	LD	E,(IX+0)
	LD	B,C
fblk9:	CP	A
	RR	E
	JR	NC,fblk11
fblk12:	DEC	HL
	LD	A,H
	OR	L
	JR	Z,fblk11
	DJNZ	fblk9
	RR	E
	LD	(IX+0),E
	JP	fblk7

;Wind up

fblk11:	RR	E		;Allocate out of last byte
	DJNZ	fblk11
	LD	(IX+0),E
	EX	DE,HL

	POP	HLck
	EX	(SP),HL		;block_descrip
	PUSH	IX
	PUSH	BC

fstart:	LD	A,(HL)		;Drive
	INC	HL
	PUSH	HL		;Save address of block number
	LD	E,(HL)		;get block number
	INC	HL
	LD	D,(HL)

	EX	DE,HL
	PUSH	HL
	CALL	getblk
	LD	C,8
	CP	A		;Clear carry for RRA
	DEC	B
	LD	A,(HL)
	JR	Z,fblk1
fblk0:	RRA
	DEC	C
	DJNZ	fblk0
fblk1:	LD	B,C
	PUSH	AF
	PUSH	BC
	PUSH	HL
	EX	DE,HL
	INC	HL
	LD	D,(HL)
	DEC	HL
	LD	E,(HL)
	DEC	HL
	LD	B,(HL)
	DEC	HL
	LD	C,(HL)
	EX	DE,HL
	ADD	HL,BC
	POP	BC
	PUSH	BC
	POP			;Fill in blocks found
	LD	(HL),E
	INC	HL
	LD	(HL),D

	POP	IX
	RET
;
; ****** END OF MAPMAN ******
;

;
; Osword block for osword &FF - r/w of i/o processor RAM
;

cblock:	DB	0DH,1
ioaddr:	DB	0,0,0,0
zaddr:	DB	0,0,0,0
clen:	DB	0,0
crdwr:	DB	0		;0=write to i/o proc, 1=read from i/o proc

;
; Osword block for disc r/w
;

dblock:
ddrive:	DB	0
daddr:	DB	0,0,0FFH,0FFH	;Address - hi bytes &FFFF since always i/o proc
	DB	3		;No. of params
drdwr:	DB	04BH		;&53 = read, &4B = write
dtraIX
	CP	A
	SBC	HL,BC
	EX	DE,HL
	POP	BC
	POP	AF
	POP	HL
	LD	C,8
	JP	fblk3

;Main find loop
;
;On entry:
; BC	8
; DE	number of bytes to search before giving up
; HL	start block number
; IX	pointer to current byte to search

fblk4:	LD	A,(IX+0)
	OR	A
	JR	NZ,fblk6
	ADD	HL,BC
	JP	fblk5
fblk6:	LD	B,C
fblk3:	RRA
	JR	C,fblk2
	INC	HL
	DJNZ	fblk3
fblk5:	INC	IX
	DEC	DE
	LD	A,E
	OR	D
	JP	NZ,fblk4

;NOT found at all so retry starting at block zero

	POP	HL
	LD	(HL),A
	INC	HL
	LD	(HL)	LD	HL,dsflag
	AND	(HL)		;Test for double sided
	JR	Z,onesid
	LD	A,D		;Track
	CP	80
	JR	C,onesid	;Side 0 if trk 0..79
	LD	A,159		;tracks 80..159 map onto 79..0 on side 1
	SUB	D
	LD	D,A
	SET	1,C		;Add 2 to drive no.
onesid:


;On entry to here:
; D	track
; E	sector
; B	read flag
; C	drive/side

	LD	A,C
	LD	(ddrive),A	;Set up osword block
	LD	A,D
	LD	(dtrack),A
	LD	A,E
	SLA	A		;*2 for use with 256 byte sectors
	LD	(dsec),A

	LD	A,B
	OR	A		;Read flag
	LD	A,04BH		;Write op-code
	JRet drive
	INC	HL
	LD	B,(HL)		; & block number
	INC	HL
	LD	H,(HL)
	LD	L,B

;	tmess	<alblk0,HL,alblk1,AF,crlf>

	CALL	getblk
	CPL
	AND	(HL)
	LD	(HL),A
	SUB	A
	RET



;GETBLK
;Converts Map number & Block Number into address and bit number
;
;On entry:
; A	Map number
; HL	Block number
;
;On exit:
; A	Byte with bit set
; B	1 - 8 => Bit number
; DE	Points to low byte of address in MAPPTR (length @(DE-2))
; HL	Address of byte

getblk:	PUSH	HL

	CP	maxdrv
	JP	NC,maperr

	ADD	A,A	Z,notrd
	LD	A,053H		;Read op-code
notrd:	LD	(drdwr),A

	IF	t.on
trace:	mcond	l4
	PUSH	AF
	PUSH	DE
	PUSH	BC
	mess	dtsmsg
	POP	HL
	CALL	dhxout
	POP	HL
	CALL	dhxout
	mess	atmsg
	LD	A,(rwpage)
	CALL	cahex
l4:	POP	AF
	ENDIF

	LD	HL,ramlow	;Cache base
	LD	A,(rwpage)	;Page offset
	ADD	A,H
	LD	H,A
	LD	(daddr),HL

	LD	A,07FH		;Disc osword number
	LD	HL,dblock
	CALL	osword

	LD	A,(derror)
	LD	C,A		;Result reg
	OR	A
	RET	Z

	LD	HL,errloc
	LD	(HL),0C7H	;Disc error

	PUSH	BC
	mess
	ADD	A,A
	LD	C,A
	LD	B,0
	LD	HL,mapptr+3
	ADD	HL,BC
	EX	(SP),HL

	LD	A,L		;HL/8, A=Remainder
	AND	7
	SRL	H
	RR	L
	SRL	H
	RR	L
	SRL	H
	RR	L

	LD	B,A		;Set bit A in A
	INC	B
	LD	C,B
	SUB	A
	SCF
getbl1:	RLA
	DJNZ	getbl1

	POP	DE
	PUSH	BC
	EX	DE,HL
	LD	B,(HL)		;BC:= address of map
	DEC	HL
	LD	C,(HL)

	IF	c.on		;** Range check block **

	PUSH	AF		;Check map exists
	LD	A,B
	AND	C
	INC	A
	JP	Z,maperr

	PUSH	HL		;Check valid block number
	DEC	HL
	LD	A,(HL)
	DEC	HL
	LD	L,(	errmsg
	POP	BC
	RET


;
;  ****** BIT MAP MANAGEMENT CODE STARTS HERE *************
;
;


;PROCEDURE dalloc (blk: block_descrip);

dalloc:	POP	HL		;Return address
	EX	(SP),HL		;Blk address

	LD	A,(HL)		;Get drive
	INC	HL
	LD	B,(HL)		; & block number
	INC	HL
	LD	H,(HL)
	LD	L,B

	tmess	<frblk0,HL,alblk1,AF,crlf>

	CALL	getblk
	OR	(HL)
	LD	(HL),A
	SUB	A
	RET



;PROCEDURE alloc (blk: block_descrip);

alloc:	POP	HL		;Return address
	EX	(SP),HL		;Blk address

	LD	A,(HL)		;GHL=^previous ent

setpag:	LD	HL,cacmap
	LD	B,0			;BC now = previous page no.
	ADD	HL,BC

	LD	A,(IY+0)
	LD	(HL),A			; previous^.next:=new_ent^.next
	LD	A,(page)
	LD	(IY+0),A		; new_ent^.next:=head_ptr
	LD	A,E
	LD	(page),A		; head_ptr:=new_ent

	SCF
	RET




;RWBLK
;Read/Write block to/from disk
;
;
;On entry:
; D	Read flag (&FF -> read, 0 -> write)
; IY	Points to map entry
;(page)	**NOT USED** (hence we can write blocks not at head of chain)
;
;On exit:
; C	Error code (0 = OK)
;To allow for the compulsory POP following
blkm:	POP	AF		;Jumped to from mcond.
	ENDIF

	RET




;RWDISC
;Read/Write sector to/from disk
;
;On entry:
;    (rwpage)	Page number to write to/get from
;	 D	Read flag (FF-read,0-write)
;	 E	Disk number
;	 HL	sector no.
;
;On exit:
; C	Error code (0 = OK)
;	(errloc) also updated


rwdisc:	PUSH	DE		;Save disk & read flag

;Convert sector number (HL) into track/sector (DE)

	IF	large

;Divide by eight

	LD	A,L
	AND	7		;Remainder MOD 8	(errloc) also updated
; (IY)	Needs writing flag cleared always. Blockno zapped if read error

rwblk:	LD	(IY+1),0FFH	;Clear needs writing flag

	PUSH	IY
	POP	HL		;Calculate page no. from table offset
	LD	BC,cacmap	;Start of table
	OR	A		;Clear carry
	SBC	HL,BC
	LD	A,L		;the answer

	LD	(rwpage),A	;Entry param for RWDISC

	LD	L,(IY+2)	;blockno.
	LD	A,(IY+3)	; Hi byte also holds drive
	AND	3FH		;not any more
	LD	H,A
	ADD	HL,HL		;Block * 2 = Sector

	LD	A,(IY+3)	;Drive
	RLCA
	RLCA
	AND	0
	LD	E,A
	ADD	HL,HL		;*2
	ADD	HL,HL		;*4
	ADD	HL,HL		;*8
	ADD	HL,HL		;*16
	ADD	HL,HL		;*32
	LD	D,H		; div 8 <=> *32 DIV 256

	ELSE

;Divide by five - Leaves result in A & remainder in L

	XOR	A
	LD	DE,-500H
tscon1:	ADD	HL,DE
	JR	C,tscon0
	SBC	HL,DE
tscon0:	RLA
	SRA	D
	RR	E
	JP	NC,tscon1

	LD	D,A		;Swap regs to match 8" vers
	LD	E,L

	ENDIF

	POP	BC		;drive now in C (0..1)

	LD	A,C
	OR	A		;Drive 0 or 1?
	LD	A,1		;flags unchanged
	JR	Z,drv0
	RLCA			;Carry clear, so A:=2
drv0:3H		;Now back in right place
	LD	E,A

	PUSH	HL
	PUSH	DE
	CALL	rwdisc		;Get first
	POP	DE
	POP	HL
	INC	C		;Error => return now
	DEC	C
	JR	Z,nxtsec

blkdud:	DEC	D		;Test for read operation
	RET	Z		;Write, so no need to zap blockno.
	LD	(IY+2),0FFH
	LD	(IY+3),0FFH	;Mark as empty since contains junk
	RET

nxtsec:	LD	A,(rwpage)
	ADD	A,2		;Sector is 2 pages long
	LD	(rwpage),A
	INC	HL		;Next sector
	CALL	rwdisc
	INC	C
	DEC	C
	JR	NZ,blkdud

	IF	t.on
	mcond	blkm
	CALL	pcrlf
	PUSH	AF		;lock to zero to give correct value in areas not initialised
;	by the user

clrblk:	LD	A,B
	SUB	4		; 0400H <=> 1K <=> block size
	OR	C
	JR	Z,rdywr		;ready to write

	PUSH	BC
	PUSH	HL
	PUSH	DE

	LD	HL,0400H
	LD	(clen),HL	;Length
	LD	HL,zeros	;RAM containing 1K of 0s
	LD	(zaddr),HL
	LD	HL,ramlow	;Base of cache
	LD	A,(page)
	ADD	A,H		;Add in entry offset
	LD	H,A
	LD	(ioaddr),HL

	XOR	A		;Write op-code =0
	LD	(crdwr),A

	DEC	A		;A=0FFH
	LD	HL,cblock
	CALL	osword

	POP	DE
	POP	HL
	Paddress of cacmap entry
	ADD	IY,DE

	LD	A,(IY+2)
	CP	L
	JR	NZ,filop1		;No good
	LD	A,(IY+3)		;Test hi byte
	CP	H
	JR	Z,found			;Both agree

filop1:					;Get here if this block no good
	DJNZ	filoop			;Fall through if we have tried all ents

; Now have tail of chain

	PUSH	HL			;Save blockno.
	CALL	setpag			;Make this into head of chain
	LD	A,(IY+1)		;Needs writing flag
	OR	A			; sets Zf, also clears Cf
	JR	NZ,setblk		;Not required, so just insert blkno.
	LD	D,0			;r/w flag set to write
	OP	BC
	JR	rdywr


;fiblk
;
;Find block in cache.
; If block not found, return the tail of the chain, making it the head
; then writing out if necessary & inserting the new info in the map.
;
;On entry:
; HL	address of block descriptor (drive then block)
;
;On exit:
;(page)	updated
; IY	points to entry in cacmap
; cf	set	Found
;	clear	Not found
;
; HL,DE,BC registers all used
;

fiblk:

;Put drive in top 2 bits of block number

	LD	A,(HL)			;Drive
	RRCA
	RRCA				;Put in top 2 bitsCALL	rwblk
setblk:	POP	HL			;Get back blockno.
	LD	(IY+2),L
	LD	(IY+3),H		;Store in map
	OR	A			;Clear carry <=> not found
	RET


;	Found already in cache, so set carry for return & drop through
;	to move to head of chain if not already there.

found:	LD	A,(page)
	CP	E			;Test for already head of chain
	SCF
	RET	Z			;Return to save looping up chain

;	Move the new entry to the top of the chain
;	IY points to new entry, C is previous page, E is new page
;	On exit, carry set, A=(page), B=0, 
	INC	HL
	LD	E,(HL)			;Lo(block)
	INC	HL
	OR	(HL)			;Hi byte add to drive bits
	LD	D,A
	EX	DE,HL

;	fudge to get started - note that link pointer is at start of map entry

	LD	IY,page			;Start of chain - IY usually points to
					; the previous entry
	LD	D,0

;	HL=block/drive no, D=0
;	In loop, DE=page no, C=previous page no.

	LD	A,(csize)		;Number of entries to search
	LD	B,A			;For DJNZ

filoop:	LD	C,E			;Save previous pageno
	LD	E,(IY+0)		;Advance to next
	LD	IY,cacmap		;Calculate OP	BC
	EX	(SP),HL
	EX	DE,HL

;	Now have: HL=source offset, BC=length, DE=destination address

	IF	t.on
	mcond	rdm1
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	DE
	mess	rdmess
	LD	L,(IY+2)	;Blockno.
	LD	H,(IY+3)
	CALL	dhxout
	mess	adrmsg
	POP	HL
	CALL	dhxout
	mess	atmsg
	LD	A,(page)
	CALL	cahex
	CALL	pcrlf
	POP	HL
	POP	DE
	POP	BC
rdm1:	POP	AF
	ENDIF

	LD	(clen),BC	;Set up control block for Osword
	LD	(zaddr),DE

	LD	A,(page)	;Add page offset to user's offset
	ADD	A,H
	LD	H,AL
	PUSH	HL
	mess	wrmess
	LD	L,(IY+2)	;Blockno.
	LD	H,(IY+3)
	CALL	dhxout
	mess	adrmsg
	POP	HL
	CALL	dhxout
	mess	atmsg
	LD	A,(page)
	CALL	cahex
	CALL	pcrlf
	POP	HL
	POP	DE
	POP	BC
wrm1:	POP	AF
	ENDIF

	JR	NZ,clrblk	;No pre-read means zap to =0
	JR	C,rdywr		; Carry => it's been pre-read anyway

	PUSH	BC
	PUSH	DE
	PUSH	HL

	LD	D,0FFH		; r/w flag (read)

	LD	A,B		;Now test for BC=0400H => don't read
	SUB	4		;because the whole blk will be over-written
	OR	C
	CALL	NZ,rwblk	;IY cont
	LD	BC,ramlow	;Start of cache RAM
	ADD	HL,BC
	LD	(ioaddr),HL

	LD	A,1		;Read op-code
	LD	(crdwr),A

	LD	A,0FFH		;Processor to processor RAM copy
	LD	HL,cblock
	JP	osword

;	RET			;Finished





;PROCEDURE disc_wr(addr,length,offset:Word;pre_read:Boolean;blk:block_descrip);
;
; Write up to 1 block from specified address. <offset> is offset in block.
; Errors are returned in common area <error>
;


discwr:	POP	HL		;Return address
	EX	(SP),HL		; addr of block descriptor


	CALL	fibains all other info

	POP	HL
	POP	DE
	POP	BC

;	Now ready to write (into cache)
;	HL=source, DE=offset to dest., BC=byte count
rdywr:
	LD	(IY+1),0	;Needs writing (or soon will!)

	LD	(zaddr),HL	;Set up Osword control block
	LD	(clen),BC

	LD	HL,ramlow	;Base addr of cache
	ADD	HL,DE		;Add user's offset
	LD	A,(page)	;Now add entry offset
	ADD	A,H
	LD	H,A
	LD	(ioaddr),HL

	XOR	A		;Reason code - Write
	LD	(crdwr),A

	DEC	A		;A=&FF
	LD	HL,cblock
	JP	osword		;Call & return


;	Clear blk		;Takes ^blk in HL, returns IY ^map entry,
				;Cf set if found, Else we have the former tail

	LD	HL,errloc 	;This user is not interested in any error
	LD	(HL),0  	; to do with previous contents of page

	POP	HL		;Return address
	POP	BC		;Pre_read flag
	DEC	B		;Pre_read now in Z flag, carry unchanged
	POP	DE		;Offset
	POP	BC		;Length
	EX	(SP),HL		;Source addr to HL

;	Now have Z <=> pre-read, NZ=> no read, C=> already in cache
;
	IF	t.on
	mcond	wrm1
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	Hand param points to a string)
	mess	param
	ELSE
	IF	'&param' EQ 'AF'
	POP	AF
	CALL	cahex
	ELSE
	POP	HL
	CALL	dhxout
	ENDIF
	ENDIF
	ENDIF
	ENDM

	POP	HL
	POP	DE
	POP	BC

nomess:	POP	AF

	ENDIF

	ENDM



pstat	MACRO	sw,mes1,mes2
	IF1
	IF	sw
	IFNB	<mes1>
.PRINTX	mes1
	ENDIF
	ELSE
	IFNB	<mes2>
.PRINTX	mes2
	ENDIF
	ENDIF
	ENDIF
	ENDM


	
	pstat	t.on,<Tracing ON>
.PRINTX	 (VERY) long macro expansion.......




crlf:	DEFM	cr,lf,'$'


	IF	t.on

;dhxout
;Print heA
	JR	NZ,idl1		;Doesn't need it

	PUSH	BC
				;D already contains 0 (meaning write)
	CALL	rwblk

	POP	BC
	DEC	B
	RET	Z		;Written as many as we want to

idl1:	LD	E,(IY+0)	;pointer to next entry in chain
	DEC	C		;Counter to prevent checking more entries
	JR	NZ,idloop	;than there are cache entries

	RET




;PROCEDURE cempty
;
;Write out any part of the cache which still has things in.

cempty:	LD	B,noblks	;Max number of blks that could possibly
mtloop:	PUSH	BC		;need writing
	CALL	cix of HL

dhxout:	LD	A,H
	CALL	cahex
	LD	A,L
				;DROP THROUGH
;cahex
;Print hex of A
;
;On entry:
; A	number to be printed

	JP	cahex		;Now lives in h2lib or some such place

	ENDIF

;
; Print a crlf!
pcrlf:	LD	DE,crlf
	JP	pmess


dtsmsg:	DEFM	' RDTS=$'
atmsg:	DEFM	' @ $'
errmsg:	DEFM	' fatal disc error $'
rtrmsg:	DEFM	' bad $'
formsg:	DEFM	cr,lf,'Formatting drive '	;Message continues below
drvmsg:	DEFM	'?$'				; - ? is poked at run time
forerr:	DEFM	cr,lf,'Format error &$'
veredle
	POP	BC
	DJNZ	mtloop
	RET



;PROCEDURE disc_rd(addr,length,offset:Word;VAR blk:block_descrip);
;
; Read in up to 1 block to specified address. <offset> is offset in block.
; Errors returned in common area <error>
;

discrd:	XOR	A
	LD	(errloc),A	;No error yet

	POP	HL
	EX	(SP),HL		;Get blockno. address

	CALL	fiblk		;Returns HL pointing to map entry
	JR	C,incach	;Carry => block already in cache

	LD	D,0FFH		;r/w flag =READ.
	CALL	rwblk

incach:	POP	HL		;Return addr.
	POP	DE
	Prr:	DEFM	cr,lf,'Verify error &$'
secmsg:	DEFM	' sector &$'






;PROCEDURE dkinit;
;
;This procedure should be called before performing any disc operations
;

dkinit:	LD	HL,trkno	;Current track table
	LD	B,maxdrv-1	;length of it
lowlp1:	LD	(HL),-1		;Zap to indicate drive not yet used
	INC	HL
	DJNZ	lowlp1
	RET


;  PROCEDURE Chk_SJ; EXTERNAL;
;
; Read blk0 into 1st cache entry, set DS flag, check for SJ disc.
; Set <error> =1 means disc OK, but no SJ message


;	Set up parameters /84 Restore cmd has verify
; 22/3/84 Various waiting code for Tunnelling etc
; 4/4/84  Dkman edited to produce DISC512

true	EQU	-1
false	EQU	0

t.on	EQU	true	;Trace

large	EQU	TRUE	;8"disc version ?

.COMMENT	*

    Globals <error> and <two_sid> are used. <error> is set on exit to indicate
   any error, although an error message will have already been displayed.
    <two_sid> is True on entry if the disc is to be treated as double sided.
    Format has drive nos. in the range 0..3 for two s


ctc	EQU	038H		;Ch0 driven from INTRQ
				;Ch1 derives motor on



;Misc equates

lf	EQU	10
cr	EQU	13

maxdrv	EQU	4		;Allowed up to 4 8" drives

maxtry	EQU	2		;Two retrys allowed



; Various Macros



;Macro to print string @ messadr

mess	MACRO	messadr

	IF	messadr EQ crlf
	CALL	pcrlf
	ELSE
	LD	DE,messadr
	CALL	pmess
	ENDIF

	ENDM



;Macro for message condition

mcond	MACRO	addr
	PUSH	AF
	LD	A,(mesflg)
	OR	A
	JR	Z,addr
	POP	AF
	ENDM



;Trace message macides separately.

	*


PUBLIC	Rwblk, dkinit, Format, Verify, chkSJ, Fivein, Vermsg

EXT	pmess, cahex, verhi, verlo


; RM emt numbers

kywait	EQU	34	;wait for key, ctrl-F active


;Drive manifests

home	EQU	004H	;Seek trk 0 + Step 3/6mS + Head Load +    verify
seek	EQU	01CH	;Seek trk n + Step 3/6ms + Head Load +    verify
rdsec	EQU	080H	;Read 1 sec + No settle time + No side compare
wrsec	EQU	0A0H	;Write 1 sec + No settle + no side comp + Data mark
trkinc	EQU	058H	;+1 Trk + inc reg + Stro

tmess	MACRO	list
	LOCAL	nomess

	IF	t.on

	mcond	nomess

	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL

count	DEFL	0

	IRP	param,<list>	;Count:= number of params
count	DEFL	count + 1
	ENDM

i	DEFL	count		;i:= count

	REPT	count
	IFF	i AND 1		;ie I is even
j	DEFL	0

	IRP	param,<list>
j	DEFL	j+1
	IF	(j EQ i)
	PUSH	param
	ENDIF
	ENDM			;of IRP param....

	ENDIF
i	DEFL	i-1
	ENDM			;of REPT count

i	DEFL	0

	IRP	param,<list>
	IFNB	<param>
i	DEFL	i+1
	IF	i AND 1		;ie I is odd (ep 3/6mS + Head Load + No Verify
writrk	EQU	0F4H	;Write track + settle time



;Port numbers

	IF	large
sectrk	EQU	8	;For format
	ELSE
sectrk	EQU	5
	ENDIF

fdc	EQU	4

status	EQU	fdc+0
comand	EQU	fdc+0
track	EQU	fdc+1
sector	EQU	fdc+2
data	EQU	fdc+3

latch	EQU	017H		;Disc control latch :
				;Bits 0-3 : drv sel 0-3
side1	EQU	010H		;Bit  4   : Side sel
inch8	EQU	020H		;Bit  5   : 5" if lo, 8" if hi
				;Bit  6   : dden if lo, single density if hi
				;Bit  7   : Hi for write precompexit:
; C	Error code (0 = OK)
;	(errloc) also updated


rwdisc:
	PUSH	DE		;Save disk & read flag

;Convert sector number HL into track D & sector (secno)

	IF	large

;Divide by eight

	LD	A,L
	AND	7		;Remainder MOD 8
	LD	(secno),A
	ADD	HL,HL		;*2
	ADD	HL,HL		;*4
	ADD	HL,HL		;*8
	ADD	HL,HL		;*16
	ADD	HL,HL		;*32
	LD	D,H		; div 8 <=> *32 DIV 256

	

	ELSE

;Divide by five - Leaves result in A & remainder in L

	XOR	A

	LD	DE,-500H
tscon1:	ADD	HL,DE
	JR	C,tscon0
	SBC	HL,DE
tress of paging window
	LD	(rwaddr+1),A		;Address to read/write
					;(low byte =0 always)
	POP	AF

	PUSH	IX			;Must preserve IX (for Propas)
	LD	IX,emtblk
	OR	A
	DI				;Disc routines speed sensitive
	JR	Z,write
	EMT	rdsec
	JR	finish

write:	EMT	wrsec

;
; On entry, A=error code (=0 for OK)

finish:
	EI
	POP	IX
	OUT	(pagoff),A	;Turn off paged RAM (value immaterial)
	JR	Z,timrt0	;No error
	LD	HL,errloc
	LD	(HL),199

	IF	t.on
	PUSH	AF
	mess	errmsg		;'Fatal error' message
	POP	AF
	scon0:	RLA
	SRA	D
	RR	E
	JP	NC,tscon1

	LD	D,A		;Swap regs - so correct for output
	LD	A,L
	LD	(secno),A

	ENDIF

; Now have D=trk, (secno)=sector, E undef.

	POP	HL		;drive now in L (0..3), H=read flag


;Convert drive number into drive bits

	SUB	A
	LD	B,L
	INC	B		;As drive numbers start at 0
	SCF
cdrnol:	RLA
	DJNZ	cdrnol
	LD	B,A		;has a single bit set in it.


	LD	A,(dsflag)	;Double sided ?
	AND	B
	LD	A,L		;Drive no.
	JR	Z,stadr2
	SRL	D		;Modify track number (/2)
	JR	NC,stPUSH	AF
	CALL	cahex
	CALL	pcrlf
	POP	AF
	ENDIF
timrt0:
	LD	C,A

	RET			;C=error number


emtblk:				;Paramater block for disc EMTs
discno:	DB	0
trkno:	DB	0
secno:	DB	0
rwaddr:	DW	0		;Low byte not initialised - hence in CSEG






	COMMON	/debug/

mesflg:	DEFS	1


	COMMON	/error/

errloc:	DEFS	1

 TITLE	Disk R/W & format routines for 380Z 512 bytes/sector
NAME	('Disc512')
.Z80
; modifications:
; 18/3/84 Floppy code now works on SS discs in DS drives (only an 8" bug)
; 19/3adr2
	ADD	A,2		;Other side
stadr2:	LD	(discno),A	;Save drive no. in param block
	LD	L,A		;And in L for trace msg
	LD	A,D
	LD	(trkno),A

	LD	A,H		;Read flag

	IF	t.on
trace:	mcond	l4
	PUSH	AF
	PUSH	HL
	mess	dtsmsg
	POP	HL	
	CALL	dhxout
	LD	HL,(trkno)
	CALL	dhxout
	mess	atmsg
	LD	A,(rwpage)
	CALL	cahex
l4:	POP	AF
	ENDIF


;On entry to here:
; A	read flag

	PUSH	AF

	LD	A,(rwpage)
	OUT	(pagon),A		;Turn on paged RAM

	AND	3			;Low bits = offset in block
	ADD	A,HIGH secbuf		;Addsav:	DS	1
rdfsav:	DS	1

rcount:	DS	1

curtrk:	DEFS	2		;This points to something. Why no comment?

DMA:	DEFS	2		;Parameter to RWDISC

trkno:	DEFS	maxdrv		;Current tracks of drvs 0..4

rwmask:	DEFS	1		;Contains either FF or mask for settle time bit

lmask:	DEFS	1		;Mask for latch on RM disc ctrlr board


	END



an this

	COMMON	/twosid/

dsflag:	DS	1

	DSEG


secsav:	DS	1		;Disk, track & sector saves for retry
trksav:	DS	1
drv
	LD	A,L		;the answer

	LD	(rwpage),A

	LD	L,(IY+2)	;blockno.
	LD	A,(IY+3)	; Hi byte also holds drive
	AND	3FH		;not any more
	LD	H,A
	ADD	HL,HL		;Block * 2 = Sector

	LD	A,(IY+3)	;Drive
	RLCA
	RLCA
	AND	03H		;Now back in right place
	LD	E,A

	PUSH	HL
	PUSH	DE
	CALL	rwdisc		;Get first
	POP	DE
	POP	HL
	INC	C		;Error => return now
	DEC	C
	JR	Z,nxtsec

blkdud:	DEC	D		;Test for read operation
	RET	Z		;Write, so no need to zap blockno.
	LD	(IY+2),0FFH
	LD	(IY+3),0FFH	;Mark as empty si	LD	H,D		;Get start
	LD	L,E
	INC	DE		;Clear map
	DEC	BC
	LD	(HL),-1

	tmess	<naloc0,BC,naloc1,HL,crlf>

	LDIR

	POP	DE		;Reset bits in last byte to indicate
	LD	A,E		; if not all availible
	AND	7
	JR	Z,inidk0
	LD	B,A
	SUB	A
inidk1:	SCF
	RLA
	DJNZ	inidk1
inidk0:	LD	(HL),A

	RET




;Heap error (overflow)

heaped:	error	'Heap oflow'





;PROCEDURE cidle
;
; Use FS idle time to write out any of the cache that needs it.
; Starts from the head, which means that under heavy lnce contains junk
	RET

nxtsec:	LD	A,(rwpage)
	ADD	A,2
	LD	(rwpage),A
	INC	HL		;Next sector
	CALL	rwdisc
	INC	C
	DEC	C
	JR	NZ,blkdud

	IF	t.on
	mcond	blkm
	CALL	pcrlf
	PUSH	AF		;To allow for the compulsory POP following
blkm:	POP	AF		;Jumped to from mcond.
	ENDIF

	RET





;RWDISC
;Read/Write sector to/from disk
;
;On entry:
;    (rwpage)	PAGE number to write to/get from (ie. 2 low bits are RAM addr)
;	 D	Read flag (FF-read,0-write)
;	 E	Disk number
;	 HL	sector no.
;
;On 


;RWBLK
;Read/Write block to/from disk
;
;
;On entry:
; D	Read flag (&FF -> read, 0 -> write)
; IY	Points to map entry
;(page)	**NOT USED** (hence we can write blocks not at head of chain)
;
;On exit:
; C	Error code (0 = OK)
;	(errloc) also updated
; (IY)	Needs writing flag cleared always. Blockno zapped if read error

rwblk:	LD	(IY+1),0FFH	;Clear needs writing flag

	PUSH	IY
	POP	HL		;Calculate page no. from table offset
	LD	BC,cacmap	;Start of table
	OR	A		;Clear carry
	SBC	HL,BC
	LD	HL,(curtrk)
	SUB	A
	LD	(HL),A
	POP	HL
	RET	


;Wait for not busy
;
;On exit:
; A	status

wairdy:	IN	A,(status)
	BIT	0,A
	JR	Z,wairdy
	RET


;Set up final motor off

drvoff:
	IFF	large

	LD	A,047H		;Reset CTC to 0A0H
	OUT	(ctc0),A
	LD	A,0A0H
	OUT	(ctc0),A

	ENDIF

	LD	A,(lmask)	;Motor select hold off
	OR	40H
	LD	(lmask),A
	OUT	(latch),A
	RET


;Start drive in A
;Only used by format - similar code in-line for normal r/w
;(gross inefficiency)

stadrv:	LD	B,A
	AND
	gap	11		;Post ID field gap (gap 2)
	sync
	DEFB	0FBH		;Data address mark

	do	512,0E5H	;Data
	DEFB	0F7H		;Data CRC

	gap	90		;Post data gap (gap 3)

endblk	DEFL	$
sec	DEFL	sec+1

	ENDM			;of REPT sectrk

	gap	300		;Final gap (gap 4) large to compensate
				; for variations in disk speed

	ELSE

; 5" disque

fordat:	DEFW	-1,-1,-1,-1,-1,-1,-1,-1
sec	DEFL	0

	REPT	sectrk

begblk	DEFL	$

	sync
	DEFB	0FEH

	IF	sec EQ 0
trknum	EQU	$
	ENDIF

	DEFB	0,0
	DEFB	sec,2,0F7H

	gap		2
	RLCA
	RLCA
	RLCA
	LD	C,A
	LD	A,89H		;Drv 1 + Drv 4 + Dint |
	BIT	0,B
	JR	Z,sta2
	LD	A,8AH		;Drv 2 + Drv 4 + Dint |
sta2:	OR	C		;SSel
	LD	(lmask),A

	IFF	large		;8" drives go round all the time

	IN	A,(ctc0)	;Glowing anyway ?
	CP	0A0H
	JR	Z,sta0
	LD	A,(lmask)

	ENDIF

	OUT	(latch),A
	RET

sta0:	LD	A,(lmask)	;Set drive glowing
	OUT	(latch),A
sta1:	IN	A,(ctc0)	;Wait 16*64mS so it can get up speed
	CP	90H
	JR	NC,sta1
	RET



;
;
; *** DATA TABLES FOR FORMAT ***
;



d11
	sync
	DEFB	0FBH

	do	512,0E5H

	DEFB	0F7H

	gap	74

endblk	DEFL	$
sec	DEFL	sec+1

	ENDM		;of REPT sectrk

	gap	160

	ENDIF		;of Large/small



blklen	EQU	endblk-begblk





	COMMON	/debug/

mesflg:	DEFS	1


	COMMON	/error/

errloc:	DEFS	1

	COMMON	/freebl/

dsksiz:	DEFS	maxdrv * 2

	COMMON	/cache/

cache1:	DEFS	1024		;Actually longer than this

	COMMON	/twosid/

dsflag:	DS	1

	DSEG


secsav:	DS	1		;Disk, track & sector saves for retry
trksav:	DS	1
drvo	MACRO	numb,byte
	REPT	numb/4
	DEFB	byte,byte,byte,byte
	ENDM
	REPT	numb MOD 4
	DEFB	byte
	ENDM
	ENDM

sync	MACRO
	DEFB	0,0,0,0,0,0
	ENDM

gap	MACRO	numb
	do	numb,0
	ENDM

	IF	large

sec	DEFL	0		;Set start sector to zero

fordat:
	gap	40		;Pre-index gap (gap 5)
	sync
	DEFB	0FCH		;Index mark
	gap	26		;Post index gap (gap 1)

	REPT	sectrk

begblk	DEFL	$

	sync
	DEFB	0FEH		;ID address mark

	IF	sec EQ 0
trknum:
	ENDIF

	DEFB	0,0		;Sector info (inc CRC)
	DEFB	sec,2,0F7H
C		; next call of OUTCOM
	LD	A,B		; 29 is the no. of T states in the loop.
	OR	C
	JR	NZ,write5
	POP	AF		;useful instruction as A has been PUSHed before

;drop through

;Return from Read or Write

rwret:	RLCA			;Move byte back the way it came
	OUT	(pagoff),A	;Turn off cache memory
	CPL			;Data bus all inverted !
	AND	D		;Mask out silly bits
	LD	C,A		;Save error number in case we want to retry
	JR	Z,giveup	;OK ?

; Not Ready,Write prot,Write fault,Lost data are all fatal

	AND	0E7H
	JR	NZ,lf
	POP	BC
	ENDIF
timrt0:

	CALL	drvoff		;Turn of drive motor after ~10 secs

	EI

	RET			;C=error number




;outcom
;Output command - getting the SSel/Dir multiplexor right
; top bit =0 indicates read or write => use side sel ELSE use direction
;
;On entry:
; A	command byte
;
;On exit:
; A	knackered
; Rest	preserved

outcom:	PUSH	AF
 	RLCA
	LD	A,(lmask)
	RES	5,A		;b5=0 gives SSel
	JR	NC,outcm0
	SET	5,A
outcm0:	LD	(lmask),A
	OUT	(latch),A
	POP	AF
	OUT	(comand),A	;Send commgiveup

	LD	A,(rcount)	;How many goes have we had at this sector ?
	CP	maxtry		;Too many ?
	JR	NC,giveup
	INC	A
	LD	(rcount),A

	IF	t.on
	PUSH	BC
	mess	rtrmsg

	POP	BC
	LD	A,C
	CALL	cahex

;print 1771 Trk, Sec registers

	IN	A,(track)
	CPL
	CALL	cahex
	IN	A,(sector)
	CPL
	CALL	cahex

; and expected Trk, Sec values

	LD	A,(trksav)
	CALL	cahex
	LD	A,(secsav)
	CALL	cahex

	LD	A,(mesflg)
	OR	A
	JR	Z,debug1

;set HLD bit for next time around

	LD	A,settle
	LD	(rwmask),A

and
	LD	A,20		;100 microsecond delay
outcm2:	DEC	A		; for WD to have valid status
	JR	NZ,outcm2	; and side sel to take effect on drive
	RET



;Seek track zero - waits for completion
;
;On exit:
; A	zero
; Rest	preserved

seekz:	PUSH	HL
	LD	A,getzer	;with verify

; NB verifying operations are generally dangerous since SideSel is
; multiplexd with StepDirection: but on a 'Restore' cmd, Dir is defined
; before any step pulses are sent, such as to select side 0.

	CALL	outcom
	CALL	wairdy	emt	kywait		;doesn't zap registers
debug1:
	ENDIF

	LD	DE,(secsav)	;Reload HL,DE
	LD	HL,(drvsav)
	BIT	4,C		;T/S not found ?
	JP	Z,retrys	;No => CRC error only => No reseek
	CALL	seekz		;If T/S not found reseek trk zero
	JP	retryt


; NB this is not necessarily an error return
;
; On entry, C=error code (=0 for OK)

giveup:
	LD	A,C
	OR	A
	JR	Z,timrt0
	LD	HL,errloc
	LD	(HL),199

	IF	t.on
	PUSH	BC
	mess	errmsg		;'Fatal error' message
	POP	BC
	PUSH	BC
	LD	A,C
	CALL	cahex
	CALL	pcrng the items
; near the tail will never be written. However, these items will tend
; to get written anyway as the entries are either used & brought back
; to the top of the cache, or get thrown out to make space for new entries.

cidle:	LD	A,(page)
	LD	E,A		;place to start
	LD	A,(csize)	;Maximum no. of ents worth looking at
	LD	C,A
	LD	B,3		;Maximum no. of blocks we have time to write

idloop:	LD	IY,cacmap
	LD	D,0		;Turn E into 16-bit value
	ADD	IY,DE
	LD	A,(IY+1)	;Get needs writing flag
	OR	
headl2:	LD	B,0
	DJNZ	$		;15*256*4=15000T,4 ms.
	DEC	A
	JR	NZ,headl2

nowait:	LD	A,E		;Fill in sector
	CPL
	OUT	(sector),A
	DI			;Stop interrupts

;retry sector without re-seeking

retrys:	LD	A,H		;Save R/W flag
	LD	HL,rwmask	;Address of mask containing settle time bit
	OR	A
	JR	Z,write

;Read a sector

read:	LD	A,rdsec
	AND	(HL)		;Insert settle time
	CALL	outcom
	LD	HL,(DMA)	;Set address to R/W to/from
	LD	D,9CH		;mask for relevant error bits

read0:	IN	A,(status)
	RRCA
	JR	C,rwrHL

	IF	t.on
trace:	mcond	l4
	PUSH	AF
	PUSH	DE
	PUSH	HL
	PUSH	DE
	PUSH	HL
	mess	dtsmsg
	POP	HL
	CALL	dhxout
	POP	HL
	CALL	dhxout
	mess	atmsg
	LD	HL,(DMA)
	CALL	dhxout
	POP	HL
	POP	DE
l4:	POP	AF
	ENDIF


;On entry to here:
; D	track
; E	sector
; H	read flag

	LD	(secsav),DE	;Save in case of retrys
	LD	(drvsav),HL

retryt:	LD	BC,(curtrk)	;Get pointer to current track
	LD	A,(BC)
	CP	D		;Already there?
	PUSH	AF		;Save Z flag in particular
	LD	A,-1
	JR	Z,nosetl
	LD	A,settle	;et
	RRCA
	JR	C,read0
	IN	A,(data)
	CPL
	LD	(HL),A
	INC	HL
	JP	read0




;Write out a sector

write:	LD	A,wrsec
	AND	(HL)		;Insert settle time
	CALL	outcom
	LD	HL,(DMA)	;Set address to R/W to/from
	LD	D,0FCH

write0:	LD	A,(HL)
	CPL
	LD	B,A
write2:	IN	A,(status)
	RRCA
	JR	C,write4
	RRCA
	JR	C,write2
	LD	A,B
	OUT	(data),A
	INC	HL
	JP	write0

write4:	PUSH	AF		;Write finished so wait for tunnel erase to end
	LD	BC,3700/29	; 1ms minus allowance for shortest code to
write5:	DEC	BSettle time mask for read or write command
nosetl:	LD	(rwmask),A	;Save for read/write command

	LD	A,D		;Dest track
	LD	(BC),A		;Update track store
	CPL
	OUT	(data),A	; And prepare to seek

	LD	A,seek
	CALL	outcom		;Do it
	CALL	wairdy		;Seek with no verify can cause no errors

;wait for head to load (=output from CTC)

headld:	IN	A,(status)
	AND	020H		;Test head load (=0 for loaded)
	JR	NZ,headld

	POP	AF		;NZ if we have done a real seek, so insert
	JR	Z,nowait	;RML-style wait

	LD	A,4it's an SJ disk
	LD	BC,23*256+1	;B:= len SJstring , C:= error not SJ
csjlop:	LD	A,(DE)
	CP	(HL)
	JR	NZ,inierr
	INC	HL
	INC	DE
	DJNZ	csjlop

	POP	BC		;B:= drive
	PUSH	BC
	INC	B		;1..5

;set bit B in A

	LD	A,80H
sbilop:	RLCA
	DJNZ	sbilop
	LD	C,A		;has 1 one
	CPL			;has 1 zero

;Set/Reset bit in dsflag

	LD	IY,($HPLM)	;Where the block was put
	LD	HL,dsflag
	AND	(HL)		;first reset bit
	LD	B,A
	LD	A,(IY+dsfoff)	;double sidedness
	AND	C		;leave relevant bit
	OR	B		;add in rest of dri,BC		;HL+:= A * 4
	ADD	HL,BC

	EXX			;Current heap address
	PUSH	HL
	EXX
	POP	BC

	LD	(HL),B		;Save current heap address in pointer table
	DEC	HL
	LD	(HL),C
	DEC	HL
	LD	(HL),D		;Also save length
	DEC	HL
	LD	(HL),E

	PUSH	DE		;Add length to heap
	EXX
	EX	DE,HL
	EX	(SP),HL
	ADD	HL,DE
	JP	C,heaped	;cf => heap > 0FFFFH !
	PUSH	HL
	LD	DE,myheap+heapln	;Check past end of heap
	SBC	HL,DE
	POP	HL
	JP	NC,heaped
	POP	DE
	EXX

	PUSH	BC
	PUSH	DE
	POP	BC		;Note: BC <-> DE
	POP	DE

	LD	ves
	LD	(HL),A

	LD	L,(IY+blkoff)	;HL:= number of blocks on disk
	LD	H,(IY+blkoff+1)


	POP	AF		;drive 0..4
	PUSH	AF
	CALL	inione		;Do that drive
	POP	AF
	DEC	A		;Repeat until finished
	JP	P,inilp0

	RET

;	Error exit. iabort is entry if errloc already set.

inierr:	LD	A,1		;Duff data in blk 0
	LD	(errloc),A
iabort:	POP	HL		;old drive no(rubbish)
	RET			;(errloc) set by rwdisc

b0tab:	DEFB	0		;This is a block descriptor for blk0
	DEFW	0		; the drive will be poked at run time


;INH,D		;Get start
	LD	L,E
	INC	DE		;Clear map
	DEC	BC
	LD	(HL),-1

	tmess	<naloc0,BC,naloc1,HL,crlf>

	LDIR

	POP	DE		;Reset bits in last byte to indicate
	LD	A,E		; if not all availible
	AND	7
	JR	Z,inidk0
	LD	B,A
	SUB	A
inidk1:	SCF
	RLA
	DJNZ	inidk1
inidk0:	LD	(HL),A

	RET




;Heap error (overflow)

heaped:	error	'Heap oflow'





;PROCEDURE cidle
;
; Use FS idle time to write out any of the cache that needs it.
; Starts from the head, which means that under heavy loadiIONE
;Initialise one drive
;
;On entry:
; A	Drive number
; HL	Number of blocks to allocate

inione:
	tmess	<almsg0,AF,almsg1,HL>

	PUSH	HL		;Save number of blocks
	EX	DE,HL		;DE:= no_of_blocks

	ADD	A,A		;Get address in mapptr
	LD	C,A		;BC:= A * 2
	LD	B,0

	LD	HL,dsksiz	;Put into disk size table
	ADD	HL,BC
	LD	(HL),E
	INC	HL
	LD	(HL),D

	SRМ	D		;Converф Blockу tп Byteу tп allocate
	RТ	E
	SRL	D
	RR	E
	SRL	D
	RR	E
	INC	DE

	LD	HL,mapptr+3	;+3 => point to map address (H)
	ADD	HLivide by eight

	LD	A,L
	AND	7		;Remainder MOD 8
	LD	E,A
	ADD	HL,HL		;*2
	ADD	HL,HL		;*4
	ADD	HL,HL		;*8
	ADD	HL,HL		;*16
	ADD	HL,HL		;*32
	LD	D,H		; div 8 <=> *32 DIV 256

	ELSE

;Divide by five - Leaves result in A & remainder 

	LD	DE,-500H
tscon1:	ADD	HL,DE
	JR	C,tscon0
	SBC	HL,DE
tscon0:	RLA
	SRA	D
	RR	E
	JP	NC,tscon1

	LD	D,A		;Swap regs - so correct for output
	LD	E,L

	ENDIF

	POP	HL		;drive now in L (0..3)


;Convert drive number into drive bits

	SUB	A
	LD	B,L
to make a spare register
	LD	B,0
	LD	C,H
	ADD	IY,BC		;Set IY to point to the block 
	POP	BC		; just tested

cilop1:	INC	H		;Proceed to next block
	INC	H
	INC	H
	INC	H
	JR	NZ,cilop0


	XOR	A
	LD	(page),A	;Head of chain pointer



; B=number of blocks in cache

	LD	A,B
	LD	(csize),A


	IF	t.on
	XOR	A
fudge1:	INC	A
	DAA			; Simple convert binary to BCD!
	DJNZ	fudge1
	CALL	cahex
	mess	cfrmes
	ENDIF

	POP	AF		;drive

	EXX			;Init heap
	LD	HL,myheap
	EXX

; this loop occurs 	INC	B		;As drive numbers start at 0
	SCF
cdrnol:	RLA
	DJNZ	cdrnol
	LD	L,A		;has a single bit set in it.

;Start drive in A and select the correct side

	LD	A,(dsflag)	;Double sided ?
	OR	A
	LD	A,L		;Drive bits
	JR	Z,stadr2
	SRL	D		;Modify track number (/2)
	JR	NC,stadr2
	OR	10H		;Other side
stadr2:	LD	L,A		;Save for trace
	OR	88H		;Drv4 + Dint |

	PUSH	HL
	LD	(lmask),A

	IN	A,(status)	;Ready ?
	BIT	7,A

	PUSH	AF
	LD	A,(lmask)
	OUT	(latch),A	;Set drive glowing
	AND	1		;Use as offsonce for each disk

inilp0:	PUSH	AF		;drive
	LD	(b0tab),A	;Put drive in block descriptor

;	Set up parameters on stack for <discrd>


	LD	HL,($hplm)	;Read this block above the system heap
	PUSH	HL
	LD	HL,0400H	;Length
	PUSH	HL
	LD	H,0		;Offset
	PUSH	HL
	LD	HL,b0tab	;Block descriptor set up to be blk0
	PUSH	HL
	CALL	discrd

	LD	A,(errloc)	;Had error ?
	OR	A
	JR	NZ,iabort


iniok:	LD	HL,($hplm)	;Where we put the block
	LD	BC,sjoff	;Offset of SJ string
	ADD	HL,BC
	LD	DE,sjmess	;Check et for track store
	LD	C,A		; WON'T WORK ON >2 DRIVES ***************
	POP	AF

	IFF	large		;8" drives go round all the time

	JR	NZ,stadr3	;Ready => going round

stadr1:	IN	A,(ctc0)	;Wait 16*64mS so it can get up speed
	CP	90H
	JR	NC,stadr1

	ENDIF

stadr3:	LD	HL,trkno	;Work out track address
	LD	B,0
	ADD	HL,BC
	LD	A,(HL)
	LD	(curtrk),HL	;Save address of current track store
	OR	A
	CALL	M,seekz		;-ve => not used before so seek track zero
	CPL
	OUT	(track),A	;update track register
	POP	al caller



;fortrk
;Format a track
;
;On entry:
; A	track number
;
;On exit:
; A	WD status

fortrk:	LD	B,sectrk	;Fill in track numbers
	LD	HL,trknum
	LD	DE,blklen
form0:	LD	(HL),A
 	ADD	HL,DE
	DJNZ	form0

	LD	A,writrk
	CALL	outcom
	LD	HL,fordat
	LD	C,data


form2:	LD	A,(HL)
	CPL
	LD	B,A
	INC	HL
form6:	IN	A,(status)
	RRCA
	RET	C
	RRCA
	JR	C,form6
	OUT	(C),B
	JR	form2




;vtrk
;Verify a track
;
;On entry:
; A	track number

vtrk:	CPL
	OUT	(data),A
	LD	A,seekry address of buffer
	
	LD	(DMA),DE	;Entry param for RWDISC
	LD	E,A		;Drive

	POP	AF		;read flag
	PUSH	BC		;Return addr.

				;Initially =1 for read, =0 for write
	DEC	A		;now have =0 for read, =FF for write
	CPL			; =FF for read, =0 for write
	LD	D,A

	ADD	HL,HL		;Block * 2 = Sector

	PUSH	HL
	PUSH	DE
	CALL	rwdisc		;Get first
	POP	DE
	POP	HL
	INC	C		;Error => return now
	DEC	C
	RET	NZ

	LD	A,(DMA+1)	;Hi byte of memory address
	ADD	A,2		;Sector is 2 pages long
	LD	(DMA+1),A
	INC	H
	CALL	outcom
	CALL	wairdy

	LD	BC,sectrk*256

vtrk0:	CALL	vsec
	INC	C
	CPL
	RLCA
	AND	0FCH
	JR	Z,vsecok

;Sector was duff so print status

	PUSH	BC
	PUSH	AF
	mess	vererr
	POP	AF
 	CALL	CAHEX
	mess	atmsg
	IN	A,(track)
	CPL
	CALL	CAHEX
	mess	secmsg
	IN	A,(sector)
	CPL
	CALL	CAHEX
	POP	BC

vsecok:	DJNZ	vtrk0
	RET


;vsec
;Verify a sector on current track
;
;On entry:
; C	sector number
;
;On exit:
; A	WD error number
; rest	preserved

vsec:	LD	A,C
	OR	A		;ZF on sectoL		;Next sector
	CALL	rwdisc

	IF	t.on
	LD	A,(mesflg)
	OR	A
	CALL	NZ,pcrlf
	ENDIF

	RET




;RWDISC
;Read/Write sector to/from disk
;
;On entry:
;    (DMA)	memory address to write to/get from
;	 D	Read flag (FF-read,0-write)
;	 E	Disk number
;	 HL	sector no.
;
;On exit:
; C	Error code (0 = OK)
;	(errloc) also updated


rwdisc:	SUB	A
	LD	(rcount),A	;Set retry count to zero

	PUSH	DE		;Save disk & read flag

;Convert sector number (HL) into track/sector (DE)

	IF	large

;Dr 0 which needs settle time
	CPL
	OUT	(sector),A

	LD	A,rdsec		;read 1 sector with no settle time
	JR	NZ,setlof
	AND	settle
setlof:	CALL	outcom

reed0:	IN	A,(status)
	RRCA
	RET	C
	RRCA
	JR	C,reed0
	IN	A,(data)
	JP	reed0







; PROCEDURE Rw_blk(read:Boolean; VAR buffer:C_ent; disc:Byte; blkno:Word);
;
; Write out 1k block to disc from main memory <buffer>.

rwblk:	XOR	A		;No error yet
	LD	(errloc),A

	POP	BC		;Return addr
	POP	HL		;blockno.
	POP	AF		;Disc no.
	POP	DE		;MemoET


;  PROCEDURE Chk_SJ; EXTERNAL;
;
; Read blk0 into 1st cache entry, set DS flag, check for SJ disc.
; Set <error> =1 means disc OK, but no SJ message


;	Set up parameters on stack for <rwblk>

chkSJ:	LD	A,1		;Read flag (=True)
	PUSH	AF
	LD	HL,cache1	;Read into 1st cache entry
	PUSH	HL
	XOR	A		;Drive no.
	PUSH	AF
	LD	HL,0		;Block no.
	PUSH	HL
	CALL	rwblk

	LD	A,(errloc)	;Had error ?
	OR	A
	RET	NZ		; Give up


iniok:	LD	HL,cache1+sjoff	;Where we put the block + Offset of SJ striDE,forerr
	CALL	pmess
	POP	AF
 	CALL	CAHEX
	LD	DE,atmsg
	CALL	pmess
	IN	A,(track)
	CPL
	CALL	CAHEX
	POP	DE		;Discard notracks
	POP	AF		;Discard track no.
	JR	exitf		;Give up


form5:	LD	BC,4000/29	;1ms Delay for Tunnel Erase
deloop:	DEC	BC		;Loop is 29 T-states (assuming wait states)
	LD	A,B
	OR	C
	JR	NZ,deloop

	POP	AF		;Loop counter/track no.
	POP	DE		;notracks in D
	INC	A
	CP	D
	JR	Z,exitf
	PUSH	DE
	PUSH	AF
	LD	A,trkinc
	CALL	outcom
	CALL	wairdy
	POP	AF
	JR	form3


;
; ng
	LD	DE,sjmess	;Check it's an SJ disk
	LD	B,23		;B:= len SJstring

csjlop:	LD	A,(DE)
	CP	(HL)
	JR	NZ,inierr
	INC	HL
	INC	DE
	DJNZ	csjlop

;	Set/reset dsflag according to flag in blk 0

	LD	A,(cache1+dsfoff)	;double sidedness
	AND	1			;leave relevant bit
	LD	(dsflag),A

	RET

;	Error exit. iabort is entry if errloc already set.

inierr:	LD	A,1		;Duff data in blk 0
	LD	(errloc),A
	RET


;
; PROCEDURE Format(drive,notracks:Byte);
;
; Format specified drive - drive nos 0..3 give sPROCEDURE Verify(drive,notracks);
;
;Verify all tracks
;

verify:	POP	HL		;Return addr
	POP	DE		; D:=notracks
	POP	AF		;drive
	PUSH	HL
	PUSH	DE

	CALL	stadrv
	CALL	seekz

	SUB	A		;start at Trk 0
ver1:	PUSH	AF	
	CALL	vtrk
	POP	AF		;Loop counter
	POP	DE		;notracks,drive
	PUSH	DE
	INC	A
	CP	D		;notracks
	JR	NZ,ver1

	POP	DE		;Discard

; done all the tracks

exitf:	CALL	drvoff
	EI
	CALL	dkinit		;Track stores are junk due to step commands
				;so Zap them.
	RET			;return to externides separately
;


format:	DI
	POP	HL
	POP	DE		;notracks to D, junk to E
	POP	AF		;drive
	LD	E,A
	PUSH	HL		;Return address
	PUSH	DE

;	Stack holds DE - D=notracks=maxtrack+1, E=driveno.

	ADD	A,'A'
	LD	(drvmsg),A	;Poke part of format drive message

	LD	DE,formsg	;Now print it
	CALL	pmess

	POP	DE		;notracks,drivE
	PUSH	DE
	LD	A,E

	CALL	stadrv		;start drive A
	CALL	seekz		;restore

form7:	SUB	A

form3:	PUSH	AF
	CALL	fortrk
	CPL
	RLCA
	AND	0FCH
	JR	Z,form5

	PUSH	AF
	LD	flg)
	OR	A
	JR	Z,addr
	POP	AF
	ENDM



;Trace message macro

tmess	MACRO	list
	LOCAL	nomess

	IF	t.on

	mcond	nomess

	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL

count	DEFL	0

	IRP	param,<list>	;Count:= number of params
count	DEFL	count + 1
	ENDM

i	DEFL	count		;i:= count

	REPT	count
	IFF	i AND 1		;ie I is even
j	DEFL	0

	IRP	param,<list>
j	DEFL	j+1
	IF	(j EQ i)
	PUSH	param
	ENDIF
	ENDM			;of IRP param....

	ENDIF
i	DEFL	i-1
	ENDM			;of REPT count

i	DEFL	0

	IRP	parIF	t.on

;dhxout
;Print hex of HL

dhxout:	LD	A,H
	CALL	cahex
	LD	A,L
				;DROP THROUGH
;cahex
;Print hex of A
;
;On entry:
; A	number to be printed

	JP	cahex		;Now lives in h2lib or some such place

	ENDIF

;
; Print a crlf!
pcrlf:	LD	DE,crlf
	JP	pmess


dtsmsg:	DEFM	' RDTS=$'
atmsg:	DEFM	' @ $'
errmsg:	DEFM	' fatal disc error $'
rtrmsg:	DEFM	' bad $'
formsg:	DEFM	cr,lf,'Formatting drive '	;Message continues below
drvmsg:	DEFM	'?$'				; - ? is poked at run time
forerr:	DEFM	am,<list>
	IFNB	<param>
i	DEFL	i+1
	IF	i AND 1		;ie I is odd (and param points to a string)
	mess	param
	ELSE
	IF	'&param' EQ 'AF'
	POP	AF
	CALL	cahex
	ELSE
	POP	HL
	CALL	dhxout
	ENDIF
	ENDIF
	ENDIF
	ENDM

	POP	HL
	POP	DE
	POP	BC

nomess:	POP	AF

	ENDIF

	ENDM



pstat	MACRO	sw,mes1,mes2
	IF1
	IF	sw
	IFNB	<mes1>
.PRINTX	mes1
	ENDIF
	ELSE
	IFNB	<mes2>
.PRINTX	mes2
	ENDIF
	ENDIF
	ENDIF
	ENDM


	
	pstat	large,<8 inch disk version>,<5 inch disk version>
	pstat	t.on,cr,lf,'Format error &$'
vererr:	DEFM	cr,lf,'Verify error &$'
secmsg:	DEFM	' sector &$'




; FUNCTION Five_in:Boolean; EXTERNAL; {return 5"/8" version}
;
fivein:	XOR	A		; A:=0 <=> false

	IFF	large		;IF small
	INC	A		;A:=1
	ENDIF

	RET



;PROCEDURE dkinit;
;
;This procedure should be called before performing any disc operations
;

dkinit:	LD	HL,trkno	;Current track table
	LD	B,maxdrv-1	;length of it
lowlp1:	LD	(HL),-1		;Zap to indicate drive not yet used
	INC	HL
	DJNZ	lowlp1
	R<Tracing ON>
	pstat	large,< (VERY) long macro expansion.......>,<long macro expansion.......>





;
; PROCEDURE ver_msg;		prints SJ FS ver etc. on screen
;


vermsg:	LD	DE,sjmess		;Print version on screen
	JP	pmess


sjmess:	DEFM	'SJ Research File Server ver '
	DEFW	verhi,verlo

	IF	large
	DEFM	'/8"'
	ELSE
	DEFM	'/5"'
	ENDIF

; NB this label must be defined before any references to the MESS
; macro is made.
; NB2 also forms part of the above string.

crlf:	DEFM	cr,lf,'$'


	S	1		;Double sided bit map


;	******* MAPMAN AREAS *********

lstadr:	DEFS	2		;Address of last block found

mapptr:	DEFS	maxdrv*4	;( length (2) + mapptr (2) ) * maxdrv

myheap:	DEFS	heapln


	END
 TITLE	Disk R/W & format routines for 380Z 512 bytes/sector
NAME	('Disc512')
.Z80
; modifications:
; 18/3/84 Floppy code now works on SS discs in DS drives (only an 8" bug)
; 19/3/84 Restore cmd has verify
; 22/3/84 Various waiting code for Tunnelling etc
; 4/4/84  Dkman edited to produce DISC5	IF	large
base	EQU	0E0H
sectrk	EQU	8	;For format
	ELSE
base	EQU	0C0H
sectrk	EQU	5
	ENDIF


status	EQU	base+0
comand	EQU	base+0
track	EQU	base+1
sector	EQU	base+2
data	EQU	base+3

latch	EQU	base+4

ctc0	EQU	base+12
ctc1	EQU	base+13
ctc2	EQU	base+14
ctc3	EQU	base+15

pagon	EQU	34H
pagoff	EQU	35H



;Misc equates

lf	EQU	10
cr	EQU	13

	IF	large
maxdrv	EQU	4		;Allowed up to 4 8" drives
	ELSE
maxdrv	EQU	3		;Only allowed 3 5" drives as Sel4=Motor on
	ENDIF

maxtry	EQU	2		;Thr12

true	EQU	-1
false	EQU	0

t.on	EQU	true	;Trace

large	EQU	TRUE	;8"disc version ?

.COMMENT	*

    Globals <error> and <two_sid> are used. <error> is set on exit to indicate
   any error, although an error message will have already been displayed.
    <two_sid> is True on entry if the disc is to be treated as double sided.
    Format has drive nos. in the range 0..3 for two sides separately.

	*


PUBLIC	Rwblk, dkinit, Format, Verify, chkSJ, Fivein, Vermsg

EXT	pmess, cahex, verhi, veee retrys allowed


;Block 0 offsets

sjoff	EQU	64		;Offset to 'SJ Research File Server'
dsfoff	EQU	97		;offset of double-sided flag: =0-> SS,=FF -> DS
blkoff	EQU	98		;offset of number of blocks on disk (16 bits)



; Various Macros


emt	MACRO	emtno
	DB	0F7H,emtno
	ENDM

;Macro to print string @ messadr

mess	MACRO	messadr

	IF	messadr EQ crlf
	CALL	pcrlf
	ELSE
	LD	DE,messadr
	CALL	pmess
	ENDIF

	ENDM



;Macro for message condition

mcond	MACRO	addr
	PUSH	AF
	LD	A,(mesrlo


; RM emt numbers

kywait	EQU	34	;wait for key, ctrl-F active


;Drive manifests

getzer	EQU	0F2H	;Seek trk 0 + Step 12mS + Head Load +    verify
seek	EQU	0E6H	;Seek trk n + Step 12ms + Head Load + No verify
rdsec	EQU	077H	;Read 1 sec + IBM + No head load
wrsec	EQU	057H	;Write 1 sec + IBM + No head load + Data mark
settle	EQU	0FBH	;Settle time bit for read or write cmd
trkinc	EQU	0A6H	;+1 Trk +     Step 6/12mS + Head Load + No Verify
writrk	EQU	00BH	;Write track



;Port numbers

	PUSH	HL		;Check valid block number
	DEC	HL
	LD	A,(HL)
	DEC	HL
	LD	L,(HL)
	LD	H,A
	CP	A
	SBC	HL,DE
	JP	C,ranerr

	POP	HL
	POP	AF

	ENDIF			;** End of range check **

	EX	DE,HL
	ADD	HL,BC
	POP	BC
	LD	B,C
	RET


	IF	c.on

;Bad map number / map not initialized

maperr:	error	'Bad map number'

;Block number out of range

ranerr:	error	'Duf block number'

	ENDIF




;PROCEDURE fblk (VAR block: block_descrip; VAR no_block: WORD);
;
;Attempt to find up to no_block blocks star so retry starting at block zero

	POP	HL
	LD	(HL),A
	INC	HL
	LD	(HL),A
	DEC	HL
	DEC	HL
	JP	fstart



;Found it

fblk2:	EX	DE,HL
	POP	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	POP	HL
	PUSH	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	CP	A
	LD	E,A
	JP	fblk12

;Find how many free & allocate them

fblk7:	INC	IX
	LD	E,(IX+0)
	LD	B,C
fblk9:	CP	A
	RR	E
	JR	NC,fblk11
fblk12:	DEC	HL
	LD	A,H
	OR	L
	JR	Z,fblk11
	DJNZ	fblk9
	RR	E
	LD	(IX+0),E
	JP	fblk7

;Wind up

fblk11:	RR	E		;Ating from block_descrip

fblk:	POP	HL		;Return address
	POP	BC		;no_block
	EX	(SP),HL		;block_descrip
	PUSH	IX
	PUSH	BC

fstart:	LD	A,(HL)		;Drive
	INC	HL
	PUSH	HL		;Save address of block number
	LD	E,(HL)		;get block number
	INC	HL
	LD	D,(HL)

	EX	DE,HL
	PUSH	HL
	CALL	getblk
	LD	C,8
	CP	A		;Clear carry for RRA
	DEC	B
	LD	A,(HL)
	JR	Z,fblk1
fblk0:	RRA
	DEC	C
	DJNZ	fblk0
fblk1:	LD	B,C
	PUSH	AF
	PUSH	BC
	PUSH	HL
	EX	DE,HL
	INC	HL
	LD	D,(HL)
	DEC	HL
	LD	E,(HL)
	DEC	HL
	LD	B,llocate out of last byte
	DJNZ	fblk11
	LD	(IX+0),E
	EX	DE,HL

	POP	HL		;Fill in blocks found
	LD	(HL),E
	INC	HL
	LD	(HL),D

	POP	IX
	RET
;
; ****** END OF MAPMAN ******
;




	COMMON	/debug/

mesflg:	DEFS	1


	COMMON	/error/

errloc:	DEFS	1

	COMMON	/freebl/

dsksiz:	DEFS	maxdrv * 2


	DSEG

cacmap:	DEFS	noblks*4	;Cache sector map

page:	DEFS	1		;Current cache page

rwpage:	DEFS	1		;Parameter to RWDISC

csize:	DEFS	1		;Number of usable blocks in cache.

dsflag:	DEF(HL)
	DEC	HL
	LD	C,(HL)
	EX	DE,HL
	ADD	HL,BC
	POP	BC
	PUSH	BC
	POP	IX
	CP	A
	SBC	HL,BC
	EX	DE,HL
	POP	BC
	POP	AF
	POP	HL
	LD	C,8
	JP	fblk3

;Main find loop
;
;On entry:
; BC	8
; DE	number of bytes to search before giving up
; HL	start block number
; IX	pointer to current byte to search

fblk4:	LD	A,(IX+0)
	OR	A
	JR	NZ,fblk6
	ADD	HL,BC
	JP	fblk5
fblk6:	LD	B,C
fblk3:	RRA
	JR	C,fblk2
	INC	HL
	DJNZ	fblk3
fblk5:	INC	IX
	DEC	DE
	LD	A,E
	OR	D
	JP	NZ,fblk4

;NOT found at allPUSH	HL
	mess	dtsmsg
	POP	HL	
	CALL	dhxout
	LD	HL,(trkno)
	CALL	dhxout
	mess	atmsg
	LD	A,(rwpage)
	CALL	cahex
l4:	POP	AF
	ENDIF


;On entry to here:
; A	read flag

	PUSH	AF

	LD	A,(rwpage)
	OUT	(pagon),A		;Turn on paged RAM

	AND	3			;Low bits = offset in block
	ADD	A,HIGH secbuf		;Address of paging window
	LD	(rwaddr+1),A		;Address to read/write
					;(low byte =0 always)
	POP	AF

	PUSH	IX			;Must preserve IX (for Propas)
	LD	IX,emtblk
	OR	A
	DI				;Disc routines speed sensitilloc:	POP	HL		;Return address
	EX	(SP),HL		;Blk address

	LD	A,(HL)		;Get drive
	INC	HL
	LD	B,(HL)		; & block number
	INC	HL
	LD	H,(HL)
	LD	L,B

;	tmess	<alblk0,HL,alblk1,AF,crlf>

	CALL	getblk
	CPL
	AND	(HL)
	LD	(HL),A
	SUB	A
	RET



;GETBLK
;Converts Map number & Block Number into address and bit number
;
;On entry:
; A	Map number
; HL	Block number
;
;On exit:
; A	Byte with bit set
; B	1 - 8 => Bit number
; DE	Points to low byte of address in MAPPTR (length @(DE-2))
; HL	Adve
	JR	Z,write
	EMT	rdsec
	JR	finish

write:	EMT	wrsec

;
; On entry, A=error code (=0 for OK)

finish:
	EI
	POP	IX
	OUT	(pagoff),A	;Turn off paged RAM (value immaterial)
	JR	Z,timrt0	;No error
	LD	HL,errloc
	LD	(HL),199

	IF	t.on
	PUSH	AF
	mess	errmsg		;'Fatal error' message
	POP	AF
	PUSH	AF
	CALL	cahex
	CALL	pcrlf
	POP	AF
	ENDIF
timrt0:
	LD	C,A

	RET			;C=error number


emtblk:				;Paramater block for disc EMTs
discno:	DB	0
trkno:	DB	0
secno:	DB	0
rwaddr:	DW	0		;Low bydress of byte

getblk:	PUSH	HL

	CP	maxdrv
	JP	NC,maperr

	ADD	A,A
	ADD	A,A
	LD	C,A
	LD	B,0
	LD	HL,mapptr+3
	ADD	HL,BC
	EX	(SP),HL

	LD	A,L		;HL/8, A=Remainder
	AND	7
	SRL	H
	RR	L
	SRL	H
	RR	L
	SRL	H
	RR	L

	LD	B,A		;Set bit A in A
	INC	B
	LD	C,B
	SUB	A
	SCF
getbl1:	RLA
	DJNZ	getbl1

	POP	DE
	PUSH	BC
	EX	DE,HL
	LD	B,(HL)		;BC:= address of map
	DEC	HL
	LD	C,(HL)

	IF	c.on		;** Range check block **

	PUSH	AF		;Check map exists
	LD	A,B
	AND	C
	INC	A
	JP	Z,maperr

te not initialised - hence in CSEG



	ENDIF	;of IF nascom ELSE on whole RWDISC code






;
;  ****** BIT MAP MANAGEMENT CODE STARTS HERE *************
;
;


;PROCEDURE dalloc (blk: block_descrip);

dalloc:	POP	HL		;Return address
	EX	(SP),HL		;Blk address

	LD	A,(HL)		;Get drive
	INC	HL
	LD	B,(HL)		; & block number
	INC	HL
	LD	H,(HL)
	LD	L,B

	tmess	<frblk0,HL,alblk1,AF,crlf>

	CALL	getblk
	OR	(HL)
	LD	(HL),A
	SUB	A
	RET



;PROCEDURE alloc (blk: block_descrip);

a56: C=port no.
	IN	A,(C)
	OR	A		;Error code
	JR	Z,noerr1
	LD	C,A		;Return error
	LD	HL,errloc
	LD	(HL),199
	RET
	
noerr1:	LD	A,(rwpage)
	LD	H,A		;Destination address in paged RAM
	LD	L,B		;L:=0 (B already contains 0)
	CALL	waitin
	DI			;Stack not working when page open
	LD	A,pawrit
	OUT	(paport),A
	INIR
	INIR
	LD	A,panorm	;Close page again
	OUT	(paport),A
	EI
	LD	C,B		;C=0 ie no error
	RET

dowrit:	LD	BC,windat	;B=byte count=256, C=portno for OTIR
	LD	A,(rwpage)	;Dest. address in paL
	AND	7		;Remainder MOD 8
	LD	(secno),A
	ADD	HL,HL		;*2
	ADD	HL,HL		;*4
	ADD	HL,HL		;*8
	ADD	HL,HL		;*16
	ADD	HL,HL		;*32
	LD	D,H		; div 8 <=> *32 DIV 256

	

	ELSE

;Divide by five - Leaves result in A & remainder in L

	XOR	A

	LD	DE,-500H
tscon1:	ADD	HL,DE
	JR	C,tscon0
	SBC	HL,DE
tscon0:	RLA
	SRA	D
	RR	E
	JP	NC,tscon1

	LD	D,A		;Swap regs - so correct for output
	LD	A,L
	LD	(secno),A

	ENDIF

; Now have D=trk, (secno)=sector, E undef.

	POP	HL		;drive now in L (0..3), ged RAM
	LD	H,A
	LD	L,B		; L:=0 (B has 0 already)
	CALL	waitot

	LD	A,paread	;Value to be sent to (paport)
	CALL	CtoWIN		;Code in Safe RAM (DI,OTIR,OTIR,EI,RET)

	CALL	waitin
	IN	C,(C)		;return code
	RET	Z		;Done if OK
	LD	HL,errloc
	LD	(HL),199
	RET



wput:	CALL	waitot		;This rtn sends a byte to win, with h/shake
	OUT	(windat),A
	RET

waitot:	PUSH	AF		;Wait till win is ready for us to output
wo1:	IN	A,(winst)
	AND	3
	JR	NZ,wo1
	POP	AF
	RET

waitin:	PUSH	AF		;Wait for win to talH=read flag


;Convert drive number into drive bits

	SUB	A
	LD	B,L
	INC	B		;As drive numbers start at 0
	SCF
cdrnol:	RLA
	DJNZ	cdrnol
	LD	B,A		;has a single bit set in it.


	LD	A,(dsflag)	;Double sided ?
	AND	B
	LD	A,L		;Drive no.
	JR	Z,stadr2
	SRL	D		;Modify track number (/2)
	JR	NC,stadr2
	ADD	A,2		;Other side
stadr2:	LD	(discno),A	;Save drive no. in param block
	LD	L,A		;And in L for trace msg
	LD	A,D
	LD	(trkno),A

	LD	A,H		;Read flag

	IF	t.on
trace:	mcond	l4
	PUSH	AF
	k to us
wi1:	IN	A,(winst)
	AND	3
	CP	1
	JR	NZ,wi1
	POP	AF
	RET


	ELSE		;NOT nascom

;RWDISC
;Read/Write sector to/from disk
;
;On entry:
;    (rwpage)	PAGE number to write to/get from (ie. 2 low bits are RAM addr)
;	 D	Read flag (FF-read,0-write)
;	 E	Disk number
;	 HL	sector no.
;
;On exit:
; C	Error code (0 = OK)
;	(errloc) also updated


rwdisc:
	PUSH	DE		;Save disk & read flag

;Convert sector number HL into track D & sector (secno)

	IF	large

;Divide by eight

	LD	A,	DEFM	' @ $'
errmsg:	DEFM	' fatal disc error $'
almsg0:	DEFM	'Init map $'
almsg1:	DEFM	' - length $'
naloc0:	DEFM	cr,lf,'Clear $'
naloc1:	DEFM	' bytes from $'
alblk0:	DEFM	'Allocate block $'
alblk1:	DEFM	' from map $'
frblk0:	DEFM	'Free block $'

cfrmes:	DEFM	'k Cache size',cr,lf,'$'

	ENDIF






;PROCEDURE inilow
;
;Initialize everything that needs initing:
; <zeros> is initialised to all zero.

inilow:	LD	BC,1023		;Len-1
	LD	DE,zeros+1
	LD	HL,zeros
	LD	(HL),0
	LDIR

	LD	DE,mUSH	AF		;To allow for the compulsory POP following
blkm:	POP	AF		;Jumped to from mcond.
	ENDIF

	RET




;RWDISC
;Read/Write sector to/from disk
;
;On entry:
;    (rwpage)	Page number to write to/get from
;	 D	Read flag (FF-read,0-write)
;	 E	Disk number
;	 HL	sector no.
;
;On exit:
; C	Error code (0 = OK)
;	(errloc) also updated


	IF nascom

rwdisc:	
	IF	t.on
	LD	A,(rwpage)
	tmess	<dtsmsg,HL,atmsg,AF>
	ENDIF

	LD	C,D		;Save r/w flag
	LD	A,E		;Test for drive 1
	OR	A
	JR	Z,ode7	;Force mode 7 as i/o proc RAM used as cache
	JP	pmess		;&return





;PROCEDURE inidsk (max_drive: BYTE);
;
;This procedure allocates heap for the map for all drives

inidsk:	POP	HL		;Return address
	EX	(SP),HL		;Max_Drive
	PUSH	HL		;Save drive again


	LD	HL,mapptr	;Init bit map pointers & track stores
	LD	DE,mapptr+1
	LD	BC,maxdrv*5-1
	LD	(HL),-1
	LDIR

	LD	HL,cacmap	;clear cache map
	LD	DE,cacmap+1
	LD	BC,noblks*4-1
	LD	(HL),-1		;all blocks free
	LDIR


;Work out how mucdrive0
	LD	DE,07878H	;Drive 1
	JR	drive1
drive0:	LD	DE,05050H	;Offset to clear CP/M area (drive 0)
drive1:	ADD	HL,DE
;
;	HL=sector no.
;
	LD	A,C		;=FF for read,0 for write
	CPL
	AND	1		;The difference between read & write op-codes
	OR	032H		;Read op-code
	CALL	wput		;put byte to win
	XOR	A		;a:=0
	CALL	wput
	LD	A,L		;Sector no.
	CALL	wput
	LD	A,H
	CALL	wput
	INC	C		;Store of r/w flag : now =0 for Read
	JR	NZ,dowrit

	CALL	waitin		;Wait for input indicator
	LD	BC,windat	;B=byte count=2h cache is actually available & set up chain
;
; On BBC, always 1st <ramsiz>K
;
; block 0 assumed to be OK.
; Note: when testing this page the code is safe due to LD HL,$ fudge

	LD	BC,0100H
	LD	H,4		;Pageno. under test
	LD	IY,cacmap	;IY points to the block which will point here
				;if this one is any good.

cilop0:
	LD	A,H
	CP	ramsiz*4	;Only <ramsiz>k available
	JR	NC,cilop1


cilop2:	INC	B		;We have a good block
	LD	(IY),H		;Link it to the last good one
	LD	IY,cacmap
	PUSH	BC		;Save or	MACRO	string
	LOCAL	stradr

	LD	DE,stradr
	CALL	pmess

	JP	fsexit

stradr:	DEFM	cr,lf,string,cr,lf,'$'
	ENDM




;Macro for message condition

mcond	MACRO	addr
	PUSH	AF
	LD	A,(mesflg)
	OR	A
	JR	Z,addr
	POP	AF
	ENDM



;Trace message macro

tmess	MACRO	list
	LOCAL	nomess

	IF	t.on

	mcond	nomess

	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL

count	DEFL	0

	IRP	param,<list>	;Count:= number of params
count	DEFL	count + 1
	ENDM

i	DEFL	count		;i:= count

	REPT	count
	Id FS version'
;				FS call.
; FUNCTION Ver_len:Word;	Returns length of block.
;


vermsg:	LD	DE,sjmess		;Print version on screen
	JP	pmess

veradr:	LD	HL,verblk		;Address of version text to
	RET				;Transmit for *VERS

verlen:	LD	HL,crlf-verblk+1	;Length of transmitted text
	RET

verblk:	DEFW	0			;Std. Tx Header

sjmess:	DEFM	'SJ Research File Server ver '
	DEFW	verhi,verlo

	IF	large
	DEFM	'/8" BBC'
	ELSE
	DEFM	'/5" BBC'
	ENDIF

; NB this label must be defined before any referenceFF	i AND 1		;ie I is even
j	DEFL	0

	IRP	param,<list>
j	DEFL	j+1
	IF	(j EQ i)
	PUSH	param
	ENDIF
	ENDM			;of IRP param....

	ENDIF
i	DEFL	i-1
	ENDM			;of REPT count

i	DEFL	0

	IRP	param,<list>
	IFNB	<param>
i	DEFL	i+1
	IF	i AND 1		;ie I is odd (and param points to a string)
	mess	param
	ELSE
	IF	'&param' EQ 'AF'
	POP	AF
	CALL	cahex
	ELSE
	POP	HL
	CALL	dhxout
	ENDIF
	ENDIF
	ENDIF
	ENDM

	POP	HL
	POP	DE
	POP	BC

nomess:	POP	AF

	ENDIF

	ENDM



pstat	MACRO	sw,mes1s to the MESS
; macro is made.
; NB2 also forms part of the above string.

crlf:	DEFM	cr,lf,'$'


	IF	t.on

;dhxout
;Print hex of HL

dhxout:	LD	A,H
	CALL	cahex
	LD	A,L
				;DROP THROUGH
;cahex
;Print hex of A
;
;On entry:
; A	number to be printed

	JP	cahex		;Now lives in h2lib or some such place
;
; Print a crlf!
pcrlf:	LD	DE,crlf
	JP	pmess


mode7:	DB	22,7,'$'
wrmess:	DEFM	'Write block $'
rdmess:	DEFM	'Read block $'
adrmsg:	DEFM	' address $'
dtsmsg:	DEFM	' RDTS=$'
atmsg:,mes2
	IF1
	IF	sw
	IFNB	<mes1>
.PRINTX	mes1
	ENDIF
	ELSE
	IFNB	<mes2>
.PRINTX	mes2
	ENDIF
	ENDIF
	ENDIF
	ENDM


	
	pstat	large,<8 inch disk version>,<5 inch disk version>
	pstat	t.on,<Tracing ON>
	pstat	c.on,<Bounds checking ON>





; Various version string related routines :
;
; PROCEDURE ver_msg;		prints SJ FS ver etc. on screen
; FUNCTION ver_adr:Word;	Returns address of a block containing the
;				version string with a std. Tx header on the
;				front, suitable for the 'reaIY+3)	;Drive
	RLCA
	RLCA
	AND	03H		;Now back in right place
	LD	E,A

	PUSH	HL
	PUSH	DE
	CALL	rwdisc		;Get first
	POP	DE
	POP	HL
	INC	C		;Error => return now
	DEC	C
	JR	Z,nxtsec

blkdud:	DEC	D		;Test for read operation
	RET	Z		;Write, so no need to zap blockno.
	LD	(IY+2),0FFH
	LD	(IY+3),0FFH	;Mark as empty since contains junk
	RET

nxtsec:	LD	A,(rwpage)
	ADD	A,2
	LD	(rwpage),A
	INC	HL		;Next sector
	CALL	rwdisc
	INC	C
	DEC	C
	JR	NZ,blkdud

	IF	t.on
	mcond	blkm
	CALL	pcrlf
	P in 2 hi bits

Empty blocks have the block no. set to &FFFF, so we can have one disc of 64K-1
blocks, 3 discs of 16K blocks, or 4 discs of 16K-1 blocks.

Blocks are marked as empty if an error occured while trying to read into them.

	*

PUBLIC	discrd,discwr, inidsk, dalloc, alloc, fblk, inilow
PUBLIC	cidle, cempty, Veradr, Verlen, Vermsg, pcrlf

EXT	$hplm, $memry, fsexit, pmess, cahex, verhi, verlo


;Cache equates

noblks	EQU	64		;maximum number of k in cache (?)


;Heap

heapln	EQU	.Z80
TITLE	Disk & Map managing routines for VARIOUS DISCS
NAME	('DkMan')

; modifications:
; 26/7/84 BBC version

true	EQU	-1
false	EQU	0

t.on	EQU	true	;Trace
c.on	EQU	true	;Parameter checking

large	EQU	FALSE	;8"disc version ?

ramsiz	EQU	20	;Size of available RAM in K
ramlow	EQU	02800H	;Start of i/o processor free RAM

osword	EQU	0FFF1H

	.COMMENT	*

HOW THE CACHE WORKS

The cache stores 1K blocks, up to 64 in all. Each block is held in 4 physical
pages, and all page numbers are 160		;Max 1280K total


;Misc equates

lf	EQU	10
cr	EQU	13

maxdrv	EQU	2


;Block 0 offsets

sjoff	EQU	64		;Offset to 'SJ Research File Server'
dsfoff	EQU	97		;offset of double-sided flag: 0-s,FF-d
blkoff	EQU	98		;offset of number of blocks on disk (16 bits)



; Various Macros



;Macro to print string @ messadr

mess	MACRO	messadr

	IF	messadr EQ crlf
	CALL	pcrlf
	ELSE
	LD	DE,messadr
	CALL	pmess
	ENDIF

	ENDM




;Macro to print error string & crash back to OS

errin this form - ie. 0,4,8,12 are successive
pages. (page) holds the current page number and also acts as a head of
chain pointer. The map has 4 bytes per entry (hence physical page can be used
as an index) and the entries form a linked list. There is no tail pointer,
but (csize) contains the total number of active entries and hence a loop
can easily scan down to the tail of the list.

entry format :

	offset	0	Page no. of next entry
		1	Needs writing if =0, else =&FF
		2,3	Block no. with drive no.
	LD	A,(HL)			;Drive
	RRCA
	RRCA				;Put in top 2 bits
	INC	HL
	LD	E,(HL)			;Lo(block)
	INC	HL
	OR	(HL)			;Hi byte add to drive bits
	LD	D,A
	EX	DE,HL

;	fudge to get started - note that link pointer is at start of map entry

	LD	IY,page			;Start of chain - IY usually points to
					; the previous entry
	LD	D,0

;	HL=block/drive no, D=0
;	In loop, DE=page no, C=previous page no.

	LD	A,(csize)		;Number of entries to search
	LD	B,A			;For DJNZ

filoop:	LD	C,E			;Save previous pageno
	Lge, E is new page
;	On exit, carry set, A=(page), B=0, HL=^previous ent

setpag:	LD	HL,cacmap
	LD	B,0			;BC now = previous page no.
	ADD	HL,BC

	LD	A,(IY+0)
	LD	(HL),A			; previous^.next:=new_ent^.next
	LD	A,(page)
	LD	(IY+0),A		; new_ent^.next:=head_ptr
	LD	A,E
	LD	(page),A		; head_ptr:=new_ent

	SCF
	RET





;RWBLK
;Read/Write block to/from disk
;
;
;On entry:
; D	Read flag (&FF -> read, 0 -> write)
; IY	Points to map entry
;(page)	**NOT USED** (hence we can write blocks not aD	E,(IY+0)		;Advance to next
	LD	IY,cacmap		;Calculate address of cacmap entry
	ADD	IY,DE

	LD	A,(IY+2)
	CP	L
	JR	NZ,filop1		;No good
	LD	A,(IY+3)		;Test hi byte
	CP	H
	JR	Z,found			;Both agree

filop1:					;Get here if this block no good
	DJNZ	filoop			;Fall through if we have tried all ents

; Now have tail of chain

	PUSH	HL			;Save blockno.
	CALL	setpag			;Make this into head of chain
	LD	A,(IY+1)		;Needs writing flag
	OR	A			; sets Zf, also clears Cf
	JR	NZ,setblk		;Not required, sot head of chain)
;
;On exit:
; C	Error code (0 = OK)
;	(errloc) also updated
; (IY)	Needs writing flag cleared always. Blockno zapped if read error

rwblk:	LD	(IY+1),0FFH	;Clear needs writing flag

	PUSH	IY
	POP	HL		;Calculate page no. from table offset
	LD	BC,cacmap	;Start of table
	OR	A		;Clear carry
	SBC	HL,BC
	LD	A,L		;the answer

	LD	(rwpage),A

	LD	L,(IY+2)	;blockno.
	LD	A,(IY+3)	; Hi byte also holds drive
	AND	3FH		;not any more
	LD	H,A
	ADD	HL,HL		;Block * 2 = Sector

	LD	A,( just insert blkno.
	LD	D,0			;r/w flag set to write
	CALL	rwblk
setblk:	POP	HL			;Get back blockno.
	LD	(IY+2),L
	LD	(IY+3),H		;Store in map
	OR	A			;Clear carry <=> not found
	RET


;	Found already in cache, so set carry for return & drop through
;	to move to head of chain if not already there.

found:	LD	A,(page)
	CP	E			;Test for already head of chain
	SCF
	RET	Z			;Return to save looping up chain

;	Move the new entry to the top of the chain
;	IY points to new entry, C is previous paCIDLEЋ¦dDДДф8о DISCRDЋљдD•45u(иЁ<FBLKЊяde4U„•HпёINIDSKЋц d”д”ДхxйрPCRLFЊэѓUФU58и0VERADRЊ– UdU$„иPVERLENЊ— UdU$Дши VERMSGњ   ћ дe$TT$Йx ј\ . — ЂЛЂЂeА`2а@p(ё\.	— Л‚АeБ 2ааpxёD\2.№ЊФЂТD…ДША $MEMRYЋВTДДф8Л 5CAHEXЋЫd4TХEмЂZ,addr
	POP	AF
	ENDM



;Trace message macro

tmess	MACRO	list
	LOCAL	nomess

	IF	t.on

	mcond	nomess

	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL

count	DEFL	0

	IRP	param,<list>	;Count:= number of params
count	DEFL	count + 1
	ENDM

i	DESH	DE
	PUSH	HL		;save working registers

	IF	rm

	LD	A,(page)	;Open page
	OUT	(pagon),A

	LD	BC,03FFH	;Length-1
	LD	HL,secbuf
	LD	DE,secbuf+1
	LD	(HL),0		;Value which will be copied all the way down
	LDIR	

	;NB. page left open - will be closed after writing data in

	ELSE		;NASCOM

	LD	A,(page)
	LD	H,A
	XOR	A
	LD	L,A		;HL=address of start of page
	LD	B,4		;page count

	DI
	LD	A,pawrit
	OUT	(paport),A

clrbl0:	LD	(HL),0
	INC	L
	JR	NZ,clrbl0
	INC	H
	DJNZ	clrbl0

	LD	A,panormFL	count		;i:= count

	REPT	count
	IFF	i AND 1		;ie I is even
j	DEFL	0

	IRP	param,<list>
j	DEFL	j+1
	IF	(j EQ i)
	PUSH	param
	ENDIF
	ENDM			;of IRP param....

	ENDIF
i	DEFL	i-1
	ENDM			;of REPT count

i	DEFL	0

	IRP	param,<list>
	IFNB	<param>
i	DEFL	i+1
	IF	i AND 1		;ie I is odd (and param points to a string)
	mess	param
	ELSE
	IF	'&param' EQ 'AF'
	POP	AF
	CALL	cahex
	ELSE
	POP	HL
	CALL	dhxout
	ENDIF
	ENDIF
	ENDIF
	ENDM

	POP	HL
	POP	DE
	POP	BC

nomess:	POP	AF

	EN
	OUT	(paport),A
	EI

	ENDIF

	POP	HL
	POP	DE
	POP	BC
	JR	rdywr


;fiblk
;
;Find block in cache.
; If block not found, return the tail of the chain, making it the head
; then writing out if necessary & inserting the new info in the map.
;
;On entry:
; HL	address of block descriptor (drive then block)
;
;On exit:
;(page)	updated
; IY	points to entry in cacmap
; cf	set	Found
;	clear	Not found
;
; HL,DE,BC registers all used
;

fiblk:

;Put drive in top 2 bits of block number
DIF

	ENDM



pstat	MACRO	sw,mes1,mes2
	IF1
	IF	sw
	IFNB	<mes1>
.PRINTX	mes1
	ENDIF
	ELSE
	IFNB	<mes2>
.PRINTX	mes2
	ENDIF
	ENDIF
	ENDIF
	ENDM


	
	pstat	rm,<Research machines version>
	IF	rm
	pstat	large,<8 inch disk version>,<5 inch disk version>
	ENDIF
	pstat	nascom,<Nascom version>
	pstat	t200,<Fixed 200K disk size (test)>,<Variable disk size (normal)>
	pstat	t.on,<Tracing ON>
	pstat	c.on,<Bounds checking ON>





; Various version string related routines :
;
; PROCE…QУPS dD•45$H%M]JINIDSKЃ‘SРаTДДф8	1.INILOWЃPТQ`d4TХEYIJVERLENЃ•‘T“TСаU5$Дh DEBUGЉ ЂTU%$х(  FREEBL”\ЂНjБВ4@†  hp$B& 2@ ™(@R2њМ¦‘ЊР #M†QLКr;NB±”д     xаD	ЊР  ъГ§ f Г Ђs‘¤иeЌ†у¬@$)L&A€Шo1љДA„Иd9Ng1 ђ@R"
cС ЂЂ ЖЎ„Ш 2Nf1”дr7њ„A€Вd		&гIР@m0њA ґ@l2›ЊзC@ЂHН†S	И@$Џ'C)М@f9Нў!Шl7М'C(ЂДl7Нb ЂМr7›DУ	А@$#Њ¦Q€Шo1љДCXЂ†a1љў™¤фe‚„‚џв0ѓн’бq№D8D#„Ђ@ ђ ЩюнXp  G Ђ _аіэЪ°С@іАє DАGи‡  <ПЏз Ан0†—В Hј$ѕб А<э: ў  Е 	ЏРKH$	vХ^2Аа/џE fXи`{пdC”eѓЂ[nYэк:БА-7#Ox€pX 	?°(
ЭщJЃ…н7…к:а q@‰вхj№Z®PЌg fЦа76› 8YґШ #[Ђ·¬u‚ YµРВСx»Jx EЂЂ]¤ј

]=GПс@|ы`РР^УqЏњМЪ"Н§@Н·@ }<GА@0  ю€'±{MДу`Ђш8h|аРё B>;©™ґDB x“ЋТЛmАг‡ГmЖ/;‹U\8ГЄ Јвє™›DA„ ЂYшн,џ…дvЫЂ8ЗѓГMЖ,aWЂPг»Ѕ@'р ,р±>Ю vФ^ў'Љ
Ng8Ђњ:АЂ/аАЋ<`@(FВЂ3oИ#тНїаЌ·Ѕ›nA[n!{6Я‚Ћ°6в‚Ћ° 6е‚Ћё ЬP>ЖX4о"v–р « ІМ,Єz
НҐ@М:
y[ЉВ5II=KЂ мPЌr fЫ@VтНє ¬Ъ| БfФgЫ%к`аZј`e»ЖX8¦дxґЬа ф@эd№GП&mfУ aVKќЬ,–ЫЃ–G>™#¬ц °pMИЙpёПВ20ЊМhzЋ ФDT%T~  ·^/V+UіАЛЂ«З‚pѓс›O 7t›PЂ-‘lЅFW8T  9D  #”L r€np•›p ‡Pj*’’z—  [€‚Єв  !   …ГKб ёF>,P щ ?IвчиЄДЂ€pP
Ћэ?T+»фЬb~™Њo«6иЂјGЇ*ШЙ F\ ВЙ   QФ€Љ„ЄЏА вЂуЕкЕj№\ЇPЌ‹ fЦ@‹6Ї „lЁ6сЂёYґШВС`ј\®ґ9< БИКHЁЁIњ  sњ™c¦Xm–:e†Щc¦Xl&!ВЂ ђKeКЩ`њgYИVsj¶]n0Лjј9B:дЪRpґ«АEІЕj°Z&#XL6ЅGPj"*Є?  [Љ/«Єеr±B6Ђ›{@\,Ъl µ ЪўбfУ`m> pґX/jБў{sЕ b:\n?мђЌЃfХ°&  ¦ЂЂЮf6ОаРPђuЃАKг¬O Яў   ?C/Урn ±YґЬ‚d?KА hЃКЙ¬Ы Б>Y*с”Љ¤¤ћҐА .6mШBПцm7pґX.7[Фuў"Ў*Јр ё bсz±Z®VЁFЁЂ3kафЬ~™ЂlЪl «Кхr„n€6Ђ8YґШ #qЂµвН АМЪ| бh°^,Ы(¶;ҐЩ.шFF™ЌЫ(/SТм—+шТ»`Иt9< б@KЊъжІЗЊ°л,xЛІЗЊ°йHKЌВблEЉл#
ЙПSВ„xК»`ОQYшVn3ЇЭҐ&Хчpј]`–	’јЂМЪаГЇа@РQВdL'ёкm1N@РPђ#@Щ·|‡xЃЃ ў!ФМ 1ж3XЂЬu6Њ§ h(Hб`ёЫ®V)шFе/КО·+6КЃр)шPѓBВХЉеu€КВІр¬Њ+':Б,+uВїvђќl‹„aХ°vйш ·,:ВAЋ‚0ѓйє#ћЦL* б;€Ов±[ЌѓєЬ'1ЙВе/КОµщ}‡cAЫў6йx A_ІГc x¬шµ‚FXmєs 0м;,6~7N`[„ж#97\,™x јERROR—Ђ KА@ дe$TT$Йx ј\ . — ЂЛЂЂeА`2а@p(ё\.	— Л‚АeБ 2ааpxёD\2.№ЊФЂТD…ДША $MEMRYЋВTДДф8Л 5CAHEXЋЫd4TХEмЂ ЫМбfУ` Ќn fЯP!ЦfЮpm> pґX/X0$`p( <>љcGЁ™а~	Е‚ +ДxУ=AўђAасiЌY.6м€`ФU%$х.  6 8X V‹ЖхAЁ€ЁJЁь n(ј^¬V«•КЁЂЫюэ7 џ¦`6› jи6ЄЃёYґШ #[ЂµђuЃАYґ›OЂ-Д@;Ш­W(Yюxk,Jnбh°_Ј` uЃАBЃQ@x}ћ °`¦4zџ‚B0аЂ
с4ЖЏPhЃдx<ZcVIб¬XЉW(лЂЃЂ‚Б¦4 ‚Шр цp°Cѓр<#/ЦЕw[фCЃАBАЦ	#’ЯҐафCЂ Ў—йшЅџ§арP:¬ЪBэ? Vв (X Н¦аЋйФэ: Цм‘Ц]ЌЩ   _§аЬuЃА_§pмeЃАFм—иШя~№\   ·vђЏЈ,э7 џ§а~gїOА08М/№Z¬ЫСpѓўЂXUђэ џпС°юЙ`Ђ0e‚ DlЫ€ЇQЧ  [Љ Їm> zјY)q–jџ\Аrш¤R)ЉJЋ№7„¦сЦ
R; IRQs	on

writck:	PUSH	BC

	LD	B,A
	CALL	w3000		;Returns with Irq disabled
	OUT	(C),D
	LD	A,B

	RRCA
	RRCA
	RRCA
	RRCA			;top nibble in A
	OUT	(C),A
	OUT	(C),B		;lo nibble
	EI

	LD	B,40		;Delay so that next write succeeds
	DJNZ	$

	POP	BC
	RET



	COMMON	/now/

now1:	DS	5

	DSEG

rdate:	DS	1		;date origin 1
rmonth:	DS	1		;month (LO,origin 1) and year (HI, origin 1981)
rhour:	DS	1
rmin:	DS	1
rsec:	DS	1

	COMMON	/error/

errloc:	DS	1



	END

CALL	write		;(HL) in decimal
	DEC	D
	JP	P,setcl4	;stops when D=-1 ie just written secs reg

;now start clock - NB D=0FFH ie select status register

	LD	A,1
	JP	writck		;and finish


writea:	LD	(HL),A
write:	PUSH	BC

;convert to BCD

	XOR	A
	RLD			;top nibble to A lo

	LD	B,4
write1:	ADD	A,A
	DAA
	DJNZ	write1

	LD	B,A
 	XOR	A
	RLD			;A=lo nibble of 
	ADD	A,B
	DAA			;A now in BCD
	POP	BC


;WRITCK
;write an RTC register
;
;On entry:
; D	register to write
; A	value to writeitially
	LD	(BC),A

	LD	H,D		;Save start of new date
	LD	L,E

;now range check

	LD	A,(DE)		;Date 1..31 (not bothering about months yet)
	INC	DE
	OR	A
	RET	Z
	CP	32
	RET	NC

	LD	A,(DE)		;months (lo-nibble) 1..12
	AND	15
	INC	DE		;years don't need checking
	OR	A
	RET	Z
	CP	13
	RET	NC

	LD	A,(DE)		;hours 0..23
	INC	DE
	CP	24
	RET	NC

	LD	A,(DE)		;mins 0..59
	INC	DE
	CP	60
	RET	NC

	LD	A,(DE)		;secs 0..59
	CP	60
	RET	NC

; new time is OK - set no error

	XOR	A
	LD	(BC),A
;
;On exit:
; A	naff
; rest	OK
; IRQs	on

writck:	PUSH	BC

	LD	B,A
	CALL	w3000		;Returns with Irq disabled
	OUT	(C),D
	LD	A,B

	RRCA
	RRCA
	RRCA
	RRCA			;top nibble in A
	OUT	(C),A
	OUT	(C),B		;lo nibble
	EI

	LD	B,40		;Delay so that next write succeeds
	DJNZ	$

	POP	BC
	RET



	COMMON	/now/

now1:	DS	5

	DSEG

rdate:	DS	1		;date origin 1
rmonth:	DS	1		;month (LO,origin 1) and year (HI, origin 1981)
rhour:	DS	1
rmin:	DS	1
rsec:	DS	1

	COMMON	/error/

errloc:	DS	1



;now set time: stop clock

	LD	D,status
	LD	A,0
	CALL	writck		;writes A unmodified

;	HL points to start of new date

	LD	D,date
	CALL	write		;writes (HL) in decimal
	INC	HL
	INC	D		;month reg
	LD	B,(HL)
	LD	A,(HL)
	AND	15
	CALL	writea		;write the months out
	INC	D		;year reg
	XOR	A
	LD	(HL),B
	RLD			;year to A low-nibble, 0 to hi
	ADD	A,81		;year was origin 81
	CALL	writea

;hms can go straight out to M3000

	LD	D,hour
setcl4:	INC	HL		;1st time round points to new hours
	

	LD	A,B		;Now test for BC=0400H => don't read
	SUB	4		;because the whole blk will be over-written
	OR	C
	CALL	NZ,rwblk	;IY contains all other info

	POP	HL
	POP	DE
	POP	BC

;	Now ready to write (into cache)
;	HL=source, DE=offset to dest., BC=byte count
rdywr:
	LD	(IY+1),0	;Needs writing (or soon will!)

	IF	RM

	LD	A,(page)	;Open paged RAM
	OUT	(pagon),A

	LD	A,D		;Add user's offset to address of paged RAM
	ADD	A,HIGH secbuf
	LD	D,A
	LDIR

	OUT	(pagoff),A	;Finished, so page off 
	LD	D,status
	LD	A,0
	CALL	writck		;writes A unmodified

;	HL points to start of new date

	LD	D,date
	CALL	write		;writes (HL) in decimal
	INC	HL
	INC	D		;month reg
	LD	B,(HL)
	LD	A,(HL)
	AND	15
	CALL	writea		;write the months out
	INC	D		;year reg
	XOR	A
	LD	(HL),B
	RLD			;year to A low-nibble, 0 to hi
	ADD	A,81		;year was origin 81
	CALL	writea

;hms can go straight out to M3000

	LD	D,hour
setcl4:	INC	HL		;1st time round points to new hours
	CALL	write		;(HL) in decimal
	DEC	D(value immaterial)

	ELSE		;NASCOM

	DI			;Stack does not work when page open!!
	LD	A,pawrit	;Enable page for writing
	OUT	(paport),A

	LD	A,(page)	;Add page number to offset
	ADD	A,D
	LD	D,A
	LDIR			;Do the transfer

	LD	A,panorm
	OUT	(paport),A	;Reset paging to normal
	EI

	ENDIF

	RET



;	Clear block to zero to give correct value in areas not initialised
;	by the user

clrblk:	LD	A,B
	SUB	4		; 0400H <=> 1K <=> block size
	OR	C
	JR	Z,rdywr		;ready to write

do:	PUSH	BC
	PU
	JP	P,setcl4	;stops when D=-1 ie just written secs reg

;now start clock - NB D=0FFH ie select status register

	LD	A,1
	JP	writck		;and finish


writea:	LD	(HL),A
write:	PUSH	BC

;convert to BCD

	XOR	A
	RLD			;top nibble to A lo

	LD	B,4
write1:	ADD	A,A
	DAA
	DJNZ	write1

	LD	B,A
 	XOR	A
	RLD			;A=lo nibble of 
	ADD	A,B
	DAA			;A now in BCD
	POP	BC


;WRITCK
;write an RTC register
;
;On entry:
; D	register to write
; A	value to write
;
;On exit:
; A	naff
; rest	OK
e start of new date
	LD	L,E

;now range check

	LD	A,(DE)		;Date 1..31 (not bothering about months yet)
	INC	DE
	OR	A
	RET	Z
	CP	32
	RET	NC

	LD	A,(DE)		;months (lo-nibble) 1..12
	AND	15
	INC	DE		;years don't need checking
	OR	A
	RET	Z
	CP	13
	RET	NC

	LD	A,(DE)		;hours 0..23
	INC	DE
	CP	24
	RET	NC

	LD	A,(DE)		;mins 0..59
	INC	DE
	CP	60
	RET	NC

	LD	A,(DE)		;secs 0..59
	CP	60
	RET	NC

; new time is OK - set no error

	XOR	A
	LD	(BC),A



;now set time: stop clock
ks	;Max number of blks that could possibly
mtloop:	PUSH	BC		;need writing
	CALL	cidle
	POP	BC
	DJNZ	mtloop
	RET



;PROCEDURE disc_rd(addr,length,offset:Word;VAR blk:block_descrip);
;
; Read in up to 1 block to specified address. <offset> is offset in block.
; Errors returned in common area <error>
;

discrd:	XOR	A
	LD	(errloc),A	;No error yet

	POP	HL
	EX	(SP),HL		;Get blockno. address

	CALL	fiblk		;Returns HL pointing to map entry
	JR	C,incach	;Carry => block already in cache

	LDrs are returned in common area <error>
;


discwr:	POP	HL		;Return address
	EX	(SP),HL		; addr of block descriptor


	CALL	fiblk		;Takes ^blk in HL, returns IY ^map entry,
				;Cf set if found, Else we have the former tail

	LD	HL,errloc 	;This user is not interested in any error
	LD	(HL),0  	; to do with previous contents of page

	POP	HL		;Return address
	POP	BC		;Pre_read flag
	DEC	B		;Pre_read now in Z flag, carry unchanged
	POP	DE		;Offset
	POP	BC		;Length
	EX	(SP),HL		;Source addr t	D,0FFH		;r/w flag =READ.
	CALL	rwblk

incach:	POP	HL		;Return addr.
	POP	DE
	POP	BC
	EX	(SP),HL
	EX	DE,HL

;	Now have: HL=source offset, BC=length, DE=destination address

	IF	t.on
	mcond	rdm1
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	DE
	mess	rdmess
	LD	L,(IY+2)	;Blockno.
	LD	H,(IY+3)
	CALL	dhxout
	mess	adrmsg
	POP	HL
	CALL	dhxout
	mess	atmsg
	LD	A,(page)
	CALL	cahex
	CALL	pcrlf
	POP	HL
	POP	DE
	POP	BC
rdm1:	POP	AF
	ENDIF

	IF	RM

	LD	A,(page)	;Open page
	OUT	(pagon),o HL

;	Now have Z <=> pre-read, NZ=> no read, C=> already in cache
;
	IF	t.on
	mcond	wrm1
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	HL
	mess	wrmess
	LD	L,(IY+2)	;Blockno.
	LD	H,(IY+3)
	CALL	dhxout
	mess	adrmsg
	POP	HL
	CALL	dhxout
	mess	atmsg
	LD	A,(page)
	CALL	cahex
	CALL	pcrlf
	POP	HL
	POP	DE
	POP	BC
wrm1:	POP	AF
	ENDIF

	JR	NZ,clrblk	;No pre-read means zap to =0
	JR	C,rdywr		; Carry => it's been pre-read anyway

	PUSH	BC
	PUSH	DE
	PUSH	HL

	LD	D,0FFH		; r/w flag (read)A

	LD	A,H		;High of offset
	ADD	A,HIGH secbuf	;Add offset to where paged RAM appears
	LD	H,A
	LDIR
	OUT	(pagoff),A	;Finished, so page off

	ELSE	;****** NASCOM

	LD	A,(page)	;Add page offset to user's offset
	ADD	A,H
	LD	H,A

	LD	A,paread	;Set up to call a LDIR in 'safe' RAM
	CALL	CtoRAM

	ENDIF

	RET			;Finished





;PROCEDURE disc_wr(addr,length,offset:Word;pre_read:Boolean;blk:block_descrip);
;
; Write up to 1 block from specified address. <offset> is offset in block.
; Erron time


;INIONE
;Initialise one drive
;
;On entry:
; A	Drive number
; HL	Number of blocks to allocate

inione:
	tmess	<almsg0,AF,almsg1,HL>

	PUSH	HL		;Save number of blocks
	EX	DE,HL		;DE:= no_of_blocks

	ADD	A,A		;Get address in mapptr
	LD	C,A		;BC:= A * 2
	LD	B,0

	LD	HL,dsksiz	;Put into disk size table
	ADD	HL,BC
	LD	(HL),E
	INC	HL
	LD	(HL),D

	SRМ	D		;Converф Blockу tп Byteу tп allocate
	RТ	E
	SRL	D
	RR	E
	SRL	D
	RR	E
	INC	DE

	LD	HL,mapptr+3	;+3 => point to map addreder heavy loading the items
; near the tail will never be written. However, these items will tend
; to get written anyway as the entries are either used & brought back
; to the top of the cache, or get thrown out to make space for new entries.

cidle:	LD	A,(page)
	LD	E,A		;place to start
	LD	A,(csize)	;Maximum no. of ents worth looking at
	LD	C,A
	LD	B,3		;Maximum no. of blocks we have time to write

idloop:	LD	IY,cacmap
	LD	D,0		;Turn E into 16-bit value
	ADD	IY,DE
	LD	A,(IY+1)	;Get needs wriss (H)
	ADD	HL,BC		;HL+:= A * 4
	ADD	HL,BC

	EXX			;Current heap address
	PUSH	HL
	EXX
	POP	BC

	LD	(HL),B		;Save current heap address in pointer table
	DEC	HL
	LD	(HL),C
	DEC	HL
	LD	(HL),D		;Also save length
	DEC	HL
	LD	(HL),E

	PUSH	DE		;Add length to heap
	EXX
	EX	DE,HL
	EX	(SP),HL
	ADD	HL,DE
	JP	C,heaped	;cf => heap > 0FFFFH !
	PUSH	HL
	LD	DE,myheap+heapln	;Check past end of heap
	SBC	HL,DE
	POP	HL
	JP	NC,heaped
	POP	DE
	EXX

	PUSH	BC
	PUSH	DE
	POP	BC		;Note: BC <-> DE
ting flag
	OR	A
	JR	NZ,idl1		;Doesn't need it

	PUSH	BC
				;D already contains 0 (meaning write)
	CALL	rwblk

	POP	BC
	DEC	B
	RET	Z		;Written as many as we want to

idl1:	LD	E,(IY+0)	;pointer to next entry in chain
	DEC	C		;Counter to prevent checking more entries
	JR	NZ,idloop	;than there are cache entries

	RET




;PROCEDURE cempty
;
;Write out any part of the cache which still has things in.
; Not called very often, so implemented compactly rather than fast.

cempty:	LD	B,nobl	POP	DE

	LD	H,D		;Get start
	LD	L,E
	INC	DE		;Clear map
	DEC	BC
	LD	(HL),-1

	tmess	<naloc0,BC,naloc1,HL,crlf>

	LDIR

	POP	DE		;Reset bits in last byte to indicate
	LD	A,E		; if not all availible
	AND	7
	JR	Z,inidk0
	LD	B,A
	SUB	A
inidk1:	SCF
	RLA
	DJNZ	inidk1
inidk0:	LD	(HL),A

	RET




;Heap error (overflow)

heaped:	error	'Heap oflow'





;PROCEDURE cidle
;
; Use FS idle time to write out any of the cache that needs it.
; Starts from the head, which means that unk
	LD	H,(IY+blkoff+1)

	ELSE			;Test option

	PUSH	AF
	mess	t200ms
	POP	AF

	LD	HL,200

	ENDIF

	POP	AF		;drive 0..4
	PUSH	AF
	CALL	inione		;Do that drive
	POP	AF
	DEC	A		;Repeat until finished
	JP	P,inilp0

	RET

;	Error exit. iabort is entry if errloc already set.

inierr:	LD	A,1		;Duff data in blk 0
	LD	(errloc),A
iabort:	POP	HL		;old drive no(rubbish)
	RET			;(errloc) set by rwdisc

b0tab:	DEFB	0		;This is a block descriptor for blk0
	DEFW	0		; the drive will be poked at ruRET

;
; PROCEDURE Char_io;
; Initialise character i/o (i not supported !)
; Also initialise messag,debug.

chario:	LD	HL,0
	LD	(sersp),HL
	LD	(serptr),HL
	LD	A,1		; Cache bank number
	LD	(serptr+2),A
	LD	(sersp+2),A

	LD	A,(07EH)
	LD	(mess),A
	LD	A,(07FH)
	LD	(debu),A

	RET



; Routine to wait for & read byte from 6502
; Value returned in A, all other regs preserved.
;
; NB.	the 6502 is now a Z80 !

wait65:	IN	A,(status)
	BIT	6,A
	JR	Z,wait65
	IN	A,(Jlatch)
	RET





Y to X performing 3-byte to 4-byte conversion


make4:	POP	IY		;Return address
	POP	HL		;Addr Y (triple is a SDT)
	POP	DE		;Addr X

	LD	BC,3		;Move the 3 bytes
	LDIR
	SUB	A		;Zero the last byte
	LD	(DE),A

	JP	(IY)		;Return





;caps
;Captilalise letter
;
;On entry:
; A	letter to be capped
;
;On exit:
; A	capital letter
; rest	preserved

caps:	CP	'a'
	RET	C
	CP	'z'+1
	RET	NC
	AND	05FH
	RET




	COMMON	/error/

err:	DEFS	1

	COMMON	/messag/

msgflg:	DEFS	1		;conta	COMMON	/prispa/
space:	DS	4

	COMMON	/priptr/
ptr:	DS	4

	COMMON	/messag/
mess:	DS	1

	COMMON	/debug/
debu:	DS	1


	DSEG
sersp:	DS	3

serptr:	DS	3

	END
,A
	LD	A,(07FH)
	LD	(debu),A

	RET



; Routine to wait for & read byte from 6502
; Value returned in A, all other regs preserved.
;
; NB.	the 6502 is now a Z80 !

wait65:	IN	A,(status)
	BIT	6,A
	JR	Z,wait65
	IN	A,(Jlatch)
	RET





ins 0 for no messages, 1 for messages on

	END
 ;Addr X

	LD	BC,3		;Move the 3 bytes
	LDIR
	SUB	A		;Zero the last byte
	LD	(DE),A

	JP	(IY)		;Return





;caps
;Captilalise letter
;
;On entry:
; A	letter to be capped
;
;On exit:
; A	capital letter
; rest	preserved

caps:	CP	'a'
	RET	C
	CP	'z'+1
	RET	NC
	AND	05FH
	RET




	COMMON	/error/

err:	DEFS	1

	COMMON	/messag/

msgflg:	DEFS	1		;contampare
	SBC	HL,DE
	EX	DE,HL		;Put valid number in HL
	RET	NC		;Ret if it is minimum

	ADD	HL,DE		;Restore other number
	RET



;FUNCTION mind (x, y: INTEGER): INTEGER
;
;Returns the minimum of X & Y

mind:	POP	IY		;Return address

	POP	BC		;Lo-X
	POP	DE		;Hi-X
	POP	HL		;Lo-Y
	EX	(SP),HL		;Make that Hi-Y

	CP	A		;Compare hi bytes
	SBC	HL,DE
	JR	Z,minxlo	;If EQ examine lo
	JR	NC,mindx	;X is min

	ADD	HL,DE		;Restore Hi-Y
	POP	BC		;Get lo-Y
	JP	(IY)

minxlo:	ADD	HL,DE		;Restore Hi-ers on stack for <discrd>

	IFF	t200		;Test --- Makes drive 200 blocks

	LD	HL,($hplm)	;Read this block above the system heap
	PUSH	HL
	LD	HL,0400H	;Length
	PUSH	HL
	LD	H,0		;Offset
	PUSH	HL
	LD	HL,b0tab	;Block descriptor set up to be blk0
	PUSH	HL
	CALL	discrd

	LD	A,(errloc)	;Had error ?
	OR	A
	JR	NZ,iabort


iniok:	LD	HL,($hplm)	;Where we put the block
	LD	BC,sjoff	;Offset of SJ string
	ADD	HL,BC
	LD	DE,sjmess	;Check it's an SJ disk
	LD	BC,23*256+1	;B:= len SJstring , C:= error notY
	EX	(SP),HL		;Get back lo

	CP	A		;Compare lo
	SBC	HL,BC
	JR	NC,mindx

	ADD	HL,BC		;Restore lo
	EX	(SP),HL		;Hi in HL
	POP	BC		;Lo in BC
	JP	(IY)

mindx:	POP	HL		;POP spurious
	EX	DE,HL
	JP	(IY)






;PROCEDURЕ makeі (VAТ xє triple¬ yє INTEGER)
;
;Assign Y to X performing 4-byte to 3-byte conversion

make3:	dstak	<BC,DE,HL>

	LD	(HL),C		;y is in DEBC: VAR x in HL
	INC	HL
	LD	(HL),B
	INC	HL
	LD	(HL),E
	RET





;PROCEDURЕ make4 (VAТ xє INTEGER¬ yє triple)
;
;Assign  SJ
csjlop:	LD	A,(DE)
	CP	(HL)
	JR	NZ,inierr
	INC	HL
	INC	DE
	DJNZ	csjlop

	POP	BC		;B:= drive
	PUSH	BC
	INC	B		;1..5

;set bit B in A

	LD	A,80H
sbilop:	RLCA
	DJNZ	sbilop
	LD	C,A		;has 1 one
	CPL			;has 1 zero

;Set/Reset bit in dsflag

	LD	IY,($HPLM)	;Where the block was put
	LD	HL,dsflag
	AND	(HL)		;first reset bit
	LD	B,A
	LD	A,(IY+dsfoff)	;double sidedness
	AND	C		;leave relevant bit
	OR	B		;add in rest of drives
	LD	(HL),A

	LD	L,(IY+blkoff)	;HL:= number of blocks on disck
	INC	H
	INC	H
	INC	H
	JR	NZ,cilop0

	IF	RM
	OUT	(pagoff),A
	ENDIF

	XOR	A
	LD	(page),A	;Head of chain pointer

	EI


; B=number of blocks in cache

	LD	A,B
	LD	(csize),A


	IF	t.on
	XOR	A
fudge1:	INC	A
	DAA			; Simple convert binary to BCD!
	DJNZ	fudge1
	CALL	cahex
	mess	cfrmes
	ENDIF

	POP	AF		;drive

	EXX			;Init heap
	LD	HL,myheap
	EXX

; this loop occurs once for each disk

inilp0:	PUSH	AF		;drive
	LD	(b0tab),A	;Put drive in block descriptor

;	Set up paramet



;PROCEDURE mhexd (n: INTEGER; addr: WORD)
;
;Put the ASCII of <n> at address <addr>

mhexd:	dstak	<BC,DE,HL>

	CALL	hexw		;Print high word
	EX	DE,HL		;Print low word
	JR	hexw





;PROCEDURE mhexw (n: WORD; addr: WORD)
;
;Put the ASCII of <n> at address <addr>

mhexw:	dstak	<BC,HL>

hexw:	CALL	hexb		;Print high byte
	LD	A,L		;Print low byte
	JR	hexba






;PROCEDURE mhexb (n: BYTE; addr: WORD)
;
;Put the ASCII of <n> at address <addr>

mhexb:	dstak	<BC,HL>

hexb:	Loke last char.

	ADD	A,"0"
	LD	(HL),A

	POP	HL		;string address
	LD	(HL),E		;insert length
	RET



adivb:	LD	C,'0'-1
adivb2:	INC	C
	SUB	B
	JR	NC,adivb2
	ADD	A,B
	LD	B,A		;rest of number in B

	LD	A,C
	CP	D		;D=C if C='0' and haven't printed any chars
	LD	A,B		;restore number
	RET	Z

	LD	(HL),C		;poke the character
	INC	HL
	INC	E		;char count
	DEC	D		;have printed a char so always print the rest
	RET


 

;PROCEDURE hex2S (n: BYTE; VAR aS: min_string)
;
;Puts the ASCII of <nD	A,H
hexba:	PUSH	AF		;Save A
	RRCA			;Print high nibb
	RRCA
	RRCA
	RRCA
	CALL	mnib
	POP	AF		;Restore A & drop thro' to print lo-nibb

mnib:	AND	15		;A:= nibb(A)
	ADD	A,90H		;Magic hex producing formula
	DAA
	ADC	A,40H
	DAA
	LD	(BC),A		;Put in memory
	INC	BC		;Point to next byte
	RET






;PROCEDURE mdecb (n:Byte; addr:Word);
;
;Put ASCII of <n> in decimal at addr.
;leading zeroes supplied

mdecb:	POP	BC
	POP	HL		;addr
	POP	AF		;number
	PUSH	BC

	LD	B,'0'-1
mdecb1:	SUB	10> into <aS>

hex2S:	dstak	<BC,HL>

	LD	A,2		;Put in length
	LD	(BC),A
	INC	BC		;Inc string pointer

	JR	hexb		;Fill in hex





;FUNCTION handle (n: BYTE): BYTE
;
;Returns the handle of <n> which is 2^(n-1)

handle:	POP	HL		;Return address
	POP	BC		;B:= n
	SUB	A		;A:= 0
	SCF			;Set carry so can rotate in

handlp:	RLA			;Whizz it round
	DJNZ	handlp

	JP	(HL)		;Return






;FUNCTION minw (x, y: WORD): WORD
;
;Returns the minimum of X & Y

minw:	dstak	<DE,HL>

	CP	A		;Co
	INC	B
	JR	NC,mdecb1

;B=tens in ASCII

	LD	(HL),B
	INC	HL

	ADD	A,10+'0'
	LD	(HL),A
	RET




;PROCEDURE DecS(n:Byte; VAR aS:minstring)
;
;much the same as mdecb except that leading zeroes are stripped
;and numbers are in range 0..255

decs:	POP	BC
	POP	HL		;string address
	POP	AF		;number
	PUSH	BC
	PUSH	HL

	LD	E,1		;count for number of chars poked (at least 1)
	INC	HL		;1st byte is len, text at 2nd byte

	LD	B,100
	LD	D,"0"
	CALL	adivb

	LD	B,10
	CALL	adivb

; always pto winchester

pcod2:	DI
	OUT	(paport),A	;Same logic as above
	OTIR
	OTIR			;Only to disc this time.
	LD	A,panorm
	OUT	(paport),A
	EI
	RET

CtoWIN	EQU	pacode+pcod2-pcod1	;Where it ends up
CtoRAM	EQU	pacode

	ENDIF





;PROCEDURE inidsk (max_drive: BYTE);
;
;This procedure allocates heap for the map for all drives

inidsk:	POP	HL		;Return address
	EX	(SP),HL		;Max_Drive
	PUSH	HL		;Save drive again


	LD	HL,mapptr	;Init bit map pointers & track stores
	LD	DE,mapptr+1
	LD	BC,max	JR	NZ,cilop2

; same again so this page IS being used as main RAM

	CPL
	LD	(DE),A		;restore RAM
	JR	cilop1		;Don't link in block

	ELSE			;******* ASSUME NASCOM *********

	LD	A,H
	CP	0C0H		;Only 48k available
	JR	NC,cilop1

	ENDIF

cilop2:	INC	B		;We have a good block
	LD	(IY),H		;Link it to the last good one
	LD	IY,cacmap
	PUSH	BC		;Save to make a spare register
	LD	B,0
	LD	C,H
	ADD	IY,BC		;Set IY to point to the block 
	POP	BC		; just tested

cilop1:	INC	H		;Proceed to next blodrv*5-1
	LD	(HL),-1
	LDIR

	LD	HL,cacmap	;clear cache map
	LD	DE,cacmap+1
	LD	BC,noblks*4-1
	LD	(HL),-1		;all blocks free
	LDIR


;Work out how much cache is actually available & set up chain
;
; On NASCOM, always 1st 48K
;
; block 0 assumed to be OK.
; Note: when testing this page the code is safe due to LD HL,$ fudge

	LD	HL,$		;Load L with low byte of here
	LD	D,HIGH secbuf	;where paged RAM appears
	LD	E,L		;ensure same offset for test
	IF	rm
	LD	BC,pagon+256	;B:=1; (size counter) C;Point to next attribute
	DJNZ	attlop		;Loop if not finished

	RET

lokatt:	DEFM	'+-'
attstr:	DEFM	'XPDLWR/WR'	;The nine deadly attributes







;PROCEDURE mhext (VAR n: triple; addr: WORD)
;
;Put the ASCII of <n> at address <addr>

mhext:	dstak	<BC,HL>

	INC	HL		;Point to high byte
	INC	HL

	LD	E,3		;Loop count:= 3
tlop:	LD	A,(HL)		;Get byte
	CALL	hexba		;Print it
	DEC	HL		;Point to next lower byte
	DEC	E		;Dec loop count
	JR	NZ,tlop		;If not finished then loop

	RET



:=pagon
	ELSE
	LD	BC,0100H	;No test if Nascom
	ENDIF
	LD	H,4		;Pageno. under test
	LD	IY,cacmap	;IY points to the block which will point here
				;if this one is any good.
	DI

cilop0:
	IF	RM		;Different tests on RM & N2
				;Ends up at cilop1 if dud, cilop2 if OK
	LD	A,H
	CP	hitest
	JR	NC,cilop2	;Last few blocks always there

	OUT	(C),H
	LD	A,(DE)
	CP	(HL)
	JR	NZ,cilop2	;Not the same piece of ram, so OK

; two versions of byte the same: try other way up.

	CPL
	LD	(DE),A
	CP	(HL)
	nascom

	LD	HL,pcod1	;The main copy of the code
	LD	DE,pacode	;The RAM where it lives
	LD	BC,030H		;Generous length allowance
	LDIR

	ENDIF

	RET


;	This code only present on NASCOM,
;	where it is copied to a piece of STATIC RAM, so that it remains
;	in the memory map even if paging is active

	IF	nascom

	;Cache to main RAM

pcod1:	DI
	OUT	(paport),A	;Turn on paging
	LDIR
	LD	A,panorm	;Set back to normal
	OUT	(paport),A
	EI			;Interrupts are off while cache open
	RET

	;Cache 




;PROCEDURE setatt (VAR old_att: BYTE; new_att: BYTE)
;
;Set old_att to new_att and validate. Error return in COMMON /error/

setatt:	POP	HL		;Return address
	EXX
	POP	DE		;D':= new_att
	LD	B,1		;modify:= replace
	EXX
	EX	(SP),HL		;HL:= @old_att
	JR	doset		;Jump to validate & store routine




;PROCEDURE expatt (att_byte: BYTE; VAR att_string: min_string)
;
;Convert the attributes in <att_bye> into an exploded
; character string in <att_string>

expatt:	dstak	<DE,HL>

	PUSH	DE	
	DJNZ	gatlop
	POP	BC

	DEC	B		;TEST modify > 0
	JP	M,subat

	OR	D		;THEN or_mask |:= A
	LD	D,A

	JR	impat4

subat:	CPL			;ELSE $(
	PUSH	AF
	AND	E		;   and_mask &:= ~A
	LD	E,A
	POP	AF
	AND	D		;   or_mask &:= ~A
	LD	D,A		;$)

impat4:	INC	B		;// Restore modify

impat0:	EXX			;$) // End of SWITCHON
impat3:	DJNZ	impat2		;$) // End of FOR loop

impat1:	EX	DE,HL		;HL:= old_attributes
doset:	LD	A,(HL)		;A:= %old_attributes
	EXX
	DEC	B		;IF modify = 1 DO and_mask:= A0H
	JR	NZ,notrep
	L	;IY:= DE
	POP	IY
	LD	(IY+0),0	;Zero string length

	LD	A,H		;A:= attbyte
	LD	B,9		;9 bits in byte+cf
	LD	HL,attstr	;HL:= 'XPDLWR/WR'

	RRCA			;Set the '/' attribute
	RRCA
	SCF
	RLA
	RLA

attlop:	RLA			;Test bit & set up for next
	JR	NC,notset	;No => don't insert att in string

	PUSH	AF		;Save attributes
	LD	A,(HL)		;Get attribute
	INC	DE		;Increment string pointer
	INC	(IY+0)		;Increment string length
	LD	(DE),A		;Put attribute in string
	POP	AF		;Restore attibutes

notset:	INC	HL		D	E,0A0H		;AND mask to preserve X & D
notrep:	AND	E		;A:= (A & and_mask) | or_mask
	OR	D
	EXX
	LD	C,A		;// Save new atts in C
	XOR	(HL)		;IF {X | D bits modified}
	AND	0A0H
	JR	NZ,moderr
	LD	A,C		;// Come back A all is forgiven !
	BIT	5,A		; | ({D bit set}
	JR	Z,domod
	AND	15		; & {any of WR/WR set})
	JR	Z,domod
moderr:	LD	A,illmod	;DO $( error:= illegal_modification
	LD	(err),A
	RET			;   FINISH $)

domod:	LD	(HL),C		;%old_attributes:= new_attributes
	SUB	A		;error:= 0
	LD	(err),A
	RETe string

wrtfin:	LD	HL,81			;Stack frame size
	ADD	HL,SP
	LD	SP,HL
	JP	(IY)			;Return

;
; PROCEDURE Wrtln(aS:Min_string);
;
; As Wrt, but followed by a CRLF.
;

Wrtln:	POP	IY

	CALL	dowrt
	CALL	PCRLF

	JR	wrtfin



;	Write out string from stack.

dowrt:	LD	HL,2
	ADD	HL,SP			;Point above return addr

	LD	A,(HL)			;Length
	OR	A
	RET	Z			;Give up if null
wrtlop:	INC	HL
	LD	E,(HL)			;Char
	CALL	PCHAR
	DEC	A
	JR	NZ,wrtlop
	RET


;
ERRMES:	DB	0DH,0AH,'Error $'
ATADDR:	DB	g.
; NB3 do not muck about with this code!

crlf:	DEFM	cr,lf,'$'


	IF	t.on

;dhxout
;Print hex of HL

dhxout:	LD	A,H
	CALL	cahex
	LD	A,L
				;DROP THROUGH
;cahex
;Print hex of A
;
;On entry:
; A	number to be printed

	JP	cahex		;Now lives in h2lib or some such place
;
; Print a crlf!
pcrlf:	LD	DE,crlf
	JP	pmess


wrmess:	DEFM	'Write block $'
rdmess:	DEFM	'Read block $'
adrmsg:	DEFM	' address $'
dtsmsg:	DEFM	' RDTS=$'
atmsg:	DEFM	' @ $'
errmsg:	DEFM	' fatal disc error $'
rt' at $'
;
	END

g);
;
; As Wrt, but followed by a CRLF.
;

Wrtln:	POP	IY

	CALL	dowrt
	CALL	PCRLF

	JR	wrtfin



;	Write out string from stack.

dowrt:	LD	HL,2
	ADD	HL,SP			;Point above return addr

	LD	A,(HL)			;Length
	OR	A
	RET	Z			;Give up if null
wrtlop:	INC	HL
	LD	E,(HL)			;Char
	CALL	PCHAR
	DEC	A
	JR	NZ,wrtlop
	RET


;
ERRMES:	DB	0DH,0AH,'Error $'
ATADDR:	DB	rmsg:	DEFM	' bad $'
almsg0:	DEFM	'Init map $'
almsg1:	DEFM	' - length $'
naloc0:	DEFM	cr,lf,'Clear $'
naloc1:	DEFM	' bytes from $'
alblk0:	DEFM	'Allocate block $'
alblk1:	DEFM	' from map $'
frblk0:	DEFM	'Free block $'

cfrmes:	DEFM	'k Cache size',cr,lf,'$'

	ENDIF

	IF	t200
t200ms:	DEFM	'Fixed size of 200K allocated',cr,lf,'$'
	ENDIF





;PROCEDURE inilow
;
;Initialize everything that needs initing:
;Currently not very much.
;Nascom vers puts paging code in safe RAM

inilow:
	IFersion on screen
	JP	pmess

veradr:	LD	HL,verblk		;Address of version text to
	RET				;Transmit for *VERS

verlen:	LD	HL,crlf-verblk+1	;Length of transmitted text
	RET

verblk:	DEFW	0			;Std. Tx Header

sjmess:	DEFM	'SJ Research File Server ver '
	DEFW	verhi,verlo

	IF	RM
	IF	large
	DEFM	'/8"'
	ELSE
	DEFM	'/5"'
	ENDIF
	ENDIF
	IF	nascom
	DEFM	'/Nascom'
	ENDIF

; NB this label must be defined before any references to the MESS
; macro is made.
; NB2 also forms part of the above strin:	IN	A,(status)
	BIT	1,A
	JR	Z,chk1		;Front sw is in syst position
	BIT	2,A
	RET	NZ		;Front sw is in Secure position

	CALL	emptyC		;Power off pos of switch
	LD	A,12		;Turn off relay
	CALL	to6502
chk3:	JR	chk3		;wait for end of world

chk1:	BIT	3,A		;In syst pos., so check for back pannel reset
	RET	NZ
	CALL	emptyC
	JP	fsexit

;
; FUNCTION Syst_sw:Boolean;
;
; Return condition of key switch.

systsw:	IN	A,(status)
	CPL			;Bit is active LOW
	AND	2
	RRCA			;return 0 (False) or 1 (True)n $HERAD
;		B,DE	Count & address of extra display (if present)
;		(SP+2)	Address to be included in message
;			if bit 2 of C is zero
;
;
$HERR:	RR	C
	JR	NC,EMOUT	; no extra display
	EX	DE,HL
;
CHLOOP:
	LD	E,(HL)		; char from message
	INC	HL
	CALL	PCHAR
	DJNZ	CHLOOP
;
;	Output error code
;

EMOUT:
	LD	DE,ERRMES	; 'Error '
	CALL	pmess
	LD	E,A		; code letter
	CALL	PCHAR
;
	LD	DE,ATADDR	; ' at address '
	CALL	pmess
;
;
;	Convert address to hex
;
	POP	DE
	POP	HL		; address for dis
	RET

;
; PROCEDURE Char_io;
; Initialise character i/o (i not supported !)
; Also initialise messag,debug.

chario:	LD	HL,0
	LD	(sersp),HL
	LD	(serptr),HL
	LD	A,1		; Cache bank number
	LD	(serptr+2),A
	LD	(sersp+2),A

	LD	A,(07EH)
	LD	(mess),A
	LD	A,(07FH)
	LD	(debu),A

	RET



; Routine to wait for & read byte from 6502
; Value returned in A, all other regs preserved.
;
; NB.	the 6502 is now a Z80 !

wait65:	IN	A,(status)
	BIT	6,A
	JR	Z,wait65
	IN	A,(Jlatch)
	RET



play
	PUSH	HL
	PUSH	DE

	LD	A,C
	AND	2
	JR	Z,CAD2
	LD	HL,($HERAD)	; alternative error address
;
CAD2:
	LD	A,H
	CALL	CAHEX
	LD	A,L
	CALL	CAHEX
;
	CALL	PCRLF

;	Terminate program
;
$HTERM:
	JP	fsexit


pmess:	PUSH	AF
	PUSH	DE
	PUSH	HL
	EX	DE,HL
	LD	A,'$'
pmess0:	LD	E,(HL)
	CP	E
	CALL	NZ,PCHAR
	INC	HL
	JR	NZ,pmess0
	POP	HL
	POP	DE
	POP	AF
	RET

;
; PROCEDURE Wrt(aS:min_string);
;
; Write out string to console
;
Wrt:	POP	IY			;Return Addr

	CALL	dowrt			;Write out th

	COMMON	/prispa/
space:	DS	4

	COMMON	/priptr/
ptr:	DS	4

	COMMON	/messag/
mess:	DS	1

	COMMON	/debug/
debu:	DS	1


	DSEG
sersp:	DS	3

serptr:	DS	3

	END
ss),A
	LD	A,(07FH)
	LD	(debu),A

	RET



; Routine to wait for & read byte from 6502
; Value returned in A, all other regs preserved.
;
; NB.	the 6502 is now a Z80 !

wait65:	IN	A,(status)
	BIT	6,A
	JR	Z,wait65
	IN	A,(Jlatch)
	RET



E
	INC	HL
	LD	(HL),D

	EX	DE,HL
	ADD	HL,BC			;Add <size> to heap end

;	HL=new heap pointer, all other regs not reqd.

	PUSH	HL
	LD	HL,return
	JP	getmem			; Returns top of RAM in DE
return:	EX	DE,HL
	POP	DE
	OR	A			; clear carry
	SBC	HL,DE			;Calculate space left for stack
	LD	BC,stksiz
	SBC	HL,BC			;Carry set if heap left < heap reqd
	SBC	A,A			;A=0 if carry clear, &FF otherwise
	INC	A			;A=0 <=> no room, A=1 => ok
	RET	Z			;Return False, & do not set heap ptr
	
	EX	DE,HL			;HL:=new hthe
;	console.  (Uses A, E.)
;

cahex:	PUSH	AF
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	cahex1
	POP	AF

cahex1:	AND	15
	ADD	A,90H
	DAA
	ADC	A,40H
	DAA
	LD	E,A

	JP	pchar



;
;
;	Errors within Pascal-coded library
;
$PERR:
	POP	HL		; return address
	POP	AF		; A := error no.
	LD	C,2
	PUSH	HL
	CALL	$HERR
	RET
;
;
;	$HERR	Run-time error handling routine.
;
;	Entry	A	Error code letter
;		C	Bit 0 = 1 if extra display
;			Bit 1 = 1 if optional restart
;			Bit 2 = 1 if error address ieap pointer
	JR	sethep			;Set $HPLM, $STKLM & return
					;Leaves A, Zflag unchanged




;	ProPascal housekeeping library (2)
; NAME	('H2LIB')


;	Date	19 October 1983
;
;	Copyright (C) 1981,1982   Prospero Software
;
;	This module contains the routines for passing calls
;	to BDOS, for reporting run-time errors, and for
;	program termination.
;


	IF	0

;	$HALOC		Take space from free store
;
;On entry:
; BC	Size required
;

$HALOC:	LD	HL,($HPLM)
	ADD	HL,BC		; new limit
	JR	C,H02

; Now update pointer

	EX	DE,HL		;Length now in DE
	LD	HL,(serptr)
	OR	A		;Clear carry
	ADC	HL,DE
	LD	(serptr),HL
;	RET	NC		;No carry into hi byte so not off end of cache
exitNZ:	XOR	A		;We have done something - return NZ
	INC	A
	RET			;64K buffer, so no wrap-round code




;
; Routine to poll front pannel switches
;
; If switch is 'Off' then exit FS & kill power.
; If rear pannel reset is pushed AND front switch is in sys_priv position,
; then exit to maintainance mode.


chkswALERR	; beyond 64K
	LD	($HPLM),HL

	LD	BC,GAP		; set $STKLM to complement
	ADD	HL,BC		; .. of new limit + gap
	JR	C,HALERR
	LD	A,H
	CPL
	LD	H,A
	LD	A,L
	CPL
	LD	L,A
	LD	($STKLM),HL

	ADD	HL,SP		; check current SP value
	RET	C

HALERR:	POP	DE		; discard $HALOC link
	LD	A,'H'
	LD	C,4		; fatal error, link in $HERAD
	CALL	$HERR		; signal error H - Call puts PC on stak

	;doesn't drop thro' (4 SRL)

	ENDIF

;CAHEX
;
;	Subroutine to convert byte in A to
;	two hex digits and output to 	Z
	LD	A,1
	RET




;GETMEM
;
;This routine returns the first unavailible memory location on the
; machine in DE & returns to HL

getmem:

	LD	DE,(1)		;Start of bios
	LD	E,0
	JP	(HL)




;PCHAR
;
;Print character in E.  All registers preserved
;See Listot: for explanation.

pchar:	PUSH	AF
	PUSH	HL
	PUSH	BC
	PUSH	DE

	LD	HL,fx3val
	LD	A,4
	CP	(HL)
	JR	Z,pchar1	;FX 3 already set for vdu
	LD	(HL),A
	LD	L,A		;Parameters for osbyte
	LD	A,3
	CALL	osbyte

pchar1:	POP	DE		;Chwill be stored

readck:	CALL	w3000		;Returns with irq disabled
	OUT	(C),D
	IN	A,(C)
	LD	(HL),A
	IN	A,(C)
	EI
	RLD
	RET
;
;w3000
; Wait for m3000 to be ready.  Exits with IRQ disabled.


w3000:	LD	C,clock

w3001:	EI
	NOP			;Allow IRQs to happen
	DI
	IN	A,(C)
	OR	0F0H
	INC	A
	JR	Z,w3001

;There is a bug in the M3000 st at the end of an update cycle the device goes
;not busy 32us before it actually goes ready, so we have to wait 32us....

	LD	A,32*6/(4+12)+1		;32us at 6MHz
w3002:	Dth in B
	INC	D
	CALL	read		;year origin 1900 in A
	SUB	81		;we require origin 1981
	LD	(HL),A		;year to lo-nibble
	LD	A,B
	RLD			;month to lo-nibble, year to hi

; now check seconds again

	LD	HL,rsec
	LD	B,(HL)
	LD	D,second
	CALL	read
	SUB	B
	JP	NZ,getclk	;go round again if failed

	INC	A		;A=1 ie TRUE
	RET			;OK




;read
;read an M3000 register
;
;On entry:
; D	register number
; HL	RAM address
;
;On exit:
; A,(HL) register contents IN HEX
; C	points to clock port
; rest	pEC	A
	JR	NZ,w3002

;but by this time it may have gone busy again...

	IN	A,(C)
	OR	0F0H
	INC	A
	JR	Z,w3001

	RET				;Not busy!




;PROCEDURE SetClk(address_of_new_time:Word);
;returns error=90H if date is invalid.
;If there is no RTC then the date & month/year is stored, but the
;hours/mins/secs are zeroed to indicate that they are not meaningful

setclk:	POP	HL
	POP	DE		;DE=pointer to new date/time
	PUSH	HL

	LD	BC,errloc
	LD	A,90H	;set error initially
	LD	(BC),A

	LD	H,D		;Savreserved

read:	CALL	readck
	LD	A,(HL)

;tohex
;On entry:
; A	BCD number
;
;On exit:
; A,(HL) hex number
; rest	preserved

tohex:	PUSH	BC
	LD	C,A
	RRCA
	RRCA
	RRCA
	RRCA
	AND	15
	ADD	A,A		;*2
	LD	B,A
	ADD	A,A		;*4
	ADD	A,A		;*8
	ADD	A,B		;*10
	LD	B,A
	LD	A,C		;this contains some of the hi-nibble set
	AND	15
	ADD	A,B		;and add lo-nibble
	POP	BC
	LD	(HL),A
	RET


;READCK
;Read a register from RTC
;
;On entry:
; D	register to be read
; HL	points to 1-byte block where reg L>

	LD	A,badatt
	LD	(err),A		;error:= bad_attribute

	EXX
	LD	BC,0100H	;modify, lowatt:= 1, 0
	LD	DE,00FFH	;or_mask, and_mask:= 0, 255
	EXX

	LD	B,(HL)		;FOR i = 1 TO string%0 DO $(
	LD	A,B		; // Test for null string
	OR	A
	JR	Z,impat1

impat2:	INC	HL		;A:= string%i
	LD	A,(HL)
	CALL	caps		;A:= caps(A)
	CP	' '		;IF A = ' ' DO LOOP
	JR	Z,impat3	; // Note: Other side of far EXX

	EXX

	LD	HL,lokatt	;HL:= "+-XPDLWR/"
	PUSH	BC
	LD	BC,9		;BC:= len(HL)
	CPIR			;A:= {9 - char posn in HL owitch *FX 3
; to select printer versus screen. <fx3val> indicates the present state.

listot:	LD	HL,fx3val
	LD	A,2
	CP	(HL)
	JR	Z,list1		;FX 3 already set for printing
	LD	(HL),A
	LD	L,A		;Parameters for osbyte
	LD	A,3
	CALL	osbyte

list1:	POP	HL		;Return addr
	POP	AF		;Char
	PUSH	HL
	JP	oswrch




;FUNCTION inkey (VAR ch: BYTE): BOOLEAN
;
;Test the keyboard to see if a char is ready.  Return true if so
; and put the char in <ch>.  If no character ready returns false
; and contents of A}
	LD	A,C
	POP	BC
	RET	NZ		;IF {not found} DO FINISH
	JP	PE,notsla	;SWITCHON A INTO $(
	LD	A,C		;CASE 0: IF low_att ~= 0 DO FINISH
	OR	A
	RET	NZ
	LD	C,3		;low_att:= 3
	JR	impat0		;ENDCASE

notsla:	CP	7
	JR	C,noratt
	LD	B,0		;CASE 7: modify:= 0; ENDCASE
	JR	Z,impat0
	LD	B,2		;CASE 8: modify:= 2; ENDCASE
	JR	impat0

				;OTHERWISE:
noratt:	CP	C		;IF A > low_att DO A +:= 2
	JR	C,loatt
	INC	A
	INC	A

loatt:	PUSH	BC		;A:= 1 << (A-1)  //Note: BC saved
	LD	B,A
	SUB	A
	SCF
gatlop:	RLAf <ch> are preserved

inkey:	LD	A,081H		;osbyte no. for INKEY
	LD	HL,0		;No delay
	CALL	osbyte

	EX	DE,HL		;Save results
	POP	HL		;Return address
	EX	(SP),HL		;Address of <ch>

	LD	A,D		;0FFH if timeout, 0 otherwise
	INC	A
	RET	Z		;No char, A=false
	LD	(HL),E
	RET			;A=true



;FUNCTION listst: BOOLEAN
;
;Returns true if device ready to receive a charcter

listst:	LD	A,080H		;ADVAL
	LD	HL,-4		;check printer buffer
	CALL	osbyte
	LD	A,L		;Result=no.of free slots in buffer
	OR	A
	RETTITLE Various FS m/c-dependant routines 11/1/84: FSMDEP.MAC
.Z80
NAME	('MDEPBBC')

; modifications:
; 26/7/84 BBC version - also contains Econet externals


PUBLIC	fsexit, listot, inkey, getmem, pchar
PUBLIC	listst

PUBLIC	ecotx, rxset, delrx, rxread, ecoini

true	EQU	-1
false	EQU	0

oswrch	EQU	0FFEEH
osword	EQU	0FFF1H
osbyte	EQU	0FFF4H

fsexit	EQU	0		;Re-boot CP/M


;PROCEDURE listot (ch: BYTE)
;
;Output a char to the list device
; We operate with a VDU 2 permanently active, and s
; C	points to clock port
; rest	preserved

read:	CALL	readck
	LD	A,(HL)

;tohex
;On entry:
; A	BCD number
;
;On exit:
; A,(HL) hex number
; rest	preserved

tohex:	PUSH	BC
	LD	C,A
	RRCA
	RRCA
	RRCA
	RRCA
	AND	15
	ADD	A,A		;*2
	LD	B,A
	ADD	A,A		;*4
	ADD	A,A		;*8
	ADD	A,B		;*10
	LD	B,A
	LD	A,C		;this contains some of the hi-nibble set
	AND	15
	ADD	A,B		;and add lo-nibble
	POP	BC
	LD	(HL),A
	RET


;READCK
;Read a register from RTC
;
;On entry:
; D	register to be read
; o
	RET	C		;IF A <= 0 DO FINISH
	RET	Z
	LD	B,A		;B:= A

	LD	A,' '		;A:= pad char
padlop:	INC	HL		;Pad it
	LD	(HL),A
	DJNZ	padlop

	RET







;PROCEDURE incw (VAR n: WORD)
;
;Increment n

incw:	dstak	<HL>

	INC	(HL)		;Increment low byte
	RET	NZ		;nz => no need to inc high byte
	INC	HL
	INC	(HL)		;Incremeent high byte
	RET





;PROCEDURE incb (VAR n: BYTE)
;
;Increment n

incb:	dstak	<HL>

	INC	(HL)		;Increment byte
	RET			;Return



;PROCEDURE decw (VAR n: WORD)HL	points to 1-byte block where reg will be stored

readck:	CALL	w3000		;Returns with irq disabled
	OUT	(C),D
	IN	A,(C)
	LD	(HL),A
	IN	A,(C)
	EI
	RLD
	RET
;
;w3000
; Wait for m3000 to be ready.  Exits with IRQ disabled.


w3000:	LD	C,clock

w3001:	EI
	NOP			;Allow IRQs to happen
	DI
	IN	A,(C)
	OR	0F0H
	INC	A
	JR	Z,w3001

;There is a bug in the M3000 st at the end of an update cycle the device goes
;not busy 32us before it actually goes ready, so we have to wait 32us....

	LD	A,32
;
;Decrement n

decw:	dstak	<HL>

	LD	A,(HL)		;Decrement low byte
	DEC	(HL)
	OR	A		;Was low byte zero BEFORE dec
	RET	NZ		;nz => no need to inc high byte
	INC	HL
	DEC	(HL)		;Decremeent high byte
	RET





;PROCEDURE decb (VAR n: BYTE)
;
;Decrement n

decb:	dstak	<HL>

	DEC	(HL)		;Decrement byte
	RET			;Return






;PROCEDURE impatt (VAR att_string: min_string; VAR att_byte: BYTE)
;
;Implode <att_string> into <att_byte>. Error return in COMMON /error/

impatt:	dstak	<DE,H*6/(4+12)+1		;32us at 6MHz
w3002:	DEC	A
	JR	NZ,w3002

;but by this time it may have gone busy again...

	IN	A,(C)
	OR	0F0H
	INC	A
	JR	Z,w3001

	RET				;Not busy!




;PROCEDURE SetClk(address_of_new_time:Word);
;returns error=90H if date is invalid.
;If there is no RTC then the date & month/year is stored, but the
;hours/mins/secs are zeroed to indicate that they are not meaningful

setclk:	POP	HL
	POP	DE		;DE=pointer to new date/time
	PUSH	HL

	LD	BC,errloc
	LD	A,90H	;set error inop if zero

gotcmd:	CALL	getcmd		;A:= <cmd code>

	POP	HL		;Remove last stack level
movstr:	POP	HL		;HL:= start of string

	LD	C,B		;C:=new string length

	PUSH	AF		;Save cmd code

;Test whether to display the cmd text

	CP	5		;*I AM
	JR	Z,nomsg
	CP	244		;*PASS
	JR	Z,nomsg	
	LD	A,(msgflg)	
	OR	A		;Test message flag
	JR	Z,nomsg		; Z if off

	PUSH	DE
	PUSH	HL
	PUSH	BC

	LD	B,(HL)		;Original string length
msglp:	INC	HL
	LD	E,(HL)		;Get char
	CALL	pchar		;print it
	DJNZ	msglp
	CALLm







;FUNCTION land (a, b: WORD): WORD
;
;Returns the logical AND of A & B

land:	dstak	<DE,HL>

	LD	A,L		;Do lo-byte
	AND	E
	LD	L,A

	LD	A,H		;Do hi-byte
	AND	D
	LD	H,A

	RET






;PROCEDURE pad (VAR str: min_string; length: BYTE)
;
;Pads a string to length <length> with spaces

pad:	dstak	<AF,HL>

	LD	B,0
	LD	C,(HL)		;BC:= Current string length
	LD	(HL),A		;Set new length of string

	ADD	HL,BC		;Point to last char of string

	SUB	C		;A:= number of bytes to zer	pcrlf

	POP	BC
	POP	HL
	POP	DE

nomsg:	POP	AF		;Restore cmd code

	LD	(HL),C		;Set string length
	INC	HL		;Point at start of text
	DEC	C		;IF B = 0 DO FINISH
	INC	C
	RET	Z

	LD	B,0		; BC:=Length
	EX	DE,HL		;Put HL,DE right way round
	LDIR			;Move

	RET



;getcmd
;Get the command code of this command & leave the pointer
; pointing to the start of the next command.
;
;On entry:
; HL	points to somewhere in the command text
;
;On exit:
; A	command code
; HL	points to start of ne	;=rmonth
	CALL	read
	LD	B,A		;month in B
	INC	D
	CALL	read		;year origin 1900 in A
	SUB	81		;we require origin 1981
	LD	(HL),A		;year to lo-nibble
	LD	A,B
	RLD			;month to lo-nibble, year to hi

; now check seconds again

	LD	HL,rsec
	LD	B,(HL)
	LD	D,second
	CALL	read
	SUB	B
	JP	NZ,getclk	;go round again if failed

	INC	A		;A=1 ie TRUE
	RET			;OK




;read
;read an M3000 register
;
;On entry:
; D	register number
; HL	RAM address
;
;On exit:
; A,(HL) register contents IN HEXxt command

getcmd:	BIT	7,(HL)		;Last char of cmd ?
	INC	HL		;Inc ptr {zf preserved}
	JR	Z,getcmd	;No => loop
	LD	A,(HL)		;Get <cmd code>
	INC	HL		;Inc ptr to start of next cmd
	RET


;Command table


cmdtab:	cm	CAT,3,+
	cm	SAVE,1
	cm	LOAD
	cm	INFO,n+2
	cm	<I AM>
	cm	SDISC
	cm	SDISK,n
	cm	DIR
	cm	LIB,n+2
	cm	DELETE,254,-
	cm	BYE
	cm	CDIR
	cm	BANNER
	cm	PRE
	cm	POST
	cm	ENDTEXT
	cm	NOBANNER
	cm	ACCESS
	cm	ACCOUNT
	cm	PASS
	cm	RENAME
	cm	DEFACCESS
	cm	CREDIT
	cm	DEBIT

	c
	CP	60
	RET	NC

; new time is OK - set no error

	LD	(HL),0

	EX	DE,HL		;HL points to (end of) new time
	LD	DE,rsec
	LD	BC,5
	LDDR


;noclock present so set hms to zero

	LD	HL,rhour
	LD	B,3
	JP	filzer



	COMMON	/now/

rdate:	DS	1		;date origin 1
rmonth:	DS	1		;month (LO,origin 1) and year (HI, origin 1981)
rhour:	DS	1
rmin:	DS	1
rsec:	DS	1

	COMMON	/error/

errloc:	DS	1



	END
e & fill in parameters.

rxread:	POP	IY		;Return
	POP	BC		;Len
	POP	DE		;Stn
	POP	HL		;Port
	LD	(block),HL	;Temp storage
	POP	HL		;Ctrl
	POP	AF		;blockno

	PUSH	IY		;Return
	PUSH	HL		;ctrl
	LD	HL,(block)
	PUSH	HL		;Port
	PUSH	DE		;Stn
	PUSH	BC		;Len

	LD	(block),A	;Ready for reading Rx block

	LD	L,A		;Poll first
	LD	A,033H
	CALL	osbyte

	BIT	7,L
	JR	NZ,doread

	XOR	A		;No Rx so return false
	POP	HL
	POP	HL		;Spurious parameters
	POP	HL
	POP	HL
	RET

doread:	LD	HL,block
	LDar
	PUSH	DE
	LD	A,E
	CALL	oswrch

	POP	DE
	POP	BC
	POP	HL
	POP	AF
	RET


;	PROCEDURE ecoini;
; No eco initialisation required, so use the call to initialise
; the printer/vdu state.

ecoini:	XOR	A
	LD	(fx3val),A	; Set to 0 - next print or vdu will force
				;a *FX 3 to set up
	LD	A,2
	JP	oswrch		;Do a VDU 2


;	PROCEDURE Rx_set(VAR blockno:Byte;port:Byte;stn,start,len:Word);

rxset:	LD	HL,07F00H	;Reason code & flag byte
	LD	(block),HL
	POP	BC		;Return address
	POP	DE		;Buffer end	A,011H
	CALL	osword

	LD	HL,(block+9)	;Buffer end
	LD	DE,(block+5)	;Buffer start
	OR	A		;Clear carry
	SBC	HL,DE		;Difference = length of Rx

	EX	DE,HL		;Result to DE
	POP	HL		;Address for length
	LD	(HL),E
	INC	HL
	LD	(HL),D

	LD	DE,(block+3)	;Stn
	POP	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D

	LD	A,(block+2)	;Port
	POP	HL
	LD	(HL),A

	LD	A,(block+1)	;Ctrl code
	AND	07FH
	POP	HL
	LD	(HL),A

	XOR	A
	INC	A		;Return True
	RET





; PROCEDURE Del_Rx(blockno:Byte);
;
; Delete an 
	POP	HL		;Buffer start
	LD	(block+5),HL
	ADD	HL,BC
	LD	(block+9),HL
	POP	HL		;Stn
	LD	(block+3),HL
	POP	AF		;Port
	LD	(block+2),A
	LD	HL,0
	LD	(block+7),HL	;high bytes
	LD	(block+11),HL

	PUSH	BC		;Save return addr
	LD	HL,block
	LD	A,011H		;Parameters
	CALL	osword		;Open Rx

	POP	HL		;Return addr
	EX	(SP),HL
	LD	A,(block)	;Rxcb number
	LD	(HL),A
	RET

; FUNCTION Rx_read(blockno:Byte;VARctrl,port:Byte;VARstn,len:Word):Boolean;
;
; Poll RxCB - if no Rx, return False, else return Tru,cli1
	INC	DE
	DJNZ	cli2		;$)

cli1:	POP	DE		;Get bcak start of text
	LD	A,C		;Work out number of chars in name
	SUB	B
	LD	B,A
	LD	A,8		;A:= unrecognised command
	JR	movstr		;Adjust string


trynxt:	PUSH	DE		;Resave start of string

cmplop:	LD	A,(DE)		;Get char
	CP	'.'		;Abreviated command ?
	JR	Z,gotdot	;Yes => we got the command
	XOR	(HL)		;Compare + case equate
	AND	05FH
	JR	NZ,notcmd	;No => try for next
	BIT	7,(HL)		;End of command in table ?
	JR	NZ,trymat	;Yes => maybe match
	INC	D	HL,rdate	;set NOW to zero to indicate to user
				;that no RTC is installed and date
				;is spurious
	LD	B,5
filzer:				;NB ENTERED HERE from setclk.
noclk2:	LD	(HL),0
	INC	HL
	DJNZ	noclk2


	;Drop through


;PROCEDURE GetClk;
;
; Does nothing since no clock to read

getclk:
	RET



;PROCEDURE SetClk(address_of_new_time:Word);
;returns error=90H if date is invalid.
;As there is no RTC then the date & month/year is stored, but the
;hours/mins/secs are zeroed to indicate that they HL		;Get next chars
	INC	DE
	DJNZ	cmplop

notcmd:	CALL	getcmd		;Move onto command number
	BIT	7,(HL)		;Finished ?
	JR	nxtcmd		;Loop {zf used @ nxtcmd}

trymat:	DEC	B		;End of string => match
	JR	Z,gotcmd
	INC	DE		;Get next charcter
	LD	A,(DE)
	AND	05FH		;Caps it
	CP	'A'		;Non alpha => match
	JR	C,skpsp2
	CP	'Z'+1		;Alpha => no match
	JR	C,notcmd

skpsp2:	LD	A,(DE)		;Get character
	CP	' '		;Skip spaces
	JR	NZ,gotcmd
gotdot:	INC	DE		;Point to next character
	DJNZ	skpsp2		;Dec length & stare not meaningful

setclk:	POP	BC
	POP	DE		;DE=pointer to new date/time
	PUSH	BC

	LD	HL,errloc
	LD	(HL),90H	;set error initially

;now range check

	LD	A,(DE)		;Date 1..31 (not bothering about months yet)
	INC	DE
	OR	A
	RET	Z
	CP	32
	RET	NC

	LD	A,(DE)		;months (lo-nibble) 1..12
	AND	15
	INC	DE		;years don't need checking
	OR	A
	RET	Z
	CP	13
	RET	NC

	LD	A,(DE)		;hours 0..23
	INC	DE
	CP	24
	RET	NC

	LD	A,(DE)		;mins 0..59
	INC	DE
	CP	60
	RET	NC

	LD	A,(DE)		;secs 0..59TITLE Clock substitute for no RTC on 380Z
.Z80

;(c) S.R.Lawrence
;     SJ Research

;modifications:
; 29/6/84 - READCK,WIRTCK external routines provided
;  6/7/84 - <option> flag added - TRUE if RTC is optional (eg 380Z)
; 24/7/84 - 32us wait fudge impl.
; 20/8/84 - Delay-after-write impl.
; 18/9/84 - Interrupts off round RTC operations.

True	EQU	-1
False	EQU	0


NAME	('NORTC')


PUBLIC	getclk,iniclk,setclk	;used by FS



;PROCEDURE iniclk
; Set to 0:00:00 on 0/0/81

iniclk:
	L	ENDIF


PUBLIC	getclk,iniclk,setclk	;used by FS
PUBLIC	readck,writck		;used by MONITOR etc

EXT	intexb


clock	EQU	3CH

;registers in M3000

second	EQU	0
minute	EQU	1
hour	EQU	2
date	EQU	3
month	EQU	4
year	EQU	6

status	EQU	15

;SIO

sio	EQU	30H
sbctrl	EQU	sio+3

dcd	EQU	3


;PROCEDURE iniclk
;NB MUST BE CALLED AFTER ECOINI!!!
;
;ALWAYS reads M3000

sdata:	DB	30O
	DB	4,84H		;*32
	DB	3,0C1H		;enable Rx
	DB	5,0E8H		;DTR
	DB	1,5		;ExtIE SAV
lsdata	EQU	$-sdata

iniclk: the command table and
; returns a reason code - unrecognised commands return 8
;It also removes the command + any leading or trailing spaces
; from the string.
;Commands can be abreviated by means of a '.' & are terminated
; by any non-alpha char

cli:	dstak	<HL>

	PUSH	HL		;Save string addr

	LD	B,(HL)		;Get string length
	LD	A,B		;Check if zero length
	OR	A
	JR	Z,nocmd

cliskp:	INC	HL		;Point to next char
	LD	A,(HL)		;Get it
	CP	' '		;Skip spaces
	JR	NZ,cli0
	DJNZ	cliskp

nocmd:	POP	LD	HL,exbint
	LD	(intexb),HL

	LD	HL,sdata
	LD	BC,sbctrl*256+lsdata
	OTIR

	CALL	rdclk

;drop thru'


;PROCEDURE GetClk;
;
;Returns at COMMON /now/ an FS-formatted date/time block (5 bytes)
;

getclk:	LD	HL,rdate
	LD	DE,now1
	LD	BC,5
	DI
	LDIR
	EI
	RET


;Interrupt Routine
;
;Entered here on a transition of DCD, CTS or SYNC

exbint:	EI
	PUSH	AF
	IN	A,(sbctrl)
	BIT	dcd,A
	JR	NZ,intex1	;not a very interesting INT

	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	rdclk
	POP	HL
	POP	DE	HL		;String address
	LD	(HL),B		;Zero string length {B = 0 if here}
	LD	A,8		;Unrecognised command
	RET


cli0:	PUSH	HL		;Save start of real string
	LD	C,B		;Save len of str
	LD	HL,cmdtab	;Point @ start of command table
	CP	A		;Set zf

nxtcmd:	POP	DE		;Get start of string
	LD	B,C		;Restore str len
	JR	Z,trynxt	;z => more commands left to try

	PUSH	DE		;Save start of string
cli2:	LD	A,(DE)		;FOR i = 1 TO B DO $( ch:= DE%i
	CP	' '		;  IF ch=' ' OR ch=',' DO BREAK
	JR	Z,cli1
	CP	','
	JR	Z
	POP	BC

intex1:	LD	A,20O		;Acknowledge INT
	OUT	(sbctrl),A
	POP	AF
	RETI


;RDCLK
;The algorithm I will use consists of the following:
; read all data
; read seconds again, if different do it all again
;

rdclk:
	LD	D,second
	LD	HL,rsec
	LD	B,3		;read 1st 3 regs directly into RAM

gethms:	CALL	read
	DEC	HL
	INC	D
	DJNZ	gethms

;date: D=date reg.

	DEC	HL		;=rdate
	CALL	read

; month and year are packed as nibbles into a single byte: month - lo

	INC	D		;=month reg
	INC	HL	…S“Ф•аdtUD4Дё%9%1.SETCLKЉЂ4дхx ERROR”  MQ 0Zrzї  FАAцЙ`ґXў5II=KЂ ’ љЭђю4N`xMnИZ ›ш0РЯГЖЂiь<hЂ°ЊњћЇБ   Pµp!а@ `‚ЂKА %а р 	xј^
ў©)'©KА %а Р ЋЉЁ†—  Й)Й(i‰qР°¦ЉЁ†—8  ћ                                                  	;date origin 1
rmonth:	DS	1		;month (LO,origin 1) and year (HI, origin 1981)
rhour:	DS	1
rmin:	DS	1
rsec:	DS	1

	COMMON	/error/

errloc:	DS	1



	END

;The algorithm I will use consists of the following:
; read all data
; read seconds again, if different do it all again
;

rdclk:
	LD	D,second
	LD	HL,rsec
	LD	B,3		;read 1st 3 regs directly into RAM

gethms:	CALL	read
	DEC	HL
	INC	D
	DJNZ	gethms

;date: D=date reg.

	DEC	HL		;=rdate
	CALL	read

; month and year are packed as nibbles into a single byte: month - lo

	INC	D		;=month reg
	INC	HL		;=rmonth
	CALL	read
	LD	B,A		;month in B
	INC	D
	CALL	read		;year origin 1900 in A
	SU	ENDIF


PUBLIC	getclk,iniclk,setclk	;used by FS
PUBLIC	readck,writck		;used by MONITOR etc



clock	EQU	3CH

;registers in M3000

second	EQU	0
minute	EQU	1
hour	EQU	2
date	EQU	3
month	EQU	4
year	EQU	6

status	EQU	15




;PROCEDURE iniclk
;
;ALWAYS reads M3000

sdata:	DB	30O
	DB	4,84H		;*32
	DB	3,0C1H		;enable Rx
	DB	5,0E8H		;DTR
	DB	1,5		;ExtIE SAV
lsdata	EQU	$-sdata

iniclk:	LD	HL,exbint
	LD	(intexb),HL

	LD	HL,sdata
	LD	BC,sbctrl*256+lsdata
	OTIR

inicl2:	CALL	rdTITLE M3000 routines for FS 3/10/84 : RTC.MAC
.Z80

;(c) S.R.Lawrence
;     SJ Research

;modifications:
; 29/6/84 - READCK,WIRTCK external routines provided
;  6/7/84 - <option> flag added - TRUE if RTC is optional (eg 380Z)
; 24/7/84 - 32us wait fudge impl.
; 20/8/84 - Delay-after-write impl.
; 18/9/84 - Interrupts off round RTC operations.
; 3/10/84 - Interrupt driven reading of clock


True	EQU	-1
False	EQU	0


NAME	('RTC')

	IF1
.PRINTX	Clock required to be fitted version (HDFS)
clk

;drop thru'


;PROCEDURE GetClk;
;
;Returns at COMMON /now/ an FS-formatted date/time block (5 bytes)
;

getclk:	LD	HL,rdate
	LD	DE,now1
	LD	BC,5
	DI
	LDIR
	EI
	RET


;Interrupt Routine
;
;Entered here on a transition of DCD, CTS or SYNC

intexb:	EI
	PUSH	AF
	IN	A,(sbctrl)
	BIT	dcd,A
	JR	Z,intex1	;not a very interesting INT

	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	rdclk
	POP	HL
	POP	DE
	POP	BC

intex1:	LD	A,20O		;Acknowledge INT
	OUT	(sbctrl),A
	POP	AF
	RETI


;RDCLKlist:	CALL	doseri		;do serial, then fall through to dopara:


dopara:
	LD	A,4		;List status
	CALL	to6502

	CALL	wait65		;ready-to-go byte
	PUSH	AF

	CALL	wait65		;Hardware status (ignored here)

	POP	AF
	OR	A
	RET	Z		;Busy, so do nothing

	LD	HL,(space)	;Lo two bytes of pri_spa
	LD	A,(space+2)
	SRL	A
	RR	H
	RRA			;Building page in H, two spare bits in
	RR	H		;lo of A

	LD	C,0
	RL	C
	RLA
	RL	C	
	LD	A,H
	LD	H,C
	LD	C,A		; HL=offset, C=page


	LD	DE,(ptr)	;Lo two bytes of pri_pt



doseri:
	LD	A,10		;Serial status
	CALL	to6502

	CALL	wait65		;ready-to-go byte
	PUSH	AF

	CALL	wait65		;Hardware status (ignored here)

	POP	AF
	OR	A
	JP	Z,exitNZ	;Busy, so do nothing

	LD	HL,(sersp)	;Lo two bytes of pri_spa
	LD	A,(sersp+2)
	SRL	A
	RR	H
	RRA			;Building page in H, two spare bits in
	RR	H		;lo of A

	LD	C,0
	RL	C
	RLA
	RL	C	
	LD	A,H
	LD	H,C
	LD	C,A		; HL=offset, C=page


	LD	DE,(serptr)	;Lo two bytes of pri_ptr
	LD	A,(serptr+2)
	SRL	A
	RR	D
	RRA			;Bur
	LD	A,(ptr+2)
	SRL	A
	RR	D
	RRA			;Building page in D, two spare bits in
	RR	D		;lo of A

	LD	B,0
	RL	B
	RLA
	RL	B
	LD	A,D
	LD	D,B
	LD	B,A		; DE=offset, B=page (also in A)

; Compare pointers

	CP	C		;Compare pages
	JR	Z,samepa
	LD	HL,0400H	;Print to end of page
samepa:	OR	A
	SBC	HL,DE		;HL now holds length
	LD	A,L
	OR	H
	RET	Z		; Zero bytes !

	LD	A,5		;Print data from cache op-code
	CALL	to6502
	LD	A,B		;Page no.
	CALL	to6502
	LD	A,E		;Offset
	CALL	to6502
	LD	A,D
	CALL	tilding page in D, two spare bits in
	RR	D		;lo of A

	LD	B,0
	RL	B
	RLA
	RL	B
	LD	A,D
	LD	D,B
	LD	B,A		; DE=offset, B=page (also in A)

; Compare pointers

	CP	C		;Compare pages
	JR	Z,samep1
	LD	HL,0400H	;Print to end of page
samep1:	OR	A
	SBC	HL,DE		;HL now holds length
	RET	Z		; Zero bytes !

	LD	A,11		;Print data from cache op-code
	CALL	to6502
	LD	A,B		;Page no.
	CALL	to6502
	LD	A,E		;Offset
	CALL	to6502
	LD	A,D
	CALL	to6502
	LD	A,L		;Length
	CALL	to6502
	LD	A,H
	CALL	to65o6502
	LD	A,L		;Length
	CALL	to6502
	LD	A,H
	CALL	to6502

; Now update pointer

	EX	DE,HL		;Length now in DE
	LD	HL,(ptr)
	OR	A		;Clear carry
	ADC	HL,DE
	LD	(ptr),HL
;	RET	NC		;No carry into hi byte so not off end of cache
;	LD	A,(ptr+2)
;	INC	A
;
; 64K BUFFER<=> auto wrap round
;
;	CP	3		;Should only be 2 bits in here
;	JR	Z,nowrap
;	LD	A,2		;Start at 64K boundary
;nowrap:	LD	(ptr+2),A
	RET


;
; Same as dopara, for serial port.
; In addition, Z flag set on exit if job finished.st for tx success
	JP	M,txok
	DJNZ	dotx

txok:	POP	HL		;Address of result byte
	LD	(HL),A		;A has been massaged to fit spec

	RET



	DSEG

fx3val:	DS	1		;Current *fx 3 value

block:	DS	13		;Workspace for eco osword calls

block2:	DS	256		;Copy of above in case corrupted

	END


H
	CALL	osbyte

	LD	A,L		;Result of poll
	RLA			;Test for tx complete
	JR	C,polltx

	POP	BC		;Retry count
	XOR	080H		;Te
	POP	DE
	POP	BC
	POP	AF
	RET

serot:	
	LD	HL,(sersp)	;Lo two bytes of pri_spa
	LD	A,(sersp+2)
	SRL	A
	RR	H
	RRA			;Building page in H, two spare bits in
	RR	H		;lo of A

	LD	C,0
	RL	C
	RLA
	RL	C	
	LD	A,H
	LD	H,C
	LD	C,A		; HL=offset, C=page

	LD	A,3		;Cache write op-code
	CALL	to6502
	LD	A,C
	CALL	to6502
	LD	A,L		;Offset
	CALL	to6502
	LD	A,H
	CALL	to6502
	CALL	wait65

	POP	HL		;Return addr
	POP	AF		;The byte
	PUSH	HL

	OUT	(cacheP),A

; Now update pointer

	LD	HL,ser	A,011H
	CALL	osword

	LD	HL,(block+9)	;Buffer end
	LD	DE,(block+5)	;Buffer start
	OR	A		;Clear carry
	SBC	HL,DE		;Difference = length of Rx

	EX	DE,HL		;Result to DE
	POP	HL		;Address for length
	LD	(HL),E
	INC	HL
	LD	(HL),D

	LD	DE,(block+3)	;Stn
	POP	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D

	LD	A,(block+2)	;Port
	POP	HL
	LD	(HL),A

	LD	A,(block+1)	;Ctrl code
	AND	07FH
	POP	HL
	LD	(HL),A

	XOR	A
	INC	A		;Return True
	RET





; PROCEDURE Del_Rx(blockno:Byte);
;
; Delete an sp
	INC	(HL)
	RET	NZ		;No carry into hi byte so not off end of cache
	INC	HL
	INC	(HL)
;	RET	NZ		;Buffer is only 64K long, so wrap-round is
	RET			;automatic






;
; PROCEDURE dolist;
;
; Initiate a printer transfer if required. Globals pri_spa and pri_ptr
; point to the first free slot and first byte to print respectively :
;
; bits	0-9	offset in page
; bits	10-17	page no. in cache (minimum 64 to clear disc area)
;
; Two near-identical versions for parallel and serial printers

dound code
;	INC	HL
;	INC	(HL)
;	LD	A,(HL)
;	CP	3		;Should only be 1 bits in here
;	RET	NZ
;	LD	(HL),2		;Start at 64K boundary
	RET













;GETMEM
;
;This routine returns the first unavailible memory location on the
; machine in DE & returns to HL

getmem:	LD	DE,0
	JP	(HL)



;PCHAR
;
;Print character in E.  All registers preserved
;Output is to serial printer, via cache

pchar:	PUSH	AF
	LD	A,E
	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	AF		;PARAMETER
	CALL	serot
	POP	HLdolist, chario, systsw, chksw, online
EXT	to6502,emptyC


true	EQU	-1
false	EQU	0



	IF1
.PRINTX Big FS version !!
	ENDIF


status	EQU	034H
system	EQU	034H
cacheP	EQU	035H		;Port nos.
Jlatch	EQU	036H


; PROCEDURE On_line;
; Illuminate the on-line lamp!

online:	LD	A,087H
	OUT	(system),A
	RET


;
; FSexit - exit to monitor. Must flush serial buffer 1st

fsexit:	LD	A,08FH		;Turn 'Online' OFF
	OUT	(system),A
	LD	HL,0		;Timeout counter
exit1:	PUSH	HL
	CALL	doseri		;flush serRxCB

delrx:	POP	HL
	EX	(SP),HL		;Return address back on stack, H:=blockno
	LD	L,H		;Argument in 'X' for osbyte
	LD	A,034H		;Delete rx osbyte no.
	JP	osbyte		;Call & return


; PROCEDURE Eco_tx(ctrl,port:Byte;stn,start,len:Word;VAR result:Byte);
;
; Transmit a packet. <ctrl> is the 7 bit ctrl code only - needs to be ORed &80
; Result >&7F means OK.

Ecotx:	POP	IY		;Return addr
	POP	BC		;Result addr
	POP	DE		;Len
	POP	HL		;Start
	LD	(block+4),HL
	ADD	HL,DE
	LD	(block+8),HL
	POP	HL		;Stnial port
	POP	HL
	JR	Z,exit2		;Serial finished.
	DEC	HL
	LD	A,L
	OR	H
	JR	NZ,exit1	;wait till timeout.

;NB this code must NOT be underneath the ROM ie not in the area 0..3FFFH

exit2:	LD	A,0FH		;ROM on
	OUT	(system),A

	JP	3		;and restart monitor




;
; PROCEDURE Listot(ch:Byte);

; Send the given byte into the cache for printing
; using global pri_spa to give the free space position

listot:	
	LD	HL,(space)	;Lo two bytes of pri_spa
	LD	A,(space+2)
	SRL	A
	RR	H
	RRA			;Buildin
	LD	(block+2),HL
	POP	AF		;Port
	LD	(block+1),A
	POP	AF		;Ctrl code
	OR	080H
	LD	(block),A

	LD	HL,0		;Hi word of 4-byte addresses
	LD	(block+6),HL
	LD	(block+10),HL

	PUSH	IY		;Return addr
	PUSH	BC		;Result

	LD	B,20		;Retry count
	
dotx:	PUSH	BC
	LD	HL,block
	LD	DE,block2
	LD	BC,13
	LDIR
	LD	HL,block2
	LD	A,010H
	CALL	osword		;Do the Tx

polltx:	LD	A,032H
	CALL	osbyte

	LD	A,L		;Result of poll
	RLA			;Test for tx complete
	JR	C,polltx

	POP	BC		;Retry count
	XOR	080H		;Teg page in H, two spare bits in
	RR	H		;lo of A

	LD	C,0
	RL	C
	RLA
	RL	C	
	LD	A,H
	LD	H,C
	LD	C,A		; HL=offset, C=page

	LD	A,3		;Cache write op-code
	CALL	to6502
	LD	A,C
	CALL	to6502
	LD	A,L		;Offset
	CALL	to6502
	LD	A,H
	CALL	to6502
	CALL	wait65

	POP	HL		;Return addr
	POP	AF		;The byte
	PUSH	HL

	OUT	(cacheP),A

; Now update pointer

	LD	HL,space
	INC	(HL)
	RET	NZ		;No carry into hi byte so not off end of cache
	INC	HL
	INC	(HL)
;	RET	NZ		;Now a 64K buffer, so no wrap-roГmУ‡S™a°ѓсєs :Ь'1Йєбdѓ@                ?Яа2X  " KА %а j*’’z”ј ^#)"ўЎ&KА %аЂа 	p ё\.— ЛЃeААІааYup,fd’$(&&Ж  1"j*j’Мu8 ¦&'ЎЖOЃj
B*Дv!ў¦Ё*,З` ЄJ"b,tX" ¦&'ЎЗl І"Jљ’$t|"$©Ў«©GwБb2b\g #)ў¬$ЄG@ rJrJ"љ\wґ$§$¦'«ЗPЂ*‚’b4gЁ&ў©©ЗAЂ2І*’
"”d°«"©$$ЗBЂ2І*’b*tdё«"©&'З@ 2І*’jљ<а  ћа2X  " KА %а j*’’z”ј ^#)"ўЎ&KА %аЂа 	p ё\.— ЛЃeААІааYup,fd’$(&&Ж  1le blocks in cache.

dsflag:	DEFS	1		;Double sided bit map

zeros:	DEFS	1024		;Contains 0s !!

;	******* MAPMAN AREAS ****;

alloc:	POP	HL		;Return address
	EX	(SP),HL		;Blk address

	LD	A,(HL)		;Get drive
	INC	HL
	LD	B,(HL)		; & block numbermess	<frblk0,HL,alblk1,AF,crlf>

	CALL	getblk
	OR	(HL)
	LD	(HL),A
	SUB	A
	RET



;PROCEDURE alloc (blk: block_descrip)
	EX	(SP),HL		;Blk address

	LD	A,(HL)		;Get drive
	INC	HL
	LD	B,(HL)		; & block number
	INC	HL
	LD	H,(HL)
	LD	L,B

	t MANAGEMENT CODE STARTS HERE *************
;
;


;PROCEDURE dalloc (blk: block_descrip);

dalloc:	POP	HL		;Return addressrr

	PUSH	HL		;Check valid block number
	DEC	HL
	LD	A,(HL)
	DEC	HL
	LD	L,(HL)
	LD	H,A
	CP	A
	SBC	HL,DE
	JP	C,ranerr
p
	DEC	HL
	LD	C,(HL)

	IF	c.on		;** Range check block **

	PUSH	AF		;Check map exists
	LD	A,B
	AND	C
	INC	A
	JP	Z,mape in A
	INC	B
	LD	C,B
	SUB	A
	SCF
getbl1:	RLA
	DJNZ	getbl1

	POP	DE
	PUSH	BC
	EX	DE,HL
	LD	B,(HL)		;BC:= address of maDD	HL,BC
	EX	(SP),HL

	LD	A,L		;HL/8, A=Remainder
	AND	7
	SRL	H
	RR	L
	SRL	H
	RR	L
	SRL	H
	RR	L

	LD	B,A		;Set bit ATITLE Various FS m/c-dependant routines 11/1/84: FSMDEP.MAC
.Z80
NAME	('MDepbig')

; modifications:
; 16/2/84 - RM char input allows ctrl-F
; 15/3/84 MEGA version
; 1/6/84  modified for new prototype environment
; 4/7/84  Added relay control, frontpanel switch, conio to serial printer
; 8/7/84  Power off switch problem fixed.
; 17/7/84 Power switch spec changed.
; 5/9/84  IRQ disabled during boot to fix Eco problem (temporary)
; 3/10/84 ^^^ removed again

PUBLIC	fsexit, listot, getmem, pchar,  HL	Address of byte

getblk:	PUSH	HL

	CP	maxdrv
	JP	NC,maperr

	ADD	A,A
	ADD	A,A
	LD	C,A
	LD	B,0
	LD	HL,mapptr+3
	A
;
;On exit:
; A	Byte with bit set
; B	1 - 8 => Bit number
; DE	Points to low byte of address in MAPPTR (length @(DE-2))
;


;GETBLK
;Converts Map number & Block Number into address and bit number
;
;On entry:
; A	Map number
; HL	Block number
	INC	HL
	LD	H,(HL)
	LD	L,B

;	tmess	<alblk0,HL,alblk1,AF,crlf>

	CALL	getblk
	CPL
	AND	(HL)
	LD	(HL),A
	SUB	A
	RET
IY+3)	;Drive
	RLCA
	RLCA
	AND	03H		;Now back in right place
	LD	E,A

	PUSH	HL
	PUSH	DE
	CALL	rwdisc		;Get first
	POP	DE
	POP	HL
	INC	C		;Error => return now
	DEC	C
	JR	Z,nxtsec

blkdud:	DEC	D		;Test for read operation
	RET	Z		;Write, so no need to zap blockno.
	LD	(IY+2),0FFH
	LD	(IY+3),0FFH	;Mark as empty since contains junk
	RET

nxtsec:	LD	A,(rwpage)
	ADD	A,2
	LD	(rwpage),A
	INC	HL		;Next sector
	CALL	rwdisc
	INC	C
	DEC	C
	JR	NZ,blkdud

	IF	t.on
	mcond	blkm
	CALL	pcrlf
	PЂ Y·\›PЂ-ЕЪCЇаОТќ{` !њ DUЬ|XaуьC]Aoы…ЖН№ b5II=KЂ ЂўБqЅGPj"*Є?  [Љ/«Єеr„jX6чЃ?MА'йН§@И НЁ nm: ЧPmO` mхfФ E‚сЗ ц+UКћАE‹–8Z,иШ W°giїѓ@ЂИл  Ўв*оЇXaи†єѓ0Ю/уГX±6®VЁ„ WрaW°a P:А (C8Љ»ѓ+ЖVz!® МЧ‹эўб`†Заx<F^­Љо·и‡  …Ђ¬G%їKАи‡  ?C/Ур	z ?OА5а 4t9YґXъ~ ­Д P°›K/УЁ	ъt­Щ#¬ »І8   їOАёл  їNаШЛ  ЌЩ/С°юэrё@8 nн!FXъn?OА70ьО)~џЂ`p;_rµY¶ўбE °«!ъ6?ЯЈ`э’:А ,`Л Ђ€Щ¶9^Ј®  ·^,Ъ„ хxІZЄр€ц ќҐ »,TЛґ¬@!\єБ<­ЗА@!А`*a@,фю(…QУPS dD•45$H%M]JINIDSKЃ‘SРаTДДф8	1.INILOWЃPТQ`d4TХEYIJVERLENЃ•‘T“TСаU5$Дh DEBUGЉ ЂTU%$х(  FREEBL”WНcA‚4@†  hp$B* 2@ ™(@R2њМ¦‘ЊР #M†QLКr;NB±”д     xФD !€`РPђшН  ¬:x ¦а: ‰
з#IРК 1ж3XЂHR2L‚°Юc5€‚	ђИr2њОb Ђ¤D*ЗўA @$Њ'C	°@d4њМb)Идo9„“q¤и 6N ЂZ 6MЖsЎ @$‚€fГ)„д G“Ў”ж 3ЌжС ђ‚l6МfЎ”@b6Мf± ђ@f9Нўi„а ЋFS(ЂДl7Нb!¬@C0НQМТz2ѓAB@ьА "6 ;Vђ ГЁА”CЃЃB8	 џоХЂ‡  p ю ?Э«  &?D8  шю(аGйР эа ( L~‚X"A ђH s+ЖX р2А@*сањ ьfФ  ЌЮ  ГдъH®ЛdћFVф2± З¶XњebЃЏqс,PЖV к:а q@yвхj±B5ё›V@Ь,Ъt бfУ  Ќu fЭЂAЦfХр7€„ (`!њE`Б‡Зс‚fј_г«O[І0j*’’z—  1ШЎт НјАЊK…Ж~‘„fcCФuў"Ў*Јр ё Bсz±Z®W«”#tЂґHВН§@Ћ Н¦ ЇmмfФ E‚сfХаU±Э.ЙpёПВ20ЊМhfХаQzо—d№_А&•ҐCЎЙа` ‡‚‚\gЧ0–<e‡YcЖXu–<e‡HаBB\n?Z,WYVNzћ#ЖUҐrЉПВіqќ~н)6®+…вл°H,ђЌ®fУ Vo‚€F ЂЪa8ЗSi€Кr‚„Ѓ”
Нµ ¬;X
¦a€Шo1љДг©ґДe9ABGЖЭr±OВ7)xFVu№Yµx_ЃOВЂ |~^¬W+¬FV—…daY9Ц	`±[®ыґ„л`ј\ аC’ѓ7OАёЂ	aТ°b|p„MСlцІaQ g	ЬFwЉШw”Цб9€ОN)xFVuЇЛм:®Э·KА
э–ЕgЕЁ z2fЯа‹dCѓЃ[/Q•ѕ  Q е ў|еfЫ !ФЉ¤¤ћҐА в Є°ЂЂH  HF€  @!pТш@.„В†>@ВТxЅъ*Ї "¦#їOЖ
Аоэ7џ¦cЕкНё /лК® ІGА—  pІ@  Фuў"Ў*Јр ё <сz±Z®W+Ф#c µPвН©А!, Нє`.m: pґX/+­O 0r2’**g  њДg&Xй–eЋ™a¶Xй–	€pH($Щr¶X'YДVrњЪ­—[Њ2Ъ­ NPЋ®v”њ-*РСl±Z¬‰€ЦЌџпQФ€Љ„ЄЏА вЃЕкЕj№\¬PЌЎ fЭР6ќ mP6 Ѓ8Yґи›PЂ-ЕЪ°hћЬАq@Ћ—…ВГ»$#\@™µ,	†  ADѓ)„а 7™Ќ†уё4$` шл “АА7и‡  ЂРЛфь[€ мVm,`ЃYТр  rІ@Д+6А0B–Jјeў©)'©p Ќ›s@З Pіэ›K-ЌЦхAЁ€ЁJЁь n(ј^¬V«•Є« ЪШэ7 џ¦`6ќ k 6л8Yґи #]@·”u
	LD	C,(HL)
	EX	DE,HL
	ADD	HL,BC
	POP	BC
	PUSH	BC
	POP	IX
	CP	A
	SBC	HL,BC
	EX	DE,HL
	POP	BC
	POP	AF
	POP	HL
	LD	C,8
	JP	fblk3

;Main find loop
;
;On entry:
; BC	8
; DE	number of bytes to search before giving up
; HL	start block number
; IX	pointer to current byte to search

fblk4:	LD	A,(IX+0)
	OR	A
	JR	NZ,fblk6
	ADD	HL,BC
	JP	fblk5
fblk6:	LD	B,C
fblk3:	RRA
	JR	C,fblk2
	INC	HL
	DJNZ	fblk3
fblk5:	INC	IX
	DEC	DE
	LD	A,E
	OR	D
	JP	NZ,fblk4

;NOT found at all so retry stasided bit map


;	******* MAPMAN AREAS *********

lstadr:	DEFS	2		;Address of last block found

mapptr:	DEFS	maxdrv*4	;( length (2) + mapptr (2) ) * maxdrv

myheap:	DEFS	heapln


	END
 
	COMMON	/freebl/

dsksiz:	DEFS	maxdrv * 2


	DSEG

cacmap:	DEFS	noblks*4	;Cache sector map

page:	DEFS	1		;Current cache page

rwpage:	DEFS	1		;Parameter to RWDISC

csize:	DEFS	1		;Number of usable blocks in cache.

dsflag:	DEFS	1		;Double rting at block zero

	POP	HL
	LD	(HL),A
	INC	HL
	LD	(HL),A
	DEC	HL
	DEC	HL
	JP	fstart



;Found it

fblk2:	EX	DE,HL
	POP	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	POP	HL
	PUSH	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	CP	A
	LD	E,A
	JP	fblk12

;Find how many free & allocate them

fblk7:	INC	IX
	LD	E,(IX+0)
	LD	B,C
fblk9:	CP	A
	RR	E
	JR	NC,fblk11
fblk12:	DEC	HL
	LD	A,H
	OR	L
	JR	Z,fblk11
	DJNZ	fblk9
	RR	E
	LD	(IX+0),E
	JP	fblk7

;Wind up

fblk11:	RR	E		;Allocate out ot head of chain)
;
;On exit:
; C	Error code (0 = OK)
;	(errloc) also updated
; (IY)	Needs writing flag cleared always. Blockno zapped if read error

rwblk:	LD	(IY+1),0FFH	;Clear needs writing flag

	PUSH	IY
	POP	HL		;Calculate page no. from table offset
	LD	BC,cacmap	;Start of table
	OR	A		;Clear carry
	SBC	HL,BC
	LD	A,L		;the answer

	LD	(rwpage),A

	LD	L,(IY+2)	;blockno.
	LD	A,(IY+3)	; Hi byte also holds drive
	AND	3FH		;not any more
	LD	H,A
	ADD	HL,HL		;Block * 2 = Sector

	LD	A,(f last byte
	DJNZ	fblk11
	LD	(IX+0),E
	EX	DE,HL

	POP	HL		;Fill in blocks found
	LD	(HL),E
	INC	HL
	LD	(HL),D

	POP	IX
	RET
;
; ****** END OF MAPMAN ******
;




	COMMON	/debug/

mesflg:	DEFS	1


	COMMON	/error/

errloc:	DEFS	1

	COMMON	/freebl/

dsksiz:	DEFS	maxdrv * 2


	DSEG

cacmap:	DEFS	noblks*4	;Cache sector map

page:	DEFS	1		;Current cache page

rwpage:	DEFS	1		;Parameter to RWDISC

csize:	DEFS	1		;Number of usable blocks in cache.

dsflag:	DEFS	1		;Double lised - hence in CSEG



	ENDIF	;of IF nascom ELSE on whole RWDISC code






;
;  ****** BIT MAP MANAGEMENT CODE STARTS HERE *************
;
;


;PROCEDURE dalloc (blk: block_descrip);

dalloc:	POP	HL		;Return address
	EX	(SP),HL		;Blk address

	LD	A,(HL)		;Get drive
	INC	HL
	LD	B,(HL)		; & block number
	INC	HL
	LD	H,(HL)
	LD	L,B

	tmess	<frblk0,HL,alblk1,AF,crlf>

	CALL	getblk
	OR	(HL)
	LD	(HL),A
	SUB	A
	RET



;PROCEDURE alloc (blk: block_descrip);

alloc:	POP	HL	eck valid block number
	DEC	HL
	LD	A,(HL)
	DEC	HL
	LD	L,(HL)
	LD	H,A
	CP	A
	SBC	HL,DE
	JP	C,ranerr

	POP	HL
	POP	AF

	ENDIF			;** End of range check **

	EX	DE,HL
	ADD	HL,BC
	POP	BC
	LD	B,C
	RET


	IF	c.on

;Bad map number / map not initialized

maperr:	error	'Bad map number'

;Block number out of range

ranerr:	error	'Duf block number'

	ENDIF




;PROCEDURE fblk (VAR block: block_descrip; VAR no_block: WORD);
;
;Attempt to find up to no_block blocks starting from blo	;Return address
	EX	(SP),HL		;Blk address

	LD	A,(HL)		;Get drive
	INC	HL
	LD	B,(HL)		; & block number
	INC	HL
	LD	H,(HL)
	LD	L,B

;	tmess	<alblk0,HL,alblk1,AF,crlf>

	CALL	getblk
	CPL
	AND	(HL)
	LD	(HL),A
	SUB	A
	RET



;GETBLK
;Converts Map number & Block Number into address and bit number
;
;On entry:
; A	Map number
; HL	Block number
;
;On exit:
; A	Byte with bit set
; B	1 - 8 => Bit number
; DE	Points to low byte of address in MAPPTR (length @(DE-2))
; HL	Address of byteck_descrip

fblk:	POP	HL		;Return address
	POP	BC		;no_block
	EX	(SP),HL		;block_descrip
	PUSH	IX
	PUSH	BC

fstart:	LD	A,(HL)		;Drive
	INC	HL
	PUSH	HL		;Save address of block number
	LD	E,(HL)		;get block number
	INC	HL
	LD	D,(HL)

	EX	DE,HL
	PUSH	HL
	CALL	getblk
	LD	C,8
	CP	A		;Clear carry for RRA
	DEC	B
	LD	A,(HL)
	JR	Z,fblk1
fblk0:	RRA
	DEC	C
	DJNZ	fblk0
fblk1:	LD	B,C
	PUSH	AF
	PUSH	BC
	PUSH	HL
	EX	DE,HL
	INC	HL
	LD	D,(HL)
	DEC	HL
	LD	E,(HL)
	DEC	HL
	LD	B,(HL)
	DEC	HL

getblk:	PUSH	HL

	CP	maxdrv
	JP	NC,maperr

	ADD	A,A
	ADD	A,A
	LD	C,A
	LD	B,0
	LD	HL,mapptr+3
	ADD	HL,BC
	EX	(SP),HL

	LD	A,L		;HL/8, A=Remainder
	AND	7
	SRL	H
	RR	L
	SRL	H
	RR	L
	SRL	H
	RR	L

	LD	B,A		;Set bit A in A
	INC	B
	LD	C,B
	SUB	A
	SCF
getbl1:	RLA
	DJNZ	getbl1

	POP	DE
	PUSH	BC
	EX	DE,HL
	LD	B,(HL)		;BC:= address of map
	DEC	HL
	LD	C,(HL)

	IF	c.on		;** Range check block **

	PUSH	AF		;Check map exists
	LD	A,B
	AND	C
	INC	A
	JP	Z,maperr

	PUSH	HL		;Chk to us
wi1:	IN	A,(winst)
	AND	3
	CP	1
	JR	NZ,wi1
	POP	AF
	RET


	ELSE		;NOT nascom

;RWDISC
;Read/Write sector to/from disk
;
;On entry:
;    (rwpage)	PAGE number to write to/get from (ie. 2 low bits are RAM addr)
;	 D	Read flag (FF-read,0-write)
;	 E	Disk number
;	 HL	sector no.
;
;On exit:
; C	Error code (0 = OK)
;	(errloc) also updated


rwdisc:
	PUSH	DE		;Save disk & read flag

;Convert sector number HL into track D & sector (secno)

	IF	large

;Divide by eight

	LD	A,mess	dtsmsg
	POP	HL	
	CALL	dhxout
	LD	HL,(trkno)
	CALL	dhxout
	mess	atmsg
	LD	A,(rwpage)
	CALL	cahex
l4:	POP	AF
	ENDIF


;On entry to here:
; A	read flag

	PUSH	AF

	LD	A,(rwpage)
	OUT	(pagon),A		;Turn on paged RAM

	AND	3			;Low bits = offset in block
	OR	HIGH secbuf		;Address of paging window
	LD	(rwaddr+1),A		;Address to read/write
					;(low byte =0 always)
	POP	AF

	PUSH	IX			;Must preserve IX (for Propas)
	LD	IX,emtblk
	OR	A
	DI				;Disc routines speed sensitive
	JR	Z,wriL
	AND	7		;Remainder MOD 8
	LD	(secno),A
	ADD	HL,HL		;*2
	ADD	HL,HL		;*4
	ADD	HL,HL		;*8
	ADD	HL,HL		;*16
	ADD	HL,HL		;*32
	LD	D,H		; div 8 <=> *32 DIV 256

	

	ELSE

;Divide by five - Leaves result in A & remainder in L

	XOR	A

	LD	DE,-500H
tscon1:	ADD	HL,DE
	JR	C,tscon0
	SBC	HL,DE
tscon0:	RLA
	SRA	D
	RR	E
	JP	NC,tscon1

	LD	D,A		;Swap regs - so correct for output
	LD	A,L
	LD	(secno),A

	ENDIF

; Now have D=trk, (secno)=sector, E undef.

	POP	HL		;drive now in L (0..3), te
	EMT	wrsec
	JR	finish

write:	EMT	rdsec

;
; On entry, A=error code (=0 for OK)

finish:
	EI
	POP	IX
	OUT	(pagoff),A	;Turn off paged RAM (value immaterial)
	JR	Z,timrt0	;No error
	LD	HL,errloc
	LD	(HL),199

	IF	t.on
	PUSH	AF
	mess	errmsg		;'Fatal error' message
	POP	AF
	PUSH	AF
	CALL	cahex
	CALL	pcrlf
	POP	AF
	ENDIF
timrt0:
	LD	C,A

	RET			;C=error number


emtblk:				;Paramater block for disc EMTs
discno:	DB	0
trkno:	DB	0
secno:	DB	0
rwaddr:	DW	0		;Low byte not initiaH=read flag


;Convert drive number into drive bits

	SUB	A
	LD	B,L
	INC	B		;As drive numbers start at 0
	SCF
cdrnol:	RLA
	DJNZ	cdrnol
	LD	B,A		;has a single bit set in it.


	LD	A,(dsflag)	;Double sided ?
	AND	B
	LD	A,L		;Drive no.
	JR	Z,stadr2
	SRL	D		;Modify track number (/2)
	JR	NC,stadr2
	ADD	A,2		;Other side
stadr2:	LD	(discno),A	;Save drive no. in param block
	LD	L,A		;And in L for trace msg
	LD	A,D
	LD	(trkno),A

	LD	A,H		;Read flag

	IF	t.on
trace:	mcond	l4
	PUSH	HL
	IY+3)	;Drive
	RLCA
	RLCA
	AND	03H		;Now back in right place
	LD	E,A

	PUSH	HL
	PUSH	DE
	CALL	rwdisc		;Get first
	POP	DE
	POP	HL
	INC	C		;Error => return now
	DEC	C
	JR	Z,nxtsec

blkdud:	DEC	D		;Test for read operation
	RET	Z		;Write, so no need to zap blockno.
	LD	(IY+2),0FFH
	LD	(IY+3),0FFH	;Mark as empty since contains junk
	RET

nxtsec:	LD	A,(rwpage)
	ADD	A,2
	LD	(rwpage),A
	INC	HL		;Next sector
	CALL	rwdisc
	INC	C
	DEC	C
	JR	NZ,blkdud

	IF	t.on
	mcond	blkm
	CALL	pcrlf
	P56: C=port no.
	IN	A,(C)
	OR	A		;Error code
	JR	Z,noerr1
	LD	C,A		;Return error
	LD	HL,errloc
	LD	(HL),199
	RET
	
noerr1:	LD	A,(rwpage)
	LD	H,A		;Destination address in paged RAM
	LD	L,B		;L:=0 (B already contains 0)
	CALL	waitin
	DI			;Stack not working when page open
	LD	A,pawrit
	OUT	(paport),A
	INIR
	INIR
	LD	A,panorm	;Close page again
	OUT	(paport),A
	EI
	LD	C,B		;C=0 ie no error
	RET

dowrit:	LD	BC,windat	;B=byte count=256, C=portno for OTIR
	LD	A,(rwpage)	;Dest. address in paUSH	AF		;To allow for the compulsory POP following
blkm:	POP	AF		;Jumped to from mcond.
	ENDIF

	RET




;RWDISC
;Read/Write sector to/from disk
;
;On entry:
;    (rwpage)	Page number to write to/get from
;	 D	Read flag (FF-read,0-write)
;	 E	Disk number
;	 HL	sector no.
;
;On exit:
; C	Error code (0 = OK)
;	(errloc) also updated


	IF nascom

rwdisc:	
	IF	t.on
	LD	A,(rwpage)
	tmess	<dtsmsg,HL,atmsg,AF>
	ENDIF

	LD	C,D		;Save r/w flag
	LD	A,E		;Test for drive 1
	OR	A
	JR	Z,ged RAM
	LD	H,A
	LD	L,B		; L:=0 (B has 0 already)
	CALL	waitot

	LD	A,paread	;Value to be sent to (paport)
	CALL	CtoWIN		;Code in Safe RAM (DI,OTIR,OTIR,EI,RET)

	CALL	waitin
	IN	C,(C)		;return code
	RET	Z		;Done if OK
	LD	HL,errloc
	LD	(HL),199
	RET



wput:	CALL	waitot		;This rtn sends a byte to win, with h/shake
	OUT	(windat),A
	RET

waitot:	PUSH	AF		;Wait till win is ready for us to output
wo1:	IN	A,(winst)
	AND	3
	JR	NZ,wo1
	POP	AF
	RET

waitin:	PUSH	AF		;Wait for win to taldrive0
	LD	DE,07878H	;Drive 1
	JR	drive1
drive0:	LD	DE,05050H	;Offset to clear CP/M area (drive 0)
drive1:	ADD	HL,DE
;
;	HL=sector no.
;
	LD	A,C		;=FF for read,0 for write
	CPL
	AND	1		;The difference between read & write op-codes
	OR	032H		;Read op-code
	CALL	wput		;put byte to win
	XOR	A		;a:=0
	CALL	wput
	LD	A,L		;Sector no.
	CALL	wput
	LD	A,H
	CALL	wput
	INC	C		;Store of r/w flag : now =0 for Read
	JR	NZ,dowrit

	CALL	waitin		;Wait for input indicator
	LD	BC,windat	;B=byte count=2
	LD	A,(HL)			;Drive
	RRCA
	RRCA				;Put in top 2 bits
	INC	HL
	LD	E,(HL)			;Lo(block)
	INC	HL
	OR	(HL)			;Hi byte add to drive bits
	LD	D,A
	EX	DE,HL

;	fudge to get started - note that link pointer is at start of map entry

	LD	IY,page			;Start of chain - IY usually points to
					; the previous entry
	LD	D,0

;	HL=block/drive no, D=0
;	In loop, DE=page no, C=previous page no.

	LD	A,(csize)		;Number of entries to search
	LD	B,A			;For DJNZ

filoop:	LD	C,E			;Save previous pageno
	Lge, E is new page
;	On exit, carry set, A=(page), B=0, HL=^previous ent

setpag:	LD	HL,cacmap
	LD	B,0			;BC now = previous page no.
	ADD	HL,BC

	LD	A,(IY+0)
	LD	(HL),A			; previous^.next:=new_ent^.next
	LD	A,(page)
	LD	(IY+0),A		; new_ent^.next:=head_ptr
	LD	A,E
	LD	(page),A		; head_ptr:=new_ent

	SCF
	RET





;RWBLK
;Read/Write block to/from disk
;
;
;On entry:
; D	Read flag (&FF -> read, 0 -> write)
; IY	Points to map entry
;(page)	**NOT USED** (hence we can write blocks not aD	E,(IY+0)		;Advance to next
	LD	IY,cacmap		;Calculate address of cacmap entry
	ADD	IY,DE

	LD	A,(IY+2)
	CP	L
	JR	NZ,filop1		;No good
	LD	A,(IY+3)		;Test hi byte
	CP	H
	JR	Z,found			;Both agree

filop1:					;Get here if this block no good
	DJNZ	filoop			;Fall through if we have tried all ents

; Now have tail of chain

	PUSH	HL			;Save blockno.
	CALL	setpag			;Make this into head of chain
	LD	A,(IY+1)		;Needs writing flag
	OR	A			; sets Zf, also clears Cf
	JR	NZ,setblk		;Not required, sot head of chain)
;
;On exit:
; C	Error code (0 = OK)
;	(errloc) also updated
; (IY)	Needs writing flag cleared always. Blockno zapped if read error

rwblk:	LD	(IY+1),0FFH	;Clear needs writing flag

	PUSH	IY
	POP	HL		;Calculate page no. from table offset
	LD	BC,cacmap	;Start of table
	OR	A		;Clear carry
	SBC	HL,BC
	LD	A,L		;the answer

	LD	(rwpage),A

	LD	L,(IY+2)	;blockno.
	LD	A,(IY+3)	; Hi byte also holds drive
	AND	3FH		;not any more
	LD	H,A
	ADD	HL,HL		;Block * 2 = Sector

	LD	A,( just insert blkno.
	LD	D,0			;r/w flag set to write
	CALL	rwblk
setblk:	POP	HL			;Get back blockno.
	LD	(IY+2),L
	LD	(IY+3),H		;Store in map
	OR	A			;Clear carry <=> not found
	RET


;	Found already in cache, so set carry for return & drop through
;	to move to head of chain if not already there.

found:	LD	A,(page)
	CP	E			;Test for already head of chain
	SCF
	RET	Z			;Return to save looping up chain

;	Move the new entry to the top of the chain
;	IY points to new entry, C is previous pao HL

;	Now have Z <=> pre-read, NZ=> no read, C=> already in cache
;
	IF	t.on
	mcond	wrm1
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	HL
	mess	wrmess
	LD	L,(IY+2)	;Blockno.
	LD	H,(IY+3)
	CALL	dhxout
	mess	adrmsg
	POP	HL
	CALL	dhxout
	mess	atmsg
	LD	A,(page)
	CALL	cahex
	CALL	pcrlf
	POP	HL
	POP	DE
	POP	BC
wrm1:	POP	AF
	ENDIF

	JR	NZ,clrblk	;No pre-read means zap to =0
	JR	C,rdywr		; Carry => it's been pre-read anyway

	PUSH	BC
	PUSH	DE
	PUSH	HL

	LD	D,0FFH		; r/w flag (read)SH	DE
	PUSH	HL		;save working registers

	IF	rm

	LD	A,(page)	;Open page
	OUT	(pagon),A

	LD	BC,03FFH	;Length-1
	LD	HL,secbuf
	LD	DE,secbuf+1
	LD	(HL),0		;Value which will be copied all the way down
	LDIR	

	;NB. page left open - will be closed after writing data in

	ELSE		;NASCOM

	LD	A,(page)
	LD	H,A
	XOR	A
	LD	L,A		;HL=address of start of page
	LD	B,4		;page count

	DI
	LD	A,pawrit
	OUT	(paport),A

clrbl0:	LD	(HL),0
	INC	L
	JR	NZ,clrbl0
	INC	H
	DJNZ	clrbl0

	LD	A,panorm

	LD	A,B		;Now test for BC=0400H => don't read
	SUB	4		;because the whole blk will be over-written
	OR	C
	CALL	NZ,rwblk	;IY contains all other info

	POP	HL
	POP	DE
	POP	BC

;	Now ready to write (into cache)
;	HL=source, DE=offset to dest., BC=byte count
rdywr:
	LD	(IY+1),0	;Needs writing (or soon will!)

	IF	RM

	LD	A,(page)	;Open paged RAM
	OUT	(pagon),A

	LD	A,D		;Add user's offset to address of paged RAM
	ADD	A,HIGH secbuf
	LD	D,A
	LDIR

	OUT	(pagoff),A	;Finished, so page off 
	OUT	(paport),A
	EI

	ENDIF

	POP	HL
	POP	DE
	POP	BC
	JR	rdywr


;fiblk
;
;Find block in cache.
; If block not found, return the tail of the chain, making it the head
; then writing out if necessary & inserting the new info in the map.
;
;On entry:
; HL	address of block descriptor (drive then block)
;
;On exit:
;(page)	updated
; IY	points to entry in cacmap
; cf	set	Found
;	clear	Not found
;
; HL,DE,BC registers all used
;

fiblk:

;Put drive in top 2 bits of block number
(value immaterial)

	ELSE		;NASCOM

	DI			;Stack does not work when page open!!
	LD	A,pawrit	;Enable page for writing
	OUT	(paport),A

	LD	A,(page)	;Add page number to offset
	ADD	A,D
	LD	D,A
	LDIR			;Do the transfer

	LD	A,panorm
	OUT	(paport),A	;Reset paging to normal
	EI

	ENDIF

	RET



;	Clear block to zero to give correct value in areas not initialised
;	by the user

clrblk:	LD	A,B
	SUB	4		; 0400H <=> 1K <=> block size
	OR	C
	JR	Z,rdywr		;ready to write

do:	PUSH	BC
	PUting flag
	OR	A
	JR	NZ,idl1		;Doesn't need it

	PUSH	BC
				;D already contains 0 (meaning write)
	CALL	rwblk

	POP	BC
	DEC	B
	RET	Z		;Written as many as we want to

idl1:	LD	E,(IY+0)	;pointer to next entry in chain
	DEC	C		;Counter to prevent checking more entries
	JR	NZ,idloop	;than there are cache entries

	RET




;PROCEDURE cempty
;
;Write out any part of the cache which still has things in.
; Not called very often, so implemented compactly rather than fast.

cempty:	LD	B,noblA

	LD	A,H		;High of offset
	ADD	A,HIGH secbuf	;Add offset to where paged RAM appears
	LD	H,A
	LDIR
	OUT	(pagoff),A	;Finished, so page off

	ELSE	;****** NASCOM

	LD	A,(page)	;Add page offset to user's offset
	ADD	A,H
	LD	H,A

	LD	A,paread	;Set up to call a LDIR in 'safe' RAM
	CALL	CtoRAM

	ENDIF

	RET			;Finished





;PROCEDURE disc_wr(addr,length,offset:Word;pre_read:Boolean;blk:block_descrip);
;
; Write up to 1 block from specified address. <offset> is offset in block.
; Erroks	;Max number of blks that could possibly
mtloop:	PUSH	BC		;need writing
	CALL	cidle
	POP	BC
	DJNZ	mtloop
	RET



;PROCEDURE disc_rd(addr,length,offset:Word;VAR blk:block_descrip);
;
; Read in up to 1 block to specified address. <offset> is offset in block.
; Errors returned in common area <error>
;

discrd:	XOR	A
	LD	(errloc),A	;No error yet

	POP	HL
	EX	(SP),HL		;Get blockno. address

	CALL	fiblk		;Returns HL pointing to map entry
	JR	C,incach	;Carry => block already in cache

	LDrs are returned in common area <error>
;


discwr:	POP	HL		;Return address
	EX	(SP),HL		; addr of block descriptor


	CALL	fiblk		;Takes ^blk in HL, returns IY ^map entry,
				;Cf set if found, Else we have the former tail

	LD	HL,errloc 	;This user is not interested in any error
	LD	(HL),0  	; to do with previous contents of page

	POP	HL		;Return address
	POP	BC		;Pre_read flag
	DEC	B		;Pre_read now in Z flag, carry unchanged
	POP	DE		;Offset
	POP	BC		;Length
	EX	(SP),HL		;Source addr t	D,0FFH		;r/w flag =READ.
	CALL	rwblk

incach:	POP	HL		;Return addr.
	POP	DE
	POP	BC
	EX	(SP),HL
	EX	DE,HL

;	Now have: HL=source offset, BC=length, DE=destination address

	IF	t.on
	mcond	rdm1
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	DE
	mess	rdmess
	LD	L,(IY+2)	;Blockno.
	LD	H,(IY+3)
	CALL	dhxout
	mess	adrmsg
	POP	HL
	CALL	dhxout
	mess	atmsg
	LD	A,(page)
	CALL	cahex
	CALL	pcrlf
	POP	HL
	POP	DE
	POP	BC
rdm1:	POP	AF
	ENDIF

	IF	RM

	LD	A,(page)	;Open page
	OUT	(pagon),k
	LD	H,(IY+blkoff+1)

	ELSE			;Test option

	PUSH	AF
	mess	t200ms
	POP	AF

	LD	HL,200

	ENDIF

	POP	AF		;drive 0..4
	PUSH	AF
	CALL	inione		;Do that drive
	POP	AF
	DEC	A		;Repeat until finished
	JP	P,inilp0

	RET

;	Error exit. iabort is entry if errloc already set.

inierr:	LD	A,1		;Duff data in blk 0
	LD	(errloc),A
iabort:	POP	HL		;old drive no(rubbish)
	RET			;(errloc) set by rwdisc

b0tab:	DEFB	0		;This is a block descriptor for blk0
	DEFW	0		; the drive will be poked at ru	POP	DE

	LD	H,D		;Get start
	LD	L,E
	INC	DE		;Clear map
	DEC	BC
	LD	(HL),-1

	tmess	<naloc0,BC,naloc1,HL,crlf>

	LDIR

	POP	DE		;Reset bits in last byte to indicate
	LD	A,E		; if not all availible
	AND	7
	JR	Z,inidk0
	LD	B,A
	SUB	A
inidk1:	SCF
	RLA
	DJNZ	inidk1
inidk0:	LD	(HL),A

	RET




;Heap error (overflow)

heaped:	error	'Heap oflow'





;PROCEDURE cidle
;
; Use FS idle time to write out any of the cache that needs it.
; Starts from the head, which means that unn time


;INIONE
;Initialise one drive
;
;On entry:
; A	Drive number
; HL	Number of blocks to allocate

inione:
	tmess	<almsg0,AF,almsg1,HL>

	PUSH	HL		;Save number of blocks
	EX	DE,HL		;DE:= no_of_blocks

	ADD	A,A		;Get address in mapptr
	LD	C,A		;BC:= A * 2
	LD	B,0

	LD	HL,dsksiz	;Put into disk size table
	ADD	HL,BC
	LD	(HL),E
	INC	HL
	LD	(HL),D

	SRМ	D		;Converф Blockу tп Byteу tп allocate
	RТ	E
	SRL	D
	RR	E
	SRL	D
	RR	E
	INC	DE

	LD	HL,mapptr+3	;+3 => point to map addreder heavy loading the items
; near the tail will never be written. However, these items will tend
; to get written anyway as the entries are either used & brought back
; to the top of the cache, or get thrown out to make space for new entries.

cidle:	LD	A,(page)
	LD	E,A		;place to start
	LD	A,(csize)	;Maximum no. of ents worth looking at
	LD	C,A
	LD	B,3		;Maximum no. of blocks we have time to write

idloop:	LD	IY,cacmap
	LD	D,0		;Turn E into 16-bit value
	ADD	IY,DE
	LD	A,(IY+1)	;Get needs wriss (H)
	ADD	HL,BC		;HL+:= A * 4
	ADD	HL,BC

	EXX			;Current heap address
	PUSH	HL
	EXX
	POP	BC

	LD	(HL),B		;Save current heap address in pointer table
	DEC	HL
	LD	(HL),C
	DEC	HL
	LD	(HL),D		;Also save length
	DEC	HL
	LD	(HL),E

	PUSH	DE		;Add length to heap
	EXX
	EX	DE,HL
	EX	(SP),HL
	ADD	HL,DE
	JP	C,heaped	;cf => heap > 0FFFFH !
	PUSH	HL
	LD	DE,myheap+heapln	;Check past end of heap
	SBC	HL,DE
	POP	HL
	JP	NC,heaped
	POP	DE
	EXX

	PUSH	BC
	PUSH	DE
	POP	BC		;Note: BC <-> DE
:=pagon
	ELSE
	LD	BC,0100H	;No test if Nascom
	ENDIF
	LD	H,4		;Pageno. under test
	LD	IY,cacmap	;IY points to the block which will point here
				;if this one is any good.
	DI

cilop0:
	IF	RM		;Different tests on RM & N2
				;Ends up at cilop1 if dud, cilop2 if OK
	LD	A,H
	CP	hitest
	JR	NC,cilop2	;Last few blocks always there

	OUT	(C),H
	LD	A,(DE)
	CP	(HL)
	JR	NZ,cilop2	;Not the same piece of ram, so OK

; two versions of byte the same: try other way up.

	CPL
	LD	(DE),A
	CP	(HL)
ers on stack for <discrd>

	IFF	t200		;Test --- Makes drive 200 blocks

	LD	HL,($hplm)	;Read this block above the system heap
	PUSH	HL
	LD	HL,0400H	;Length
	PUSH	HL
	LD	H,0		;Offset
	PUSH	HL
	LD	HL,b0tab	;Block descriptor set up to be blk0
	PUSH	HL
	CALL	discrd

	LD	A,(errloc)	;Had error ?
	OR	A
	JR	NZ,iabort


iniok:	LD	HL,($hplm)	;Where we put the block
	LD	BC,sjoff	;Offset of SJ string
	ADD	HL,BC
	LD	DE,sjmess	;Check it's an SJ disk
	LD	BC,23*256+1	;B:= len SJstring , C:= error not	JR	NZ,cilop2

; same again so this page IS being used as main RAM

	CPL
	LD	(DE),A		;restore RAM
	JR	cilop1		;Don't link in block

	ELSE			;******* ASSUME NASCOM *********

	LD	A,H
	CP	0C0H		;Only 48k available
	JR	NC,cilop1

	ENDIF

cilop2:	INC	B		;We have a good block
	LD	(IY),H		;Link it to the last good one
	LD	IY,cacmap
	PUSH	BC		;Save to make a spare register
	LD	B,0
	LD	C,H
	ADD	IY,BC		;Set IY to point to the block 
	POP	BC		; just tested

cilop1:	INC	H		;Proceed to next blo SJ
csjlop:	LD	A,(DE)
	CP	(HL)
	JR	NZ,inierr
	INC	HL
	INC	DE
	DJNZ	csjlop

	POP	BC		;B:= drive
	PUSH	BC
	INC	B		;1..5

;set bit B in A

	LD	A,80H
sbilop:	RLCA
	DJNZ	sbilop
	LD	C,A		;has 1 one
	CPL			;has 1 zero

;Set/Reset bit in dsflag

	LD	IY,($HPLM)	;Where the block was put
	LD	HL,dsflag
	AND	(HL)		;first reset bit
	LD	B,A
	LD	A,(IY+dsfoff)	;double sidedness
	AND	C		;leave relevant bit
	OR	B		;add in rest of drives
	LD	(HL),A

	LD	L,(IY+blkoff)	;HL:= number of blocks on disck
	INC	H
	INC	H
	INC	H
	JR	NZ,cilop0

	IF	RM
	OUT	(pagoff),A
	ENDIF

	XOR	A
	LD	(page),A	;Head of chain pointer

	EI


; B=number of blocks in cache

	LD	A,B
	LD	(csize),A


	IF	t.on
	XOR	A
fudge1:	INC	A
	DAA			; Simple convert binary to BCD!
	DJNZ	fudge1
	CALL	cahex
	mess	cfrmes
	ENDIF

	POP	AF		;drive

	EXX			;Init heap
	LD	HL,myheap
	EXX

; this loop occurs once for each disk

inilp0:	PUSH	AF		;drive
	LD	(b0tab),A	;Put drive in block descriptor

;	Set up parametg.
; NB3 do not muck about with this code!

crlf:	DEFM	cr,lf,'$'


	IF	t.on

;dhxout
;Print hex of HL

dhxout:	LD	A,H
	CALL	cahex
	LD	A,L
				;DROP THROUGH
;cahex
;Print hex of A
;
;On entry:
; A	number to be printed

	JP	cahex		;Now lives in h2lib or some such place
;
; Print a crlf!
pcrlf:	LD	DE,crlf
	JP	pmess


wrmess:	DEFM	'Write block $'
rdmess:	DEFM	'Read block $'
adrmsg:	DEFM	' address $'
dtsmsg:	DEFM	' RDTS=$'
atmsg:	DEFM	' @ $'
errmsg:	DEFM	' fatal disc error $'
rtto winchester

pcod2:	DI
	OUT	(paport),A	;Same logic as above
	OTIR
	OTIR			;Only to disc this time.
	LD	A,panorm
	OUT	(paport),A
	EI
	RET

CtoWIN	EQU	pacode+pcod2-pcod1	;Where it ends up
CtoRAM	EQU	pacode

	ENDIF





;PROCEDURE inidsk (max_drive: BYTE);
;
;This procedure allocates heap for the map for all drives

inidsk:	POP	HL		;Return address
	EX	(SP),HL		;Max_Drive
	PUSH	HL		;Save drive again


	LD	HL,mapptr	;Init bit map pointers & track stores
	LD	DE,mapptr+1
	LD	BC,maxrmsg:	DEFM	' bad $'
almsg0:	DEFM	'Init map $'
almsg1:	DEFM	' - length $'
naloc0:	DEFM	cr,lf,'Clear $'
naloc1:	DEFM	' bytes from $'
alblk0:	DEFM	'Allocate block $'
alblk1:	DEFM	' from map $'
frblk0:	DEFM	'Free block $'

cfrmes:	DEFM	'k Cache size',cr,lf,'$'

	ENDIF

	IF	t200
t200ms:	DEFM	'Fixed size of 200K allocated',cr,lf,'$'
	ENDIF





;PROCEDURE inilow
;
;Initialize everything that needs initing:
;Currently not very much.
;Nascom vers puts paging code in safe RAM

inilow:
	IFdrv*5-1
	LD	(HL),-1
	LDIR

	LD	HL,cacmap	;clear cache map
	LD	DE,cacmap+1
	LD	BC,noblks*4-1
	LD	(HL),-1		;all blocks free
	LDIR


;Work out how much cache is actually available & set up chain
;
; On NASCOM, always 1st 48K
;
; block 0 assumed to be OK.
; Note: when testing this page the code is safe due to LD HL,$ fudge

	LD	HL,$		;Load L with low byte of here
	LD	D,HIGH secbuf	;where paged RAM appears
	LD	E,L		;ensure same offset for test
	IF	rm
	LD	BC,pagon+256	;B:=1; (size counter) C	nascom

	LD	HL,pcod1	;The main copy of the code
	LD	DE,pacode	;The RAM where it lives
	LD	BC,030H		;Generous length allowance
	LDIR

	ENDIF

	RET


;	This code only present on NASCOM,
;	where it is copied to a piece of STATIC RAM, so that it remains
;	in the memory map even if paging is active

	IF	nascom

	;Cache to main RAM

pcod1:	DI
	OUT	(paport),A	;Turn on paging
	LDIR
	LD	A,panorm	;Set back to normal
	OUT	(paport),A
	EI			;Interrupts are off while cache open
	RET

	;Cache 