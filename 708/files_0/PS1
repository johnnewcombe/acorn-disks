{  PS1  PRINT Server INCLUDE FILE }FOR b:=1 TO 2 DO WITH Printer[b] DO BEGIN  IF in_use THEN IF rx_open THEN BEGIN    IF Rx_read(seq_no,a,print_stn,w,print_rxcbs+b) THEN BEGIN    {Data received}      buff_max:=w;      IF last_seq=Land_B(seq_no,1) THEN buff_ptr:=buff_max  {Wrong seq -ignore}      ELSE BEGIN        buff_ptr:=1;        IF old_protocol THEN BEGIN          IF NOT first_packet THEN buff_ptr:=2; {Skip spurious null - bug fix}          log_off:=buffer[buff_max]=3        END        ELSE log_off:=Land_B(seq_no,4)=4;   {new protocol logoff}        last_seq:=seq_no;        IF NOT log_off THEN Inc_B(buff_max)  {Last byte junk if logoff}      END;      rx_open:=False;      first_packet:=False;      tim_out[b]:=128  {Disable timeout while we process data}    END  END  ELSE  { IF rx_open ELSE ... }  IF (buff_ptr=buff_max) THEN BEGIN  {Buffer empty -> send ack to client, ?open Rx}    IF log_off THEN BEGIN      in_use:=False;      IF NOT no_endtext THEN PrintS(end_text,b)    END ELSE Rx_set(print_port,stn,Addr(buffer),prx_size,print_rxcbs+b);    rx_open:=True;  {Only required valid if <in_use> still true}    Eco_tx(last_seq,print_port,stn,0,1,a); {Send ack to client}    tim_out[b]:=print_timeout  END;{Send buffer contents to printer}  IF buff_ptr<>buff_max THEN BEGIN    a:=buff_max-buff_ptr;    Print(Addr(buffer[buff_ptr]),a,b);      {2nd param is bytes to print - returns number actually printed}    buff_ptr:=buff_ptr+a  ENDENDEND;