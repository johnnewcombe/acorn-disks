{ FSCAT  Code for catalogue, INCLUDEd in FSP4 }PROCEDURE Cat;VARfname:min_string;ent_no,chain_no,a,arg,ent_offset,entry,no_of_ents:Byte;index:Word;big_buff:ARRAY[1..buff_size] OF Byte;b_list:blk_vec;private:Boolean;DDA:disc_address;BEGINWITH mainRx DO BEGIN  arg:=data[1];  ent_offset:=data[2];  no_of_ents:=data[3]END;GetScr(Addr(mainRX.data[4]),min_size-4,fname);A:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[a].DDA;  Strip_dirs(fname,DDA,True);  IF error=0 THEN BEGIN    WITH cache.dir_ent[DDA.offset] DO BEGIN      b_list:=blk_list;      big_buff[4]:=cycle_no    END;  { after here, DDA contains the current block, but <offset> is undefined }    DDA.block.blk:=b_list[0];    Cache_entry(DDA.block,True);    IF error=0 THEN BEGIN      a:=0; {entry number offset to 1st chain}      chain_no:=0;      REPEAT        ent_offset:=ent_offset-a;        a:=cache.dir_ent[0].chain[chain_no].ents_in_chain;        chain_no:=Succ(chain_no);      UNTIL (ent_offset<a) OR (chain_no=15);      chain_no:=Pred(chain_no);      entry:=0; {Counter of the number we've done}      index:=5; {Index into the output buffer}      IF ent_offset<a THEN BEGIN        ent_no:=cache.dir_ent[0].chain[chain_no].ent_no;        WHILE (ent_offset>0) AND (error=0) DO BEGIN        {scan down to right entry}          ent_offset:=Pred(ent_offset);          DDA.block.blk:=b_list[ent_no DIV ents_per_block];          Cache_entry(DDA.block,True);          ent_no:=cache.dir_ent[ent_no MOD ents_per_block].next_ent        END;      {Main entry-by entry writing loop starts here}        WHILE (ent_no<>0) AND (entry<no_of_ents) AND (error=0)        AND (index < buff_size-100) DO BEGIN          DDA.block.blk:=b_list[ent_no DIV ents_per_block];          DDA.offset:=ent_no MOD ents_per_block;          Cache_entry(DDA.block,True);          WITH cache.dir_ent[DDA.offset] DO BEGIN            GetScr(Addr(Name),10,fname);               { Name as a string will come in useful}            entry:=Succ(entry);            private:=NOT((Land_B(access,P_bit)=0) OR Owner(account,aux_acc));            Pad(fname,10);            IF private THEN fname:='...Private';            CASE arg OF              0:BEGIN                PutS(Addr(big_buff[index]),fname);                Move(load_addr,big_buff[index+10],8); {Exec also}                Move(access,big_buff[index+18],3); {date also}                big_buff[index+21]:=account;                big_buff[index+22]:=0;                big_buff[index+23]:=aux_acc;                Move(extent,big_buff[index+24],3);                index:=index+27              END;              1:BEGIN {info string}                IF private THEN BEGIN                  PutS(Addr(big_buff[index]),fname);a:=10                END ELSE Info_string(cache.dir_ent[DDA.offset],                  Addr(big_buff[index]),a); {Length returned in <a>}                index:=index+a+1;                big_buff[index-1]:=0  {Terminator}              END;              2:BEGIN  {plain name}                big_buff[index]:=10;                PutS(addr(big_buff[index+1]),fname);                index:=index+11              END;              3:BEGIN  {name + att string}                Pad(fname,11);                PutS(addr(big_buff[index]),fname);                index:=index+11;                IF private THEN fname:=''    {temp use of fname}                ELSE Exp_att(access,Owner(account,aux_acc),fname);                Pad(fname,7);                PutS(addr(big_buff[index]),fname);                index:=index+8;                big_buff[index-1]:=0 {terminator}              END;              OTHERWISE error:=79 {Illegal ARG}            END; {Case}            ent_no:=next_ent          END; {with}          WHILE (ent_no=0) AND (chain_no<14) AND (error=0) DO BEGIN            chain_no:=Succ(chain_no);            DDA.block.blk:=b_list[0];            Cache_entry(DDA.block,True);            ent_no:=cache.dir_ent[0].chain[chain_no].ent_no          END        END {main WHILE loop}      END    END  ENDEND;IF error=0 THEN BEGIN  big_buff[index]:=128; {final terminator}  big_buff[1]:=0;  big_buff[2]:=0; {TX header}  big_buff[3]:=entry;  {Count of entries actually got}  Ecotx(0,mainRX.reply,client_stn,Addr(big_buff),index,a)END ELSE Err_messageEND;PROCEDURE Acct_space;CONSTmaxno=128; {Max no. of accounts to scan @ once}VARTx:RECORD  cmd_code:Byte;  return_code:Byte;  next_acc:Word;  no_sent:Word;  {Number of accounts scanned}  info:ARRAY[1..maxno] OF RECORD acc:Word; bal:Word ENDEND;bl_des:Block_descrip;out_ptr,max_ptr:Byte;account:Word;BEGINMove(mainRx.data[4],account,2); {max no. of accounts to <account> }IF account<maxno THEN max_ptr:=account ELSE max_ptr:=maxno;out_ptr:=1;tx.cmd_code:=040H; {Normal value}Move(mainRx.data[2],account,2); {start account to <account> }IF mainRx.data[6] > no_discs THEN tx.cmd_code:=0   {Test for out of range disc}ELSE BEGIN  bl_des.blk:=0;  bl_des.drive:=mainRx.data[6];  Cache_entry(bl_des,True);  WHILE (out_ptr<=max_ptr) AND (account < 256) DO BEGIN    IF (account IN user_info^.owner)THEN WITH tx.info[out_ptr] DO BEGIN      acc:=account;      bal:=cache.account_space[account];      Inc_b(out_ptr)    END;    REPEAT      Inc_W(account);    UNTIL (account > 255) OR (account IN user_info^.owner)  END;  IF account>255 THEN BEGIN    IF bl_des.drive<no_discs THEN tx.cmd_code:=080H {'go to next disc'}    ELSE tx.cmd_code:=0; {Finished}    account:=0  ENDEND;IF error<>0 THEN Err_messageELSE BEGIN  Tx.return_code:=0;  tx.next_acc:=account;  tx.no_sent:=Pred(out_ptr); {out_ptr points to free slot}  Ecotx(0,mainRX.reply,client_stn,Addr(TX),2+4*out_ptr,max_ptr)END        {NB max_ptr is dummy location here}END;