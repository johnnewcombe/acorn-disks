{ FSP4  File Server Procedures & Functions }SEGMENT Fscat;CONST{$Ifsconst}{$Ifsdecs}{$Ifsext}{$Ifsp1e}{$Ifsdire}{$Ifsdatae}PROCEDURE Read_info;VARmainTx:stdTx;fname:min_string;DDA:Disc_address;a,arg:Byte;s:Dbl_word;BEGINarg:=mainRX.data[1];GetScr(Addr(mainRX.data[2]),min_size-1,fname);a:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[a].DDA;  Strip_dirs(fname,DDA,False);  IF error=0 THEN Find(fname,DDA);  IF (error=0D6H) AND (arg<>6) THEN BEGIN {Not found, so check library                                           unless returning catalogue header}    GetScr(Addr(mainRX.data[2]),min_size-1,fname);    a:=Fcb_no(mainRx.envir.lib);    IF error=0 THEN BEGIN      DDA:=user_info^.fcbs[a].DDA;      Strip_dirs(fname,DDA,false);    END;    IF error=0 THEN Find(fname,DDA);    IF (error<>0) THEN error:=0D6H   {Ignore any problems in lib - probably                              expected to find it in CSD, so return not found.}    ELSE IF (Land_B(cache.dir_ent[DDA.offset].access,D_bit)<>0)THEN error:=0D6H      {Don't admit to finding any dirs found in the lib}  END;  IF (arg<>6) AND (error=0D6H) THEN BEGIN {Not found, so clear flag (no error)}    error:=0;    MainTx.data[1]:=0; {File exists flag (it doesn't)}    a:=3 {Tx size}  END ELSE IF error=0 THEN WITH cache.dir_ent[DDA.offset] DO BEGIN    IF Land_B(access,D_bit)=0 THEN mainTx.data[1]:=1 ELSE mainTx.data[1]:=2;                                {exists/is a file/dir flag}    CASE arg OF    1:BEGIN { creation date }      Move(creation,mainTx.data[2],2);      a:=5  {number of bytes to transmit}      END;    2:BEGIN { Load, execute addresses }      Move(load_addr,mainTx.data[2],8);      a:=11  {number of bytes to transmit}      END;    3:BEGIN {'Size' (really means extent) }      IF mainTx.data[1]=2 THEN BEGIN       {Is a dir, so SIZE reqd}        s:=Size(blk_list,exploded IN flags);        Move(s,MainTx.data[2],3)      END      ELSE Move(extent,mainTx.data[2],3);  {Is a file, so EXTENT reqd}      a:=6  {number of bytes to transmit}      END;    4:BEGIN { Access byte }      mainTx.data[2]:=access;      a:=4      END;    5:BEGIN { All info }      Move(load_addr,mainTx.data[2],14);      IF mainTx.data[1]=2 THEN BEGIN       {Is a dir, so SIZE reqd}        s:=Size(blk_list,exploded IN flags);        Move(s,MainTx.data[10],3)      END;      a:=17      END;    6:BEGIN      Check_dir(DDA.offset);      GetScr(Addr(name),10,fname);      Pad(fname,10);      WITH mainTx DO BEGIN        PutS(addr(data[4]),fname);        data[1]:=0; {Spurious byte}        data[2]:=0;        data[3]:=10; {required by BBC NFS!}        IF Owner(account,aux_acc) THEN data[14]:=0 {Owner access}        ELSE data[14]:=255; {Public}        data[15]:=cache.dir_ent[DDA.offset].cycle_no;      END;      a:=17  {Tx size}      END;      OTHERWISE error:=4FH    END {of case}  ENDEND;IF error<>0 THEN Err_messageELSE BEGIN  WITH mainTx DO BEGIN    rtncode:=0;    cmd:=0  END;  Ecotx(0,mainRX.reply,client_stn,addr(mainTX),a,a)ENDEND;PROCEDURE Write_info;VARmainTx:stdTx;fname:min_string;DDA:Disc_address;a,arg:Byte;BEGINerror:=0;arg:=mainRX.data[1];CASE arg OF  1:a:=11;  2,3:a:=6;  4:a:=3;  OTHERWISE error:=04FHEND;IF error=0 THEN GetScr(Addr(mainRX.data[a]),min_size-1,fname);a:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[a].DDA;  Strip_dirs(fname,DDA,False);  IF error=0 THEN Find(fname,DDA);  IF error=0 THEN WITH cache.dir_ent[DDA.offset] DO CASE arg OF    1:BEGIN { load,exec,access }      Check_not_dir(DDA.offset);      IF error=0 THEN        Set_att(access,Land_B( 255-D_bit-X_bit ,mainRX.data[10]));                  {Mask out dir & X bits in case someone sets them}      IF error=0 THEN Move(mainRx.data[2],load_addr,8)      END; {Set_att can set error}    2:BEGIN { Load address }      Check_not_dir(DDA.offset);      IF error=0 THEN Move(mainRx.data[2],load_addr,4)      END;    3:BEGIN { Execute addr }      Check_not_dir(DDA.offset);      IF error=0 THEN Move(mainRx.data[2],exec_addr,4)      END;    4:{ Set access }      Set_att(access,Land_B( 255-D_bit-X_bit ,mainRX.data[2]))        {Mask out dir & X bits in case someone sets them}   END {of case}END;IF error=0 THEN cache.needs_writing:=True;Err_messageEND;PROCEDURE User_envir;VARmainTx:stdTx;aS:min_string;DDA:Disc_address;lib_no,csd_no,a:Byte;BEGINmaintx.cmd:=0;maintx.rtncode:=0;csd_no:=Fcb_no(mainRx.envir.CSD);lib_no:=2; {SHOULD BE Fcb_no(mainRx.envir.LIB) BUT BBC DOES NOT ALWAYS SEND HANDLE!!}IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[csd_no].DDA;  Cache_entry(DDA.block,True);  IF error=0 THEN BEGIN    GetScr(Addr(cache.dir_ent[DDA.offset].Name),10,aS);    Pad(aS,10); {pad out CSD name}    PutS(Addr(mainTX.data[18]),aS);    DDA.block.blk:=0; {Get disc name out of blk 0}    Cache_entry(DDA.block,True);    IF error=0 THEN BEGIN      GetScr(Addr(cache.data[87]),10,aS);      maintx.data[1]:=16; {Length of disc name}      Pad(aS,16);      PutS(Addr(mainTX.data[2]),aS);      DDA:=user_info^.fcbs[lib_no].DDA;      Cache_entry(DDA.block,True);      IF error=0 THEN BEGIN        GetScr(Addr(cache.dir_ent[DDA.offset].Name),10,aS);        Pad(aS,10); {pad out LIB name}        PutS(Addr(mainTX.data[28]),aS);        Ecotx(0,mainRX.reply,client_stn,Addr(mainTX),39,a)      END    END  ENDEND;IF error<>0 THEN Err_messageEND;{$IFSCAT}PROCEDURE Disc_info;VARblk0:block_descrip;a:Byte;disc_name:Min_string;Tx:RECORD  cmd_ret_codes:Word;  no_found:Byte;          {number of discs found}  info:ARRAY[1..2] OF RECORD CASE Byte OF    1:(disc_no:Byte);     {NB. overlays length of string}    2:(disc_name:STRING[16])  ENDEND;BEGINWITH blk0 DO BEGIN  drive:=mainRx.data[1];  blk:=0END;error:=0;Tx.no_found:=0;a:=mainRx.data[2];IF a>2 THEN a:=2; {Number of drives asked for}WHILE (error=0) AND (blk0.drive <= no_discs) AND (Tx.no_found < a)DO BEGIN  Cache_entry(blk0,True);  IF error=0 THEN BEGIN    GetScr(Addr(cache.data[87]),10,disc_name);    Pad(disc_name,16);    Inc_B(tx.no_found);    tx.info[tx.no_found].disc_name:=disc_name;    tx.info[tx.no_found].disc_no:=blk0.drive  END;  Inc_B(blk0.drive)END;IF error<>0 THEN Err_messageELSE BEGIN  Tx.cmd_ret_codes:=0;  Ecotx(0,mainRX.reply,client_stn,Addr(TX),Tx.no_found*17+3,a)ENDEND;PROCEDURE Free_space;VARTx:RECORD  cmd_ret_codes:Word;  answer:Dbl_word {NB. last byte not transmitted}END;a:Byte;aS,disc_name:Min_string;BEGINGetScr(Addr(mainRx.data),10,aS);GSread(aS,disc_name,True);a:=Drive_no(disc_name);IF error<>0 THEN Err_messageELSE BEGIN  Tx.cmd_ret_codes:=0;  Tx.answer:=free_bl[a]*4; {answer is in units of 256 bytes - 3 bytes only}  Ecotx(0,mainRX.reply,client_stn,Addr(TX),5,a)ENDEND;BEGINEND.