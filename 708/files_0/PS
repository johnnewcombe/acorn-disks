{  PS  PRINT Server main code }SEGMENT Ps;CONSTstatus_port=09FH;status_reply_pt=09EH;print_port=0D1H;prx_size=128;print_timeout=20; {Timeout in seconds}{$Ifsconst}printer_type=RECORD  stn:Word;  in_use,rx_open,log_off:Boolean;  {rx_open only valid if <in_use> true}  first_packet,old_protocol:Boolean;  last_seq:Byte;  account:Word;  buff_ptr,buff_max:Byte;  buffer:ARRAY [1..prx_size] OF Byte;{Items below here all loaded from blk 0}  name:PACKED ARRAY [1..6] OF Char;  exists,use_restricted,anon_allowed,no_banner,no_endtext:Boolean;  file_name:ARRAY[1..22] OF ByteEND;{$Ifsdecs}{ COMMON variables :  }pre_text,post_text,banner,end_text:Min_string;msg_cha:Byte;tim_out:ARRAY [1..2] OF Byte;  {Count down to 0 at 1Hz if <128}VARprint_user:user_ptr;print_stn:Word;first_choice,second_choice:Byte; {Default printer numbers}log_on_buffer:Byte;printer:ARRAY[1..2] OF printer_type;status_block:RECORD  text:PACKED ARRAY[1..6] OF Char;  fn_code:WordEND;{$Ifsext}{$Ifsp1e}{$Ifsp2e}{$Ifsp3e}{$Ifsdatae}{$Ifsrnde}PROCEDURE Print(addr:Word;VAR count:Byte; channel:Byte); EXTERNAL;FUNCTION Offlin(channel:Byte):Boolean; EXTERNAL;PROCEDURE Do_list; EXTERNAL;FUNCTION Scmp(a,b:PkdS6):Boolean; EXTERNAL;PROCEDURE Ini_ban(VAR envir:printer_type); EXTERNAL;FUNCTION Gen_ban(VAR ch:Char; VAR envir:printer_type):Boolean; EXTERNAL;{Ini_ban initialises workspace; Gen_ban usually returns TRUE & deposits the next char of the banner in <ch>. Calls Next_ch to get input}PROCEDURE Ini_PS;{Initialise printer globals etc.}{**** USES BL_DES ****}VARb:Byte;BEGINRx_set(status_port,0,Addr(status_block),8,status_rxcb);Rx_set(print_port,0,Addr(log_on_buffer),1,log_on_rxcb);pre_text:='';post_text:=Concat(chr(13),chr(10)); {CR,LF}banner:='***  SJ Research ';end_text:=chr(12);WITH bl_des DO BEGIN  blk:=0;  drive:=0END;Cache_entry(bl_des,True);WITH cache DO BEGIN  first_choice:=auto_print1;  second_choice:=auto_print2;  IF message_channel=2 THEN msg_cha:=2 ELSE msg_cha:=1    {global used to determine destination of Wrch etc.}END;FOR b:=1 TO 2 DO WITH printer[b],cache.print_info[b] DO BEGIN  exists:=exists_f IN flags;  name:=printer_name;  anon_allowed:=anon_f IN flags;  use_restricted:=acct_f IN flags;  no_banner:=no_ban IN flags; {**Temp**}  no_endtext:=no_endtxt IN flags;  account:=acct_reqd;  move(banner_file,file_name,22);  buff_ptr:=1;  buff_max:=1;  in_use:=FalseEND;END;PROCEDURE PrintS(VAR aS:Min_string;printer_no:Byte);{Insert given string into LOCAL printer buffer. If insufficient room, text is truncated}BEGINWITH printer[printer_no] DO BEGIN  IF buff_ptr=buff_max THEN BEGIN    buff_ptr:=1;    buff_max:=1  END;  PutS_cr(Addr(buffer[buff_max]),aS,prx_size-Pred(buff_max));  buff_max:=buff_max+Length(aS);  IF buff_max > Succ(prx_size) THEN buff_max:=Succ(prx_size)ENDEND;PROCEDURE Who;{Find user table entry, if any, for <print_stn>}BEGINprint_user:=user_info;WHILE (print_user<>Nil) AND (print_user^.stn <> print_stn)DO print_user:=print_user^.next_userEND;FUNCTION Available(number:Byte):Boolean;{Test whether printer <number> exists & <print_user> is allowed to use it}BEGINAvailable:=False; {Until proved otherwise}IF number<>0 THEN WITH printer[number] DO IF exists THEN BEGIN  IF (NOT use_restricted) AND (anon_allowed) THEN Available:=True  ELSE IF (print_user<>Nil) THEN BEGIN    IF use_restricted THEN Available:=account IN print_user^.owner    ELSE Available:=True  ENDENDEND;FUNCTION Free(printer_no:Byte):Boolean;{Test for printer not already in use, or timed out}BEGINIF printer_no=0 THEN Free:=FalseELSE Free:=NOT(printer[printer_no].in_use AND (tim_out[printer_no]<>0))END;PROCEDURE Do_status(printer_no:Byte);{Transmit info on the status of a printer}VARtx:RECORD  status:Byte;  stn:WordEND;b:Byte;BEGINIF printer_no=0 THEN BEGIN {Chose which one to report status of}  IF Available(first_choice)  AND (Free(first_choice) OR NOT Available(second_choice))  THEN printer_no:=first_choice ELSE printer_no:=second_choiceEND;IF Offlin(printer_no) THEN tx.status:=2ELSE IF Free(printer_no) THEN tx.status:=0ELSE BEGIN  tx.status:=1;  tx.stn:=printer[printer_no].stnEND;IF Available(printer_no) THEN Eco_tx(0,status_reply_pt,print_stn,Addr(tx),3,b)END;PROCEDURE Set_status(printer_no:Byte);{Perform Do_status, & also insert printer number into user table}BEGIN  {Save selected printer. Anyone can select printer 0; explicit printers  can only be selected if access is allowed : this prevents failure later}IF (printer_no=0)OR Available(printer_no) THEN print_user^.printer:=printer_no;Do_status(printer_no)END;PROCEDURE Poll_PS;{Performs all the print server functions - polling Rx blocks, moving data & responding to status enquiries}VARaS:Min_string;a,b,seq_no:Byte;w:Word;BEGIN{Stir up peripherals}do_list;{Deal with status requests}IF Rx_read(b,b,print_stn,w,status_rxcb) THEN WITH status_block DO BEGIN  IF fn_code=1 THEN BEGIN {Ignore any functions not yet invented!}    Who;    IF print_user=NIL THEN BEGIN {anon users may not select explicit printers}      IF Scmp('PRINT ',text) THEN Do_status(0)    END    ELSE BEGIN      IF Scmp(printer[1].name,text) THEN Set_status(1)      ELSE IF Scmp(printer[2].name,text) THEN Set_status(2)      ELSE IF Scmp('AUTO  ',text) THEN Set_status(0)      ELSE IF Scmp('PRINT ',text) THEN Do_status(print_user^.printer)    END;  END;  Rx_set(status_port,0,Addr(status_block),8,status_rxcb)END;IF Rx_read(seq_no,b,print_stn,w,log_on_rxcb) THEN BEGIN  Who;  IF print_user=Nil THEN b:=0 ELSE b:=print_user^.printer; {b:=printer type}  IF b=0 THEN BEGIN  {Decide on default printer}    IF Available(first_choice) AND Free(first_choice)    THEN b:=first_choice ELSE b:=second_choice  END;  IF Available(b) AND Free(b) AND (log_on_buffer < 3)  THEN WITH printer[b] DO BEGIN       {Requested printer exists & is authorised}    IF in_use THEN BEGIN {Must have timed out}      IF NOT no_endtext THEN PrintS(endtext,b);      IF rx_open THEN Del_rx(print_rxcbs+b)    END;    in_use:=True;    stn:=print_stn;    old_protocol:=log_on_buffer = 2; {Note that =1 (illegal) not trapped}    first_packet:=True;  {Used to fix bug in old protocol}    last_seq:=Land_B(seq_no,1);    log_off:=False;    rx_open:=False;    tim_out[b]:=128; {Don't start timeout until ack sent}    StnS(print_stn,aS);    Pad(aS,15);  {statID text}    IF messag THEN BEGIN      Wrt(aS);      Wrt('Printing - ');      IF old_protocol THEN Wrt('Old') ELSE Wrt('New');      Wrtln(' protocol')    END;    IF NOT no_banner THEN BEGIN      PrintS(pre_text,b);      PrintS(banner,b);      aS:=Concat(' ***  Station ',aS);  {aS still has statid text}      PrintS(aS,b);      DateS(aS,now.date,False);      PrintS(aS,b);      aS:=' xx:yy:zz  ***';      M_dec_B(now.time.hrs,Addr(aS)+2);      M_dec_B(now.time.mins,Addr(aS)+5);      M_dec_B(now.time.secs,Addr(aS)+8);      PrintS(aS,b);      PrintS(post_text,b)    END;  END;  Rx_set(print_port,0,Addr(log_on_buffer),1,log_on_rxcb)END;{$Ips1}BEGINEND.