SEGMENT FSP3;{$Ifsconst}TYPE{$Ifsdecs}banner,end_text,pre_text,post_text:Min_string;no_banner:Boolean;{$Ifsext}{$Ifsp1e}{$Ifsp2e}{$IfsuserE}{$Ifsdire}{$Ifsdatae}{$Ifsrnde}{$Ifswilde}FUNCTION System:Boolean; EXTERNAL;PROCEDURE FlushP; EXTERNAL;FUNCTION Get_num(VAR aS:min_string;VAR found:Boolean; base:Byte; max_value:Word):Word;{Get a number from the string supplied. <base> specifies the base of the number - max is 16. <max_value> gives the maximum value allowed - any larger will cause an error.  It must be possible to hold the largest possible number with the same number of digits as <max_value> in a dbl_word. <found> is True if a legal number found - False if error or no digits at all. Any non legal-digit terminates the number & is not removed. Spaces are skipped initially.** aS must be less than <min_size> chars long}VARindex,digit:Byte;temp:Dbl_word;go_on:Boolean;result:Word;BEGINerror:=0;result:=0;found:=False;index:=1;WHILE (aS[index]=' ') AND (index<=Length(aS)) DO Inc_B(index);go_on:=index<=Length(aS);WHILE (aS[index] IN ['0'..'9','A'..'F','a'..'f']) AND go_on DO BEGIN  digit:=Ord(aS[index])-030H;  IF digit>9 THEN digit:=digit-7;   {must be A..f}  IF digit>16 THEN digit:=digit-020H;  {must be lower case}  IF digit >= base THEN go_on:=False  ELSE BEGIN    found:=True;    temp:=result*base+digit;    IF temp > max_value THEN BEGIN      go_on:=False;      error:=4  {'Bad number'}    END    ELSE result:=temp  END;  Inc_B(index);  IF index>Length(aS) THEN go_on:=FalseEND;Mid_S(aS,index-1,255);IF error=0 THEN Get_num:=result ELSE Get_num:=0END;Procedure Do_cdir(VAR real_name:min_string; no_of_K:Byte);VARb_list:blk_vec;parent,DDA:Disc_address;a,block_no:Byte;BEGINIF (no_of_K=0) OR (no_of_K > 16) THEN no_of_K:=1;a:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[a].DDA;  Strip_dirs(real_name,DDA,False);  IF error=0 THEN BEGIN    parent:=DDA;    Look_up([make,dir],no_of_K,real_name,DDA);    IF error=0C4H THEN error:=0   {Already exists, so do nothing}    ELSE IF error=0 THEN BEGIN      WITH cache.dir_ent[DDA.offset] DO BEGIN        no_of_ents:=0;        cycle_no:=0;        parent_block:=parent.block.blk;        parent_offset:=parent.offset;        def_access:=access;        access:=Land_B(access,050H)+020H;        b_list:=blk_list      END;      cache.needs_writing:=True;      FOR block_no:=0 TO Pred(no_of_K) DO BEGIN        DDA.block.blk:=b_list[block_no];        Cache_entry(DDA.block,False);        WITH cache DO BEGIN {Currently, all bytes set to 0}          FOR a:=0 TO M1ents_per_block DO dir_ent[a].next_ent:=a+block_no*16;          IF block_no=0 THEN dir_ent[0].bit_map:=[0]; {only ent 0 exists}          needs_writing:=True        END      END    END  ENDEND;Err_messageEND;PROCEDURE Cdir;VARname:Min_string;BEGINGetScr(Addr(mainRx.data[2]),80,name);Do_cdir(name,(mainRx.data[1]+3)DIV 4)END;Procedure Star_cdir(VAR cmd_text:min_string);VARreal_name:Min_string;BEGINGSread(cmd_text,real_name,True);Do_cdir(real_name,1)END;Procedure Star_lib(VAR cmd_text:min_string);VARreal_name:Min_string;DDA:Disc_address;tx:RECORD cmd_ret_codes:Word; hand:Byte END;csd_no:Byte;BEGINGSread(cmd_text,real_name,True);csd_no:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[csd_no].DDA;  Strip_dirs(real_name,DDA,True)END;IF error=0 THEN BEGIN  user_info^.fcbs[2].DDA:=DDA;  tx.cmd_ret_codes:=9;  tx.hand:=2;  {Constant lib handle}  Ecotx(0,mainRX.reply,client_stn,Addr(tx),3,csd_no)ENDELSE Err_messageEND;Procedure Star_dir(VAR cmd_text:min_string);VARreal_name:Min_string;new_no,csd_no:Byte;tx:RECORD cmd_ret_codes:Word; hand:Byte END;BEGINGSread(cmd_text,real_name,True);csd_no:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN WITH user_info^ DO BEGIN  IF ( Length(real_name)=0 ) THEN new_no:=1 {Select URD as CSD}  ELSE BEGIN    Spare_FCB(new_no);    IF error=0 THEN BEGIN      fcbs[new_no].DDA:=fcbs[csd_no].DDA;      Strip_dirs(real_name,fcbs[new_no].DDA,True);    END  END;  IF error=0 THEN BEGIN  {Close old dir, unless it's the URD}    IF csd_no<>1 THEN fcbs[csd_no].flags:=[];    fcbs[new_no].flags:=[in_use]  ENDEND;IF error<>0 THEN Err_messageELSE BEGIN  tx.cmd_ret_codes:=7;  tx.hand:=Handle(new_no);  Ecotx(0,mainRX.reply,client_stn,Addr(tx),3,new_no)ENDEND;Procedure Star_Sdisc(VAR cmd_text:min_string);BEGINcmd_text:=Concat(':',cmd_text);Star_dir(cmd_text)END;PROCEDURE Star_credit(VAR cmd_text:min_string; plus:Boolean);VARnew_bal:Dbl_word;balance:Word;got_one:Boolean;csd_no,account:Byte;BEGINIF System THEN BEGIN  account:=Get_num(cmd_text,got_one,16,0FFH);  IF got_one THEN new_bal:=Get_num(cmd_text,got_one,10,65535);  IF NOT got_one THEN error:=4  {'Bad number'}  ELSE BEGIN    csd_no:=Fcb_no(mainRx.envir.CSD);    IF error=0 THEN BEGIN      bl_des.drive:=user_info^.fcbs[csd_no].DDA.block.drive;      bl_des.blk:=0;      Cache_entry(bl_des,True);      IF plus THEN BEGIN        new_bal:=cache.account_space[account]+new_bal;        IF new_bal>65535 THEN new_bal:=65535      END ELSE BEGIN        new_bal:=cache.account_space[account]-new_bal;        IF new_bal<0 THEN new_bal:=0      END;      cache.account_space[account]:=new_bal;      cache.needs_writing:=True    END  ENDEND;Err_messageEND;PROCEDURE Star_defaccess(VAR at_string:Min_string);{Set the default access of the CSD }VARDDA:Disc_address;a:Byte;BEGINa:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[a].DDA;  Cache_entry(DDA.block,True);  IF error=0 THEN Check_dir(DDA.offset);  IF error=0 THEN WITH cache.dir_ent[DDA.offset] DO BEGIN    IF Owner(account,aux_acc) THEN Imp_att(at_string,def_access)    ELSE error:=0BDH  ENDEND;IF error=0 THEN cache.needs_writing:=True;Err_messageEND;    PROCEDURE Read_time;VARtx:RECORD  cmd_ret_codes:Word;  time:TimedateEND;a:Byte;BEGINtx.time:=now;tx.cmd_ret_codes:=0;Ecotx(0,mainRX.reply,client_stn,Addr(tx),7,a)END;PROCEDURE Set_time;BEGINIF System THEN Set_clk(Addr(mainRx.data[1]));Err_messageEND;PROCEDURE Star_flush;BEGINIF System THEN FlushP;Err_messageEND;PROCEDURE Starcmd;VARcmd_text:min_string;result,cmd_code:byte;a:Word;mainTx:RECORD  cmd_code,rtn_code:Byte;  data:ARRAY[0..min_size] OF Byte {NB. 0.. To give one xtra byte to hold max length cmd.}END;BEGINerror:=0;IF messag THEN BEGIN  StnS(client_stn,cmd_text); {cmd_text is temp store}  Pad(cmd_text,15);  Wrt(cmd_text);  Wrt('*')END;GetScr(Addr(mainRX.data),min_size,cmd_text);cmd_code:=CLI(cmd_text);IF (cmd_code=5) OR User_ok THEN {Check logged on if not *I AM }  CASE cmd_code OF     4:Star_info(cmd_text);     5:I_am(cmd_text);     6:Star_Sdisc(cmd_text);     7:Star_dir(cmd_text);     9:Star_lib(cmd_text);   239:Star_flush;   240:Star_credit(cmd_text,False);  {*DEBIT}   241:Star_credit(cmd_text,True);   {*CREDIT}   242:Star_defaccess(cmd_text);   243:Star_rename(cmd_text);   244:Star_pass(cmd_text);   245:Star_acnt(cmd_text);    {*ACCOUNT}   246:Star_access(cmd_text);   247:BEGIN GSread(cmd_text,banner,False);no_banner:=TRUE;Err_message END;   248:BEGIN GSread(cmd_text,end_text,False);Err_message END;   249:BEGIN GSread(cmd_text,post_text,False);Err_message END;   250:BEGIN GSread(cmd_text,pre_text,False);Err_message END;   251:BEGIN GSread(cmd_text,banner,False);no_banner:=False;Err_message END;   252:Star_cdir(cmd_text);   253:Log_off; {*BYE}   254:Star_delete(cmd_text);   OTHERWISE BEGIN {Unrecognised command}      mainTX.cmd_code:=8;      mainTX.rtn_code:=0;      PutS(addr(mainTX.data),cmd_text);      a:=length(cmd_text);      mainTx.data[a]:=CR;      Ecotx(0,mainRX.reply,client_stn,addr(mainTX),a+3,result)    ENDEND {case}ELSE BEGIN error:=0BFH; Err_message END {Not logged on}END;BEGINEND.