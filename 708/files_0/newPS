{  newPS  PRINT Server main code }SEGMENT Ps;CONSTstatus_port=09FH;status_reply_pt=09EH;print_port=0D1H;prx_size=128;log_on_size=80; {Need only be 1 byte but for bugs in BBC NFS}print_timeout=20; {Timeout in seconds}{$Ifsconst}pflag=(f0,disable_op);printer_type=RECORD  buffer:ARRAY [1..prx_size] OF Byte;  buff_ptr,buff_max:Byte;  up_len:Byte; {Length of unprocessed text}  start_time,end_time,current_time:Time_date;  userid:PACKED ARRAY[1..10] OF Char;  stn:Word;  tab_pos,tab_reqd:Byte;  flags:SET OF pflag;{Items above here assumed by <Banner> }  in_use,rx_open,log_off:Boolean;  {rx_open only valid if <in_use> true}  old_protocol:Boolean;  last_seq:Byte;  account:Word;  blk:FCB;{Items below here all loaded from blk 0}  name:PACKED ARRAY [1..6] OF Char;  exists,use_restricted,anon_allowed,no_banner,no_endtext:Boolean;  file_name:ARRAY[1..22] OF ByteEND;{$Ifsdecs}{ COMMON variables :  }msg_cha:Byte;tim_out:ARRAY [1..2] OF Byte;  {Count down to 0 at 1Hz if <128}VARprint_user:user_ptr;print_stn:Word;first_choice,second_choice:Byte; {Default printer numbers}printer:ARRAY[1..2] OF printer_type;status_block:RECORD  text:PACKED ARRAY[1..6] OF Char;  fn_code:WordEND;log_on_open:Boolean; {True if Rx block open for logons}log_on_buffer:ARRAY [1..log_on_size] OF Byte;{$Ifsext}{$Ifsp1e}{$Ifsp2e}{$Ifsp3e}{$Ifsdatae}{$Ifsrnde}PROCEDURE Print(addr:Word;VAR count:Byte; channel:Byte); EXTERNAL;FUNCTION Offlin(channel:Byte):Boolean; EXTERNAL;PROCEDURE Do_list; EXTERNAL;FUNCTION Scmp(a,b:PkdS6):Boolean; EXTERNAL;PROCEDURE Ini_ban(VAR envir:printer_type); EXTERNAL;FUNCTION Gen_ban(VAR ch:Char; VAR envir:printer_type):Boolean; EXTERNAL;{Ini_ban initialises workspace; Gen_ban usually returns TRUE & deposits the next char of the banner in <ch>. Calls Next_ch to get input}PROCEDURE Ini_PS;{Initialise printer globals etc.}{**** USES BL_DES ****}VARb:Byte;BEGINRx_set(status_port,0,Addr(status_block),8,status_rxcb);log_on_open:=False;WITH bl_des DO BEGIN  blk:=0;  drive:=0END;Cache_entry(bl_des,True);WITH cache DO BEGIN  first_choice:=auto_print1;  second_choice:=auto_print2;  IF message_channel=2 THEN msg_cha:=2 ELSE msg_cha:=1    {global used to determine destination of Wrch etc.}END;FOR b:=1 TO 2 DO WITH printer[b],cache.print_info[b] DO BEGIN  exists:=exists_f IN flags;  name:=printer_name;  anon_allowed:=anon_f IN flags;  use_restricted:=acct_f IN flags;  no_banner:=no_ban IN flags; {**Temp**}  no_endtext:=no_endtxt IN flags;  account:=acct_reqd;  move(banner_file,file_name,22);  buff_ptr:=1;  buff_max:=1;  in_use:=FalseENDEND;PROCEDURE Who;{Find user table entry, if any, for <print_stn>}BEGINprint_user:=user_info;WHILE (print_user<>Nil) AND (print_user^.stn <> print_stn)DO print_user:=print_user^.next_userEND;FUNCTION Available(number:Byte):Boolean;{Test whether printer <number> exists & <print_user> is allowed to use it}BEGINAvailable:=False; {Until proved otherwise}IF number<>0 THEN WITH printer[number] DO IF exists THEN BEGIN  IF (NOT use_restricted) AND (anon_allowed) THEN Available:=True  ELSE IF (print_user<>Nil) THEN BEGIN    IF use_restricted THEN Available:=account IN print_user^.owner    ELSE Available:=True  ENDENDEND;FUNCTION Free(printer_no:Byte):Boolean;{Test for printer not already in use, or timed out}BEGINIF printer_no=0 THEN Free:=FalseELSE WITH printer[printer_no] DO  Free:=exists AND ((NOT in_use) OR (tim_out[printer_no]=0))END;PROCEDURE Do_status(printer_no:Byte);{Transmit info on the status of a printer}VARtx:RECORD  status:Byte;  stn:WordEND;b:Byte;BEGINIF printer_no=0 THEN BEGIN {Chose which one to report status of}  IF Available(first_choice)  AND (Free(first_choice) OR NOT Available(second_choice))  THEN printer_no:=first_choice ELSE printer_no:=second_choiceEND;IF Available(printer_no) THEN BEGIN  IF Offlin(printer_no) THEN tx.status:=2  ELSE IF Free(printer_no) THEN tx.status:=0 ELSE BEGIN    tx.status:=1;    tx.stn:=printer[printer_no].stn  END;  Eco_tx(0,status_reply_pt,print_stn,Addr(tx),3,b)ENDEND;PROCEDURE Set_status(printer_no:Byte);{Perform Do_status, & also insert printer number into user table}BEGIN  {Save selected printer. Anyone can select printer 0; explicit printers  can only be selected if access is allowed : this prevents failure later}IF (printer_no=0)OR Available(printer_no) THEN print_user^.printer:=printer_no;Do_status(printer_no)END;PROCEDURE Poll_PS;{Performs all the print server functions - polling Rx blocks, moving data & responding to status enquiries}VARaS:Min_string;a,b,seq_no:Byte;w:Word;BEGIN{Stir up peripherals}do_list;{Deal with status requests}IF Rx_read(b,b,print_stn,w,status_rxcb) THEN WITH status_block DO BEGIN  IF fn_code=1 THEN BEGIN {Ignore any functions not yet invented!}    Who;    IF print_user=NIL THEN BEGIN {anon users may not select explicit printers}      IF Scmp('PRINT ',text) THEN Do_status(0)    END    ELSE BEGIN      IF Scmp(printer[1].name,text) THEN Set_status(1)      ELSE IF Scmp(printer[2].name,text) THEN Set_status(2)      ELSE IF Scmp('AUTO  ',text) THEN Set_status(0)      ELSE IF Scmp('PRINT ',text) THEN Do_status(print_user^.printer)    END;  END;  Rx_set(status_port,0,Addr(status_block),8,status_rxcb)END;{$Inewps1}BEGINEND.