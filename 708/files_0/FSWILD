{ FSWILD  File Server wildcard-able operations }SEGMENT fswild;{$Ifsconst}TYPE{$Ifsdecs}{$Ifsext}{$Ifsp1e}{$Ifsp3e}  {For Get_num() only!}{$Ifsdatae}{$Ifsdire}PROCEDURE Delete(dir_DDA:Disc_address;VAR fname:Min_string;no_dealloc:Boolean); EXTERNAL;PROCEDURE Wild(DDA:Disc_address;VAR fname:Min_string;  PROCEDURE do_it(DDA:disc_address;VAR soft_err:Boolean) );{Sets <error>, corrupts <c_ent>}{<Do_it> sets <error>, uses <c_ent> as input param, & may corrupt it}{ Repeatedly calls <do_it> for all the files in the dir at DDA which match the fname and to which the user has owner access. c_ent assumed bashed on exit from do_it.}{** MUST NOT USE GLOBAL BLDES, as used by *ACCOUNT}VARb_list:Blk_vec;b,chain_no,ent_no:Byte;soft_err,wild,go_on,done:Boolean;w:Word;BEGINdone:=False;  {Nothing happened indicator}IF Not Legal(fname,chain_no,wild) THEN error:=204 {Bad filename}ELSE Cache_entry(DDA.block,True);IF error=0 THEN  {look at access byte to see if it's a directory}IF Land_B(cache.dir_ent[DDA.offset].access,D_bit)=0 THEN error:=190ELSE BEGIN  b_list:=cache.dir_ent[DDA.offset].blk_list;  REPEAT {for all the chains if wild, else just 1}    DDA.block.blk:=b_list[0];    Cache_entry(DDA.block,True);    IF error=0 THEN BEGIN      ent_no:=cache.dir_ent[0].chain[chain_no].ent_no;      go_on:=True;      WHILE (error=0) AND go_on AND (ent_no<>0) DO BEGIN   {ent_no=0 <=> end chain}        DDA.block.blk:=b_list[ent_no DIV ents_per_block];        Cache_entry(DDA.block,True);        DDA.offset:=ent_no MOD ents_per_block;        IF error=0 THEN WITH cache.dir_ent[DDA.offset] DO BEGIN          ent_no:=next_ent; {Advance to next- use DDA from now on}          IF Match(fname,Addr(name),go_on) THEN BEGIN            IF NOT Owner(account,aux_acc) THEN BEGIN              error:=0BDH;              soft_err:=True            END ELSE Do_it(DDA,soft_err);            IF error=0 THEN done:=True              {If wildcard, soft errors are ignored & matching continues}            ELSE IF soft_err AND wild THEN error:=0;          END        END      END    END;    Inc_B(chain_no)  UNTIL NOT(go_on) OR (error<>0) OR (chain_no=15) OR NOT(wild);  IF (error=0) AND (NOT done) THEN    IF wild THEN error:=1 {Nothing happened}    ELSE BEGIN      error:=214;      aux_error:=fname    ENDENDEND;PROCEDURE Star_access(VAR cmd_text:Min_string);{** THIS ROUTINE SETS <error> **}VARDDA:Disc_address;a:Byte;at_string,fname:Min_string;PROCEDURE do_acc(DDA:disc_address;VAR soft_err:Boolean);{sets <error>, corrupts <c_ent>}{On entry, c_ent gives the entry pointed to by DDA. Access is performed using outer level local variables in Star_access}BEGINImp_att(at_string,cache.dir_ent[DDA.offset].access);soft_err:=error<>0CFH;IF error=0 THEN cache.needs_writing:=TrueEND;BEGINGSread(cmd_text,fname,True);IF error=0 THEN GSread(cmd_text,at_string,False);IF error=0 THEN a:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[a].DDA;  Strip_dirs(fname,DDA,False)END;IF error=0 THEN Wild(DDA,fname,Do_acc);Err_messageEND;PROCEDURE Star_acnt(VAR cmd_text:Min_string);{** USES GLOBAL BLDES & expects it to remain through calls to Wild **}{ *ACCOUNT <filespec> [<main account>] ['('<aux account>')']Booleans set_acc,set_aux indicate whether the respective fields are present.Filespace accounts are adjusted to account for the transfer.}VARDDA:Disc_address;new_acc,new_aux,a:Byte;balance:Word;   {Current balance of new account}set_acc,set_aux:Boolean;fname:Min_string;PROCEDURE do_acnt(DDA:disc_address;VAR soft_err:Boolean);{sets <error>, corrupts <c_ent>}{On entry, c_ent gives the entry pointed to by DDA. }VARold_bal,fsize:Word;BEGINsoft_err:=False;WITH cache.dir_ent[DDA.offset] DO BEGIN  IF set_acc AND (account <> new_acc) THEN BEGIN    f_size:=Size(blk_list,exploded IN flags);    IF fsize > balance THEN BEGIN      error:=0ABH;      Hex2S(new_acc,aux_error)    END    ELSE BEGIN  {OK, so change it}      Cache_entry(DDA.block,True);      IF error=0 THEN BEGIN        balance:=balance-fsize;        Disc_rd(Addr(old_bal),2,account*2+512,bl_des);        Add_no_wrap(fsize,old_bal);        Disc_wr(Addr(old_bal),2,account*2+512,True,bl_des);        account:=new_acc;        cache.needs_writing:=True      END    END  END;  IF (error=0) AND set_aux THEN BEGIN    aux_acc:=new_aux;    cache.needs_writing:=True  ENDENDEND;BEGINGSread(cmd_text,fname,True);IF error=0 THEN BEGIN  new_acc:=Get_num(cmd_text,set_acc,16,0FFH);  IF set_acc THEN IF NOT (new_acc IN user_info^.owner) THEN error:=0BDHEND;IF error=0 THEN BEGIN  a:=Pos('(',cmd_text);  IF a=0 THEN set_aux:=False {No bracket present}  ELSE BEGIN    MidS(cmd_text,a,255);  {Remove text up to & including the bracket}    new_aux:=Get_num(cmd_text,set_aux,16,0FFH)  ENDEND;IF error=0 THEN a:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[a].DDA;  Strip_dirs(fname,DDA,False)END;IF set_acc AND (error=0) THEN BEGIN  bl_des.drive:=DDA.block.drive;  bl_des.blk:=0;  Disc_rd(Addr(balance),2,new_acc*2+512,bl_des);END;IF error=0 THEN BEGIN  Wild(DDA,fname,Do_acnt);    {NB. Write back a/c info even if an error occurs}  a:=error;  IF set_acc THEN Disc_wr(Addr(balance),2,new_acc*2+512,True,bl_des);  error:=a    {Restore original error - cleared by <Disc_wr> }END;Err_messageEND;{$Ifsren}