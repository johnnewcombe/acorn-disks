{ FSOPEN  Also includes CLOSE etc.  ! }{Include file for FSRND}PROCEDURE Update_blk(VAR fbk:Fcb;new_ptr:Dbl_word);{Corrupts <c_ent>, Sets <error>}{Sets the new pointer into the FCB, updating the current block number. Also sets the extent if this is going to extend the file.}VARb_no:Word;bl_des:Block_descrip;e:Dbl_word;BEGINerror:=0;WITH fbk DO BEGIN  b_no:=new_ptr DIV blk_size; {Block offset in file}  Cache_entry(DDA.block,TRUE);  IF error=0 THEN  IF exploded IN cache.dir_ent[DDA.offset].flags THEN BEGIN    {Exploded}    bl_des.blk:=cache.dir_ent[DDA.offset].blk_list[b_no DIV 512];    IF bl_des.blk=0 THEN curr_blk:=0             {512=blocknos per exp.block}    ELSE BEGIN      bl_des.drive:=DDA.block.drive;      Cache_entry(bl_des,TRUE);      b_no:=Land_W(b_no,(blk_size DIV 2)-1); {Bring into range for this EBlist}      IF error=0 THEN curr_blk:=cache.EB_list[b_no]    END  END ELSE BEGIN    {Not exploded}    IF b_no>15 THEN curr_blk:=0    ELSE curr_blk:=cache.dir_ent[DDA.offset].blk_list[b_no]  END;  IF error=0 THEN Make3(ptr,new_ptr)ENDEND;PROCEDURE Spare_FCB(VAR fcb_no:Byte);VARfound:Boolean;new_no:Byte;BEGINWITH user_info^ DO BEGIN  new_no:=2; {The first FCB that might be free-1}  REPEAT    Inc_B(new_no);    found:=(in_use IN fcbs[new_no].flags)  UNTIL NOT found OR (new_no=8);  IF found THEN error:=192 {Too many open files}  ELSE BEGIN error:=0; fcb_no:=new_no ENDENDEND;PROCEDURE Open_in(VAR fname:Min_string;VAR new:FCB;write:Boolean);{Sets <error>,<c_ent>}VARspareS:Min_string;a,b:Byte;BEGINa:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  spareS:=fname; {Save fname in case first attempt fails}  new.DDA:=user_info^.fcbs[a].DDA;  Strip_dirs(fname,new.DDA,False);  IF error=0 THEN Find(fname,new.DDA);  IF error=0D6H THEN BEGIN {not found, so try LIB}    fname:=spareS; {repair fname}    spareS:=aux_error; {If any error occurs on LIB search, 1st error counts}    new.DDA:=user_info^.fcbs[2].DDA; {Lib handle defined =2}    Strip_dirs(fname,new.DDA,False);    IF error=0 THEN Find(fname,new.DDA);    IF error=0 THEN IF Land_B(D_bit,cache.dir_ent[new.DDA.offset].access)<>0    THEN error:=0B5H;  {Don't open dirs in the lib}    IF error<>0 THEN BEGIN {if failed, return error relating to CSD scan}      error:=0D6H;      aux_error:=spareS    END  END;  IF error=0 THEN WITH cache.dir_ent[new.DDA.offset] DO BEGIN    IF Owner(account,aux_acc) THEN a:=access DIV 4 ELSE a:=access;{<a> contains W,R bits of access byte. <write> indicates whether we are openingfor input or update. Directories are allowed to be opened only for input.}    IF write THEN BEGIN      IF Land_B(a,W_bit)=0 THEN error:=0BDH; {will be changed if it is a dir}      Check_not_dir(new.DDA.offset);      IF error=0 THEN BEGIN        Move(now,update,sizeof(short_td));   {Set update date}        cache.needs_writing:=True      END    END    ELSE IF (Land_B(a,R_bit)=0) AND (Land_B(access,D_bit)=0) THEN error:=0BDH  END;  IF error=0 THEN BEGIN    new.ext:=cache.dir_ent[new.DDA.offset].extent;    Update_blk(new,0); {Sets error}    Make3(new.old_ptr,0);    IF error=0 THEN Cache_entry(new.DDA.block,True); {Cache used by Update_blk}    IF error=0 THEN IF Check_open(new.DDA,[W]) THEN error:=0C2H  {<Check_open> sets <aux_error>, but not <error> if any FCB found   with given flags}    ELSE BEGIN      IF NOT write THEN a:=Land_B(a,R_bit); {Knock out W if OPENIN type call}      IF Land_B(a,R_bit)=0 THEN new.flags:=[in_use] ELSE new.flags:=[in_use,R];      IF Land_B(a,W_bit)<>0 THEN new.flags:=new.flags+[W]    END  ENDENDEND;PROCEDURE Open_out(VAR fname:Min_string;VAR new:FCB;init_ext:Dbl_word);VARa:Byte;x:Word;BEGINa:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN IF init_ext>0800000H THEN error:=035HELSE BEGIN  new.DDA:=user_info^.fcbs[a].DDA;  Strip_dirs(fname,new.DDA,False);  IF init_ext=0 THEN x:=0 ELSE x:=Succ(Pred(init_ext) DIV block_size);  IF error=0 THEN Look_up([make],x,fname,new.DDA);  IF error=0 THEN BEGIN    Update_blk(new,0);    Make3(new.old_ptr,0);    IF error=0 THEN Cache_entry(new.DDA.block,True);    {cache used by Set_ptr & not set properly by Look_up anyway.}    IF error=0 THEN BEGIN      Make3(new.ext,init_ext);      WITH cache.dir_ent[new.DDA.offset] DO BEGIN        extent:=new.ext;        load_addr:=-1;        exec_addr:=-1       {0FFFFFFFFH really!}      END;      new.flags:=[in_use,W,R];      cache.needs_writing:=True    END  ENDENDEND;PROCEDURE Close(VAR fblk:FCB);{Sets <error>}BEGINerror:=0;IF (fblk.flags * [W,in_use]) = [W,in_use] THEN BEGIN  Cache_entry(fblk.DDA.block,True);  IF error=0 THEN BEGIN    cache.dir_ent[fblk.DDA.offset].extent:=fblk.ext;    cache.needs_writing:=True  ENDEND;fblk.flags:=[]END;PROCEDURE X_open;{Open an object - external (user) call}VARfname:Min_string;tx:RECORD  cmd_rtn_codes:Word;  hand:ByteEND;number:Byte;BEGINGetScr(Addr(mainRx.data[3]),min_size,fname);Spare_FCB(number); {Select a new fcb}IF error=0 THEN BEGIN  IF mainRx.data[1]=0 THEN Open_out(fname,user_info^.fcbs[number],0)  ELSE Open_in(fname,user_info^.fcbs[number],(mainRx.data[2]=0))END;{     Last parameter to <Open_in> is boolean <write> - ie. Open_up if True }IF error<>0 THEN Err_messageELSE BEGIN  Tx.hand:=Handle(number);  tx.cmd_rtn_codes:=0;  Ecotx(0,mainRx.reply,client_stn,addr(tx),3,number)ENDEND;PROCEDURE X_close;VARnumber:Byte;BEGINerror:=0;number:=mainRx.data[1];IF number=0 THEN WITH user_info^ DO BEGIN  { CLOSE#0 }  number:=3;  REPEAT    IF (fcbs[number].flags * [W,R]) <> [] THEN Close(fcbs[number]);    Inc_B(number);              {don't close directories}  UNTIL (error<>0) OR (number>8)ENDELSE BEGIN  number:=Fcb_no(number);  IF error=0 THEN Close(user_info^.fcbs[number])END;Err_messageEND;PROCEDURE Rd_rnd_info;VARtx:RECORD  cmd_rtn_codes:Word;  value:Three_byteEND;number:Byte;BEGINnumber:=FCB_no(mainRx.data[1]);IF error=0 THEN WITH user_info^.fcbs[number] DO  CASE mainRx.data[2] OF  {data[2] is ARG}  0:tx.value:=ptr;  1:tx.value:=ext;  2:BEGIN      Cache_entry(DDA.block,True);      WITH cache.dir_ent[DDA.offset] DO      Make3(tx.value,Size(blk_list,exploded IN flags)*blk_size)    END;  OTHERWISE error:=06DHEND;IF error<>0 THEN Err_messageELSE BEGIN  tx.cmd_rtn_codes:=0;  Ecotx(0,mainRx.reply,client_stn,Addr(tx),5,number)ENDEND;PROCEDURE Wr_rnd_info;VARp,e:Dbl_word;number:Byte;BEGINnumber:=FCB_no(mainRx.data[1]);IF error=0 THEN WITH user_info^ DO WITH fcbs[number] DO BEGIN  p:=0; {hi bits}  Move(mainRx.data[3],p,3); {lo 3 bytes}  CASE mainRx.data[2] OF  {data[2] is ARG}    0:BEGIN        IF p>0800000H THEN error:=035H        ELSE Update_blk(fcbs[number],p);        IF error=0 THEN BEGIN          flags:=flags-[err];          Make3(old_ptr,p);          Make4(e,ext);          IF p>e THEN Make3(ext,p) {Extend file}        END      END;    OTHERWISE error:=06DH  ENDEND;Err_messageEND;PROCEDURE Eof;VARTx:RECORD  cmd_rtn_codes:Word;  value:ByteEND;p,e:Dbl_word;number:Byte;BEGINnumber:=FCB_no(mainRx.data[1]);IF error=0 THEN WITH user_info^ DO BEGIN  IF Check_flags(fcbs[number],[]) THEN BEGIN    Make4(e,fcbs[number].ext);    Make4(p,fcbs[number].ptr);    IF p=e THEN tx.value:=0FFH ELSE tx.value:=0;    tx.cmd_rtn_codes:=0;    Ecotx(0,mainRx.reply,client_stn,addr(tx),3,number)  END  ELSE Err_messageENDELSE Err_message;END;