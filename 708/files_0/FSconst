{>  FSconst}min_size=80; {Size of minibuffers}CR=13;cmdport=099H;data_port=09AH; {This is re-declared locally when it is a variable}blk_size=1024; {Size of unit in which disc is allocated. Not easily changed. }block_size=blk_size;ents_per_block=16;words_per_block=512;M1ents_per_block=15;  {Minus 1!!}M1words_per_block=511;M1block_size=1023;buff_size=2048; {MUST be an integer no. of blocks (for save/load) }max_drive=3;  {min drive is 0}{Rxcb numbers}task_no=0;  {Current task has 1 rxcb with rxcb no = task no}status_rxcb=4; {For print status}print_rxcbs=4;  {printerN_rxcb=print_rxcbs+N}printer1_rxcb=5;printer2_rxcb=6;log_on_rxcb=7;  {Will be open for any stn, so MUST come after printer1,printer2}{Access Byte bits}X_bit=128;P_bit=64;D_bit=32;L_bit=16;R_bit=1;W_bit=2;TYPEDbl_word=Integer;Byte=0..255;Three_Byte=ARRAY [1..3] OF Byte;Word=0..65535;Nibble=0..15; Buffer=ARRAY [1..buff_size] of Byte;Minibuffer=ARRAY [1..min_size] of Byte;min_string=string[min_size];PkdS6=PACKED ARRAY[1..6] OF Char;Handles=RECORD  URD,CSD,lib:ByteEND;StdRX=RECORD CASE Boolean OF  True:(print:Minibuffer);  False:(reply:Byte;    FN:Byte;    envir:Handles;    data:Minibuffer)END;StdTX=RECORD  cmd:Byte;  rtncode:Byte;  data:minibufferEND;Block_descrip=RECORD  drive:Byte;  blk:Word    {Block number. Each block is <blk_size> Bytes}END;Date_type=RECORD  day:Byte;  mth_yr:ByteEND;Short_time=RECORD  hrs:Byte;  mins:ByteEND;Time_type=RECORD  hrs:Byte;  mins:Byte;  secs:ByteEND;Timedate=RECORD  date:Date_type;  time:Time_typeEND;Short_td=RECORD  date:Date_type;  time:Short_timeEND;Disc_address=RECORD  block:block_descrip;  offset:Byte          {64 Byte Offset in block : Origin is ZERO}END;dir_flags=(exploded,xx1,xx2,xx3,xx4,xx5,xx6,xx7);blk_vec=ARRAY [0..15] OF Word;ent_type=RECORD CASE Byte OF   0:(bit_map:SET OF Byte;      chain:ARRAY [0..14] OF RECORD        ents_in_chain:Byte;        ent_no:Byte      END;      spare:Word      );   1:(Dum2:ARRAY [0..11] OF Byte;      def_access:Byte;      cycle_no:Byte;      parent_block:Word;      parent_offset:Byte;      no_of_ents:Byte;      dum1:ARRAY [18..63] OF Byte; {Items common to both}      );   2:(account:Byte;      name:ARRAY[0..9] OF Byte;      next_ent:Byte;      load_addr:Dbl_word;      exec_addr:Dbl_word;      extent:Three_Byte;      access:Byte;      creation:Date_type;      update:Short_td; {Time & date - no secs }      Aux_acc:Byte;      flags:SET OF dir_flags;      blk_list:blk_vec      )END;user_flags=(pass_set,sys_priv,prot_save,aa3,aa4,aa5,aa6,aa7);printer_flags=(exists_f,anon_f,acct_f,no_ban,no_endtxt);Cache_descrip=RECORD  which_blk:block_descrip;  next:Byte;  needs_writing:Boolean;  CASE Byte OF    1:(data:ARRAY [0..M1block_size] OF Byte);    2:(EB_list:ARRAY [0..M1words_per_block] OF Word);    3:(dir_ent:ARRAY [0..M1ents_per_block] OF ent_type);    5:(junk:ARRAY [0..86] OF Byte;      disc_name:ARRAY[0..9] OF Byte;      ds_flag:Byte;      disc_size:Word;      message_channel:Byte; {Dest for Wrtln etc.}      auto_print1:Byte;      auto_print2:Byte;      junk2:ARRAY [103..191] OF Byte;      print_info:ARRAY[1..2] OF RECORD        printer_name:PkdS6;        flags:SET OF printer_flags;        acct_reqd:Word;        banner_file:ARRAY[9..31] OF Byte      END;      junk3:ARRAY[256..511] OF Byte;      account_space:ARRAY [Byte] OF Word)END;fcb_flag=(seq,in_use,W,R,err,yy5,yy6,yy7);fcb_flags=SET OF fcb_flag;fcb=RECORD  flags:fcb_flags;  DDA:Disc_address; {The directory disc address : the disc address of the                     directory entry for the file. This implicitly contains                     the drive of the file as files can't refer from                     drive to drive. Drive set to 255 if disc changed }  curr_blk:Word;    {The block pointed to by the random pointer}  ptr:Three_Byte;   {The random pointer (PTR# in Basic)}  old_ptr:Three_Byte; {The value used for the last operation}  ext:Three_Byte    {File extent}            {NB. curr_blk to ext are over-written by the user ID in the             1st FCB for each user, which is always a dir (the URD) }END;user_ptr=^user_descrip;user_descrip=RECORD {169 bytes}  next_user:user_ptr;  flags:SET OF user_flags;  stn:Word;  fcbs:ARRAY[1..8] OF fcb;  {1,2 defined: 1=URD, 2=LIB}  pass_drive:Byte;  {Which password file used for log-on?}  pass_ptr:Word; {index into password file}  owner:SET of Byte;  printer:Byte;END;lookup_flag=(make,dir,no_del);lookup_flags=SET OF lookup_flag;