{ BIGDATA  File Server data management }SEGMENT fsdata;CONST{$Ifsconst}{$Ifsdecs}{$Ifsext}{$IFSP1E}{$Ifsrnde}{$IFSDIRE}PROCEDURE Sys_err; EXTERNAL;PROCEDURE Ini_PS; EXTERNAL;FUNCTION Same_blk(a,b:Block_descrip):Boolean;BEGINSame_blk:=(a.blk=b.blk) AND (a.drive=b.drive)END;PROCEDURE Cache_entry(desired:block_descrip;read_in:Boolean);{Sets <c_ent>,<error>}{ Either finds the required block in the cache or allocates a new entry. If a new entry is required, the block will only be brought in off disc if the <read_in> parameter is TRUE (it would be false for a block which is going to be re-written eg. if the block has only just been allocated) If <read_in> is false, then the block data is zeroed before returning.}VARw:Word;BEGINerror:=0;IF Not Same_blk(desired,cache.which_blk) THEN WITH cache DO BEGIN  IF needs_writing THEN BEGIN    Disc_wr(Addr(data),block_size,0,False,which_blk);    needs_writing:=FALSE  END;  IF read_in THEN BEGIN    Disc_rd(Addr(data),block_size,0,desired);    IF error<>0 THEN desired.blk:=255   {drive=255 <=> cache entry empty}  END  ELSE FOR w:=0 TO M1block_size DO data[w]:=0;  which_blk:=desiredENDEND;PROCEDURE Empty_C;{Empties both internal & external caches in preparation for exit or changing discs}VARa,b:Byte;this_user:user_ptr;BEGINthis_user:=user_info;WHILE this_user <> Nil DO WITH this_user^ DO BEGIN  FOR b:=1 TO 8 DO IF W IN fcbs[b].flags THEN Close(fcbs[b]); {close O/P files}  this_user:=next_userEND;WITH cache DO BEGIN  IF needs_writing THEN BEGIN    Disc_wr(Addr(data),block_size,0,False,which_blk);    needs_writing:=FALSE  END;  which_blk.drive:=255END;C_empty;  {Empty external cache}END;PROCEDURE Un_count;{ Un counts the block described by global <bl_des> }BEGINAlloc(bl_des);Dec_W(free_bl[bl_des.drive])END;PROCEDURE Scan_file(b_list:Blk_vec;exploded:Boolean);{Un counts the blocks occupied by a file. <b_list> is 2nd half of dir ent <exploded> indicates whether this is in fact an exploded file, in which case, all the blocks are loaded & scanned.}VARa:Byte;b:Word;BEGINFOR a:=0 TO 15 DO IF b_list[a]<>0 THEN BEGIN {=0 => not allocated}  bl_des.blk:=b_list[a];  Un_count;  IF exploded THEN BEGIN    Cache_entry(bl_des,True);    IF error=0 THEN WITH cache    DO FOR b:=0 TO M1words_per_block DO BEGIN      bl_des.blk:=EB_list[b];      IF bl_des.blk<>0 THEN Un_count    END  ENDENDEND;PROCEDURE Bld_map;VARaS:Min_string;this_ent:Ent_type;b_list:Blk_vec;no_users,ent_offset,block_offset,this_ent_offset,discno:Byte;this_block:Word;  {Context of <this_ent> }root:Boolean;BEGINHeap_rs;  {Reset heap}Inidsk(no_discs);  {Returns max drive no.}IF error<>0 THEN BEGIN  Wrtln('Blk 0 corrupt');  Sys_errEND;Ini_PS;   {MUST come after Ecoini, AND after Inidsk}FOR discno:=0 TO no_discs DO BEGIN  root:=False;  { completion flag }  bl_des.drive:=discno;  bl_des.blk:=0;   {Look @ root}  Cache_entry(bl_des,True);  Uncount;  block_offset:=0;  ent_offset:=0;  cache.dir_ent[0].next_ent:=1;  {Root appears deleted otherwise}  REPEAT  {Scan directory tree}    WHILE (Land_B(D_bit,cache.dir_ent[ent_offset].access)<>0)    AND (cache.dir_ent[ent_offset].next_ent<>(ent_offset+block_offset*16))    DO BEGIN      {Is a dir and not deleted}      this_block:=bl_des.blk; {Save context}      this_ent_offset:=ent_offset;      this_ent:=cache.dir_ent[ent_offset];      FOR block_offset:=15 DOWNTO 0 DO BEGIN        bl_des.blk:=this_ent.blk_list[block_offset];        IF bl_des.blk<>0 THEN Uncount      END;      ent_offset:=1;   {Ent 0 in block 0 is bit map etc.}      block_offset:=0;      Cache_entry(bl_des,True) {bl_des contains 1st blk of list from FOR loop}    END;               {NB also that the 1st block of a dir. always exists}{ Enters here with current ent either a file or deleted}    WITH cache.dir_ent[ent_offset] DO    IF (next_ent<>(ent_offset+block_offset*16))   {Not deleted}    THEN Scan_file(blk_list,exploded IN flags);    Inc_B(ent_offset);    WHILE ent_offset=ents_per_block DO BEGIN      ent_offset:=0;      IF block_offset=15 THEN IF this_block=0 THEN root:=True        ELSE BEGIN { End of dir, so up one level }        bl_des.blk:=this_ent.parent_block;        ent_offset:=Succ(this_ent_offset);        this_ent_offset:=this_ent.parent_offset;        Cache_entry(bl_des,True);        this_ent:=cache.dir_ent[this_ent_offset];        block_offset:=0;        WHILE this_ent.blk_list[block_offset] <> this_block        DO Inc_B(block_offset);        this_block:=bl_des.blk        END      ELSE BEGIN        Inc_B(block_offset);        IF this_ent.blk_list[block_offset]=0 THEN ent_offset:=ents_per_block        {Force skip to next block if this blk does not exist}      END    END; { NB. Scan_file may zap cache, so we need to request block from cache even if   not crossing block boundary }    bl_des.blk:=this_ent.blk_list[block_offset];    Cache_entry(bl_des,True);  UNTIL root;  {Got back to the root} { Now do password file }  bl_des.blk:=0;  Cache_entry(bl_des,True);  WITH cache.dir_ent[2] DO Scan_file(blk_list,exploded IN flags)END;{Init user table}no_users:=0;spare_users:=Nil;WHILE Heap(user_info,Sizeof(user_descrip)) DO WITH user_info^ DO BEGIN  Inc_B(no_users);  FOR ent_offset:=1 TO 8 DO fcbs[ent_offset].flags:=[];  {Not in_use etc.}  next_user:=spare_users;  spare_users:=user_infoEND;user_info:=Nil;IF messag THEN BEGIN  Wrt('Max users=');  Dec_S(no_users,aS);  Wrtln(aS)ENDEND;BEGINEND.