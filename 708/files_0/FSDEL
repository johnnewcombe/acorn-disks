{ FSDEL  File Server delete operation }SEGMENT fsdel;{$Ifsconst}TYPE{$Ifsdecs}{$Ifsext}{$Ifsp1e}{$Ifsdatae}{$Ifsdire}{$Ifsrnde}FUNCTION Scrap(b_list:Blk_vec;exploded:Boolean):Word;{Sets <error>. Corrupts <c_ent>,<bl_des> }{Counts & de-allocs blocks occupied by a file. <b_list> is 2nd half of dir ent. <exploded> indicates whether this is in fact an exploded file, in which case, all the blocks are loaded & scanned. Note that <free_bl> & account info are NOT adjusted. ***Takes it's drive no from the current cache block !!!!*****}VARa,b:Byte;result:Word;BEGINresult:=0;a:=0;bl_des.drive:=cache.which_blk.drive;  {**FUDGE  ***** }WHILE (a<16) AND (error=0) DO BEGIN  IF b_list[a]<>0 THEN BEGIN {=0 => not allocated}    bl_des.blk:=b_list[a];    D_alloc(bl_des);    Inc_W(result);    IF exploded THEN BEGIN      Cache_entry(bl_des,True);      WITH cache DO FOR b:=0 TO M1words_per_block DO BEGIN        bl_des.blk:=EB_list[b];        IF bl_des.blk<>0 THEN BEGIN Inc_W(result); D_alloc(bl_des) END;      END    END  END;  Inc_B(a)END;Scrap:=resultEND;PROCEDURE Delete(dir_DDA:Disc_address;VAR fname:Min_string;no_dealloc:Boolean);{Sets <error>, Corrupts <c_ent>}{Deletes one or many files, as specified by <fname> which may be ambiguous.First builds a map of entries to delete, whilst removing them from the chain,then deletes them. This minimises the possibility of broken dirs.If <no_dealloc> is True, blocks are not dealloced & dir not MT is not checked.}VARmap:SET of Byte; {Set to hold all those to be deleted}b_list:Blk_vec;DDA:Disc_address;total:Word;tot_count,chain_no,ent_no,previous,count,b:Byte;go_on,wild,deleted:Boolean;PROCEDURE Get_blk(a:Word);{Local procedure - sets c_ent if the current block <DDA.block> is not the same as <a> }BEGINIF DDA.block.blk<>a THEN BEGIN  DDA.block.blk:=a;  Cache_entry(DDA.block,True)ENDEND;BEGINIF Not Legal(fname,chain_no,wild) THEN error:=204 {Bad name}ELSE Cache_entry(dir_DDA.block,True);IF error=0 THEN BEGIN  tot_count:=0; {Count of total files deleted}  map:=[]; {Map of deleted files}  b_list:=cache.dir_ent[dir_DDA.offset].blk_list;  DDA:=dir_DDA;  REPEAT {for all the chains if wild, else just 1}    previous:=0; {Dummy value to indicate start of chain}    count:=0;    {Count of successive entries to be deleted}    Get_blk(b_list[0]);    IF error=0 THEN BEGIN      ent_no:=cache.dir_ent[0].chain[chain_no].ent_no;      go_on:=True;      WHILE (error=0) AND go_on AND (ent_no<>0) DO BEGIN   {ent_no=0 <=> end chain}        DDA.offset:=ent_no MOD ents_per_block;        deleted:=False;        Get_blk(b_list[ent_no DIV ents_per_block]);        WITH cache.dir_ent[DDA.offset] DO BEGIN          b:=next_ent; {save to move on ent_no at end}          IF (error=0) AND Match(fname,Addr(name),go_on) THEN BEGIN            IF NOT Owner(account,aux_acc) THEN error:=0BDH            ELSE IF Land_B(access,L_bit)<>0 THEN error:=0C3H {locked}            ELSE IF Check_open(DDA,[in_use]) THEN error:=0C2H {already open}                            {<Check_open> sets <aux_error>, but not <error>}            ELSE IF (Land_B(access,D_bit)<>0) AND (no_of_ents<>0)              AND (NOT no_dealloc) THEN error:=0B4H     {Dir not empty}            ELSE BEGIN              Inc_B(count);              Inc_B(tot_count);              deleted:=True;              map:=map+[ent_no]            END;            IF wild THEN error:=0;          {If wild, ignore non-serious errors as there may be more files}          END        END;        IF NOT deleted THEN BEGIN          IF count<>0 THEN BEGIN {count gives number of files to delete}            Get_blk(b_list[previous DIV ents_per_block]);            IF error=0 THEN BEGIN              WITH cache.dir_ent[previous MOD ents_per_block] DO              IF previous=0 THEN chain[chain_no].ent_no:=ent_no              ELSE next_ent:=ent_no;              cache.needs_writing:=True;              Get_blk(b_list[0]);              IF error=0 THEN BEGIN                WITH cache.dir_ent[0].chain[chain_no] DO                  ents_in_chain:=ents_in_chain - count;                cache.needs_writing:=True              END;              count:=0            END          END;          previous:=ent_no {ent_no of last non-deleted file}        END;        ent_no:=b {b holds next ent as cache contents undef. here}      END    END;    IF (error=0) AND (count<>0) THEN BEGIN {End of chain to cut off}      Get_blk(b_list[previous DIV ents_per_block]);      IF error=0 THEN BEGIN        WITH cache.dir_ent[previous MOD ents_per_block] DO        IF previous=0 THEN chain[chain_no].ent_no:=ent_no        ELSE next_ent:=ent_no;        cache.needs_writing:=True;        Get_blk(b_list[0]);        IF error=0 THEN BEGIN          WITH cache.dir_ent[0].chain[chain_no] DO            ents_in_chain:=ents_in_chain - count;          cache.needs_writing:=True        END;      END    END;    Inc_B(chain_no)  UNTIL NOT(go_on) OR (error<>0) OR (chain_no=15) OR NOT(wild)END;IF (error=0) AND (map=[]) THEN  IF wild THEN error:=1  {Nothing happened}  ELSE BEGIN    error:=214;    aux_error:=fname  ENDELSE FOR ent_no:=1 TO 255 DO  IF (error=0) AND (ent_no IN map) THEN BEGIN  DDA.block.blk:=b_list[ent_no DIV ents_per_block];  Cache_entry(DDA.block,True);  IF error=0 THEN WITH cache.dir_ent[ent_no MOD ents_per_block] DO BEGIN    next_ent:=ent_no; {Mark as deleted}    chain_no:=account; {Using chain_no to store info from cache}    cache.needs_writing:=True;    IF Not(no_dealloc) THEN total:=Scrap(blk_list,exploded IN flags)  END;  IF (error=0) AND (Not(no_dealloc)) THEN BEGIN    DDA.block.blk:=0; {Account allocation in blk 0}    Cache_entry(DDA.block,True);    IF error=0 THEN WITH cache DO BEGIN {chain_no holds account no}      Add_no_wrap(total,account_space[chain_no]);      free_bl[DDA.block.drive]:=free_bl[DDA.block.drive]+total;      needs_writing:=True    END  ENDEND;IF error=0 THEN BEGIN  DDA.block.blk:=b_list[0]; {Remove files from bit map in entry 0}  Cache_entry(DDA.block,True);  IF error=0 THEN BEGIN    WITH cache.dir_ent[0] DO bit_map:=bit_map-map;    cache.needs_writing:=True;    Cache_entry(dir_DDA.block,True);    IF error=0 THEN WITH cache DO BEGIN      WITH dir_ent[dir_DDA.offset] DO BEGIN        no_of_ents:=no_of_ents-tot_count;        Move(now,update,Sizeof(short_td)); {Insert update date}        Inc_B(cycle_no)      END;      needs_writing:=True    END  ENDENDEND;BEGINEND.