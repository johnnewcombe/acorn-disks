{ FSREN  INCLUDed in FSWILD }PROCEDURE Star_rename(VAR cmd_text:Min_string);VARfname,dest:Min_string;from_DDA,to_DDA:Disc_address;done_already:SET of Byte;   {Prevents files being renamed twice}same_dir:Boolean;  {True if source & destination dirs the same}a:Byte;PROCEDURE do_ren(DDA:disc_address;VAR soft_err:Boolean);{NB LOCAL BL_DES}VARbl_des:Block_descrip;ent_offset,block_offset:Byte;old_ent:Ent_type;new_DDA:Disc_address;bool:Boolean;BEGINold_ent:=cache.dir_ent[DDA.offset];IF Land_B(L_bit,old_ent.access) <> 0 THEN error:=0C3HELSE IF Check_open(DDA,[in_use]) THEN error:=0C2HELSE Tst_ren(dest,cmd_text,fname,Addr(old_ent.name),bool);{cmd_text contains new name}IF error=0 THEN BEGIN  IF same_dir AND Match(cmd_text,Addr(old_ent.name),bool) {*REN. fred FrEd etc}  THEN BEGIN    PutScr(Addr(cache.dir_ent[DDA.offset].name),cmd_text,10);    cache.needs_writing:=True  END  ELSE IF NOT (DDA.offset IN done_already) THEN BEGIN    IF NOT ((Land_B(D_bit,old_ent.access)=0) OR same_dir) THEN BEGIN {It's a dir, being renamed from dir to dir, so check for loops}      new_DDA:=to_DDA;      REPEAT        bool:=Same_DDA(DDA,new_DDA);        Cache_entry(new_DDA.block,True);        WITH cache.dir_ent[new_DDA.offset],new_DDA DO BEGIN          block.blk:=parent_block;          offset:=parent_offset        END      UNTIL bool OR (new_DDA.block.blk=0);  {Stop at root if no loop}      IF bool THEN error:=7      ELSE WITH old_ent,to_DDA DO BEGIN        parent_block:=block.blk;        parent_offset:=offset      END    END;    new_DDA:=to_DDA;    IF error=0 THEN Look_up([make,no_del],0,cmd_text,new_DDA); {Make new entry}    IF error=0 THEN WITH cache.dir_ent[new_DDA.offset] DO BEGIN      Move(old_ent.load_addr,load_addr,52);      account:=old_ent.account;      GetScr(Addr(old_ent.name),10,cmd_text);  {Get un-wildcarded name}      Delete(from_DDA,cmd_text,True);      IF same_dir THEN done_already:=done_already+[new_DDA.offset]    END;    IF (Land_B(D_bit,old_ent.access)<>0) AND (error=0) THEN BEGIN      ent_offset:=1;      block_offset:=0;      bl_des.drive:=to_DDA.block.drive;      bl_des.blk:=old_ent.blk_list[0];      REPEAT        Cache_entry(bl_des,True);        WHILE ent_offset<ents_per_block DO WITH cache.dir_ent[ent_offset] DO           BEGIN          IF Land_B(D_bit,access)<>0 THEN BEGIN            parent_block:=new_DDA.block.blk;            parent_offset:=new_DDA.offset;            cache.needs_writing:=True          END;          Inc_B(ent_offset)        END;        REPEAT          Inc_B(block_offset);          IF block_offset<16 THEN bl_des.blk:=old_ent.blk_list[block_offset]        UNTIL (bl_des.blk<>0) OR (block_offset>15);        ent_offset:=0      UNTIL Block_offset>15    END  ENDEND;soft_err:=error IN [7,0C3H,0C2H,0C4H]END;BEGINdone_already:=[];a:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  GSread(cmd_text,fname,True);  IF error=0 THEN GSread(cmd_text,dest,True);  IF error=0 THEN BEGIN    from_DDA:=user_info^.fcbs[a].DDA;    to_DDA:=from_DDA;    Strip_dirs(dest,to_DDA,False);    IF error=0 THEN Strip_dirs(fname,from_DDA,False);    IF from_DDA.block.drive<>to_DDA.block.drive THEN error:=0B0H;    same_dir:=Same_DDA(from_DDA,to_DDA);    IF error=0 THEN Wild(from_DDA,fname,Do_ren)  ENDEND;Err_messageEND;BEGINEND.