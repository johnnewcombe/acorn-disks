{ FSRND  FS random access }SEGMENT fsrnd;CONST{$Ifsconst}{$Ifsdecs}{$Ifsext}{$Ifsp1e}{$Ifsp2e}{$Ifsdatae}{$Ifsdire}PROCEDURE new_blk(VAR fbk:FCB);{Allocate a new block at the current pointer position of the file given. NOTE that no check is made that a block already exists - the file is assumed sparse at this point as the routine should not be called otherwise}VARblk_offset,x:Word;bl_des:Block_descrip;p:Dbl_word;acct,blks_reqd:Byte;BEGINWITH fbk DO BEGIN  bl_des.drive:=DDA.block.drive;  bl_des.blk:=0;  {Prepare for later use - account info is in blk 0}  Make4(p,ptr);  blk_offset:=p DIV blk_size; {Block offset in file}  IF p>07FFFFFH THEN error:=035H  ELSE Cache_entry(DDA.block,TRUE);  IF error=0 THEN WITH cache.dir_ent[DDA.offset] DO BEGIN    acct:=account; {Save to work out charging later}{Blocks reqd.        Case   1     not expoded, not going to be.   2     not exploded, will be, new block is in 1st EBlist   3     not exploded, will be, new block is in a different EBlist   1     exploded, relevant EBlist exists   2     exploded, new block is in a new EB list}    IF exploded IN flags THEN BEGIN      IF (blk_list[blk_offset DIV words_per_block]=0) THEN blks_reqd:=2      ELSE blks_reqd:=1      END    ELSE BEGIN      IF blk_offset<16 THEN blks_reqd:=1      ELSE IF blk_offset<words_per_block THEN blks_reqd:=2      ELSE blks_reqd:=3    END;    IF blks_reqd > free_bl[bl_des.drive] THEN error:=0C6H {disc full}    ELSE Cache_entry(bl_des,True); {bring in account info}  END;  IF error=0 THEN WITH cache DO BEGIN    IF account_space[acct] < blks_reqd THEN BEGIN      error:=0ABH;  {internal error no.}      Hex2S(acct,aux_error)    END    ELSE BEGIN      account_space[acct]:=account_space[acct]-blks_reqd;      needs_writing:=True;      Free_bl[bl_des.drive]:=free_bl[bl_des.drive]-blks_reqd;      Cache_entry(DDA.block,True)    END  END;  IF error=0 THEN WITH cache.dir_ent[DDA.offset] DO BEGIN    IF NOT(exploded IN flags) THEN BEGIN      x:=1;      F_blk(bl_des,x); {find a block}      IF blk_offset>15 THEN BEGIN        Disc_wr(Addr(blk_list),32,0,False,bl_des); {move blk_list to new block}        flags:=flags+[exploded];        blk_list[0]:=bl_des.blk;        FOR x:=1 TO 15 DO blk_list[x]:=0;        cache.needs_writing:=True      END      ELSE BEGIN        blk_list[blk_offset]:=bl_des.blk;        curr_blk:=bl_des.blk;     {FCB current block store}        cache.needs_writing:=True      END    END;    IF exploded IN flags THEN BEGIN         {now Exploded, maybe as a result of above code}      bl_des.blk:=blk_list[blk_offset DIV words_per_block];      IF bl_des.blk=0 THEN BEGIN        x:=1;        Fblk(bl_des,x); {find a block}        blk_list[blk_offset DIV words_per_block]:=bl_des.blk;        cache.needs_writing:=True;        Cache_entry(bl_des,False)   {New blk, so don't read it}      END      ELSE Cache_entry(bl_des,TRUE);      IF error=0 THEN BEGIN        x:=1;        F_blk(bl_des,x);        cache.EB_list[blk_offset MOD words_per_block]:=bl_des.blk;        cache.needs_writing:=True;        curr_blk:=bl_des.blk     {FCB current block store}      END    END  ENDENDEND;{$Ifsopen}FUNCTION Fix_ptr(VAR fblk:fcb):Dbl_word;{ Deal with sequence no. & return appropriate pointer.}VARnew_seq:Boolean;p:Dbl_word;BEGINWITH fblk DO BEGIN  new_seq:=Land_B(rx_seq,1)=1;  IF new_seq = (seq IN flags) THEN BEGIN    Make4(p,ptr);    old_ptr:=ptr;  {Operation starts OK, so previous op must be finished}    IF new_seq THEN flags:=flags-[seq] ELSE flags:=flags+[seq]  END  ELSE BEGIN     {Wrong sequence, so re-set pointer}    Make4(p,old_ptr);    Update_blk(fblk,p)  ENDEND;Fix_ptr:=pEND;PROCEDURE B_get;VARtx:RECORD  cmd_rtn_codes:Word;  value:Byte;  flag:ByteEND;bl_des:Block_descrip;p,e:Dbl_word;number:Byte;new_seq:Boolean;BEGIN{NB. Handle is in URD slot}error:=0;number:=FCB_no(mainRx.envir.URD);IF error=0 THEN WITH user_info^ DO WITH fcbs[number] DO BEGIN  p:=Fix_ptr(fcbs[number]);  Make4(e,ext);   {check for read access}  IF error=0 THEN IF Check_flags(fcbs[number],[R])  THEN IF p=e THEN BEGIN  {we are at EOF}    IF err IN flags THEN error:=0DFH;    flags:=flags + [err];   {Flag to indicate EOF error next time round}    tx.value:=0FEH;    tx.flag:=0C0H;  END  ELSE BEGIN    bl_des.blk:=curr_blk;    bl_des.drive:=DDA.block.drive;    IF bl_des.blk=0 THEN tx.value:=0    ELSE Disc_rd(Addr(tx.value),1,p MOD blk_size,bl_des);    IF error=0 THEN BEGIN      p:=Succ(p);      IF (p MOD blk_size)=0 THEN Update_blk(fcbs[number],p);      IF p=e THEN tx.flag:=080H      ELSE tx.flag:=0;      Make3(ptr,p)    END  ENDEND;IF error<>0 THEN Err_messageELSE BEGIN  tx.cmd_rtn_codes:=0;  Ecotx(rx_seq,mainRx.reply,client_stn,Addr(tx),4,number)ENDEND;PROCEDURE B_put;VARbl_des:Block_descrip;p,e:Dbl_word;number:Byte;new_bl,new_seq:Boolean;BEGIN{NB. Handle is in URD slot,value is in CSD}error:=0;number:=FCB_no(mainRx.envir.URD);IF error=0 THEN WITH user_info^ DO WITH fcbs[number] DO BEGIN  p:=Fix_ptr(fcbs[number]);  Make4(e,ext);  IF p>07FFFFFH THEN error:=035H;  IF error=0 THEN IF Check_flags(fcbs[number],[W]) THEN BEGIN   {check for write access}    new_bl:=curr_blk=0;    IF new_bl THEN New_blk(fcbs[number]); {File was sparse or we're at EOF}    IF error=0 THEN BEGIN      bl_des.blk:=curr_blk;      bl_des.drive:=DDA.block.drive;      Disc_wr(Addr(mainRx.envir.CSD),1,p MOD blk_size,NOT new_bl,bl_des);      p:=Succ(p);      IF (p MOD blk_size)=0 THEN Update_blk(fcbs[number],p)      ELSE Make3(ptr,p);      IF p>e THEN Make3(ext,p)    END  ENDEND;Err_messageEND;PROCEDURE MB_get;VARtx:RECORD  cmd_ret_codes:Word;  flag:Byte;  no_of_bytes:Dbl_wordEND;p,e:Dbl_word;a,number:Byte;BEGINerror:=0;tx.cmd_ret_codes:=0;  {used for several replies}number:=FCB_no(mainRx.data[1]);IF error=0 THEN WITH user_info^ DO WITH fcbs[number] DO BEGIN  p:=Fix_ptr(fcbs[number]);  Make4(e,ext);   {check for read access}  IF error=0 THEN IF Check_flags(fcbs[number],[R]) THEN BEGIN    IF mainRx.data[2]=0 THEN BEGIN  {Use supplied new value of PTR# }      p:=0;     {init HI byte}      Move(mainRx.data[6],p,3);      IF p>e THEN error:=0DFH   {EOF}      ELSE Update_blk(fcbs[number],p)    END;    tx.no_of_bytes:=0;   {init Hi byte}    Move(mainRx.data[3],tx.no_of_bytes,3);    IF error=0 THEN BEGIN      Ecotx(rx_seq,mainRx.reply,client_stn,Addr(tx),2,a);      IF tx.no_of_bytes >0 THEN Load_protocol(fcbs[number],tx.no_of_bytes)    END;    IF tx.no_of_bytes > (e-p) THEN BEGIN       tx.no_of_bytes:=e-p;      tx.flag:=080H    END ELSE tx.flag:=0  ENDEND;IF error<>0 THEN Err_messageELSE  Ecotx(rx_seq,mainRx.reply,client_stn,Addr(tx),6,a)END;PROCEDURE MB_put;VARtx:RECORD  cmd_ret_codes:Word;  flag:Byte;  no_of_bytes:Dbl_wordEND;p,e:Dbl_word;a,number:Byte;BEGINerror:=0;tx.cmd_ret_codes:=0;number:=FCB_no(mainRx.data[1]);IF error=0 THEN WITH user_info^ DO WITH fcbs[number] DO BEGIN  p:=Fix_ptr(fcbs[number]);  Make4(e,ext);  IF (mainRx.data[2]=0) AND (error=0) THEN BEGIN  {Use supplied value of PTR# }    p:=0;     {init HI byte}    Move(mainRx.data[6],p,3);    IF p>800000H THEN error:=035H    ELSE Update_blk(fcbs[number],p)  END;  IF error=0 THEN IF Check_flags(fcbs[number],[W]) THEN BEGIN    tx.no_of_bytes:=0;   {init Hi byte}    Move(mainRx.data[3],tx.no_of_bytes,3);    tx.flag:=0;    IF p +tx.no_of_bytes > e THEN BEGIN {extend file}      e:=p +tx.no_of_bytes;      IF e>800000H THEN error:=035H      ELSE Make3(ext,e)    END;    IF error=0 THEN    IF tx.no_of_bytes>0 THEN Save_protocol(fcbs[number],tx.no_of_bytes,True)    ELSE Err_message   {Spurious reply as per protocol}  ENDEND;IF error<>0 THEN Err_messageELSE  Ecotx(rx_seq,mainRx.reply,client_stn,Addr(tx),6,a)END;BEGINEND.