{ FSlogon  File Server *I AM command }{Include file for FSuser}Procedure I_am(VAR cmd_text:min_string);VARaS,real_name:Min_string;pass_ent:RECORD  user_id:ARRAY[0..9] OF Byte;  password:ARRAY[0..9] OF Byte;  boot:Byte;  flags:SET of user_flags;  spare:ARRAY[22..31] OF Byte;  owner:SET OF ByteEND;tx:RECORD cmd_code,rtn_code,URD,CSD,LIB,boot:Byte END;new_DDA:Disc_address;this:user_ptr;default_user:Word;default_drive,b:Byte;found,go_on:Boolean;BEGINerror:=0;IF user_info^.stn=client_stn THEN Do_logoff;default_user:=0; {Set to entry no. of default user in 1st pw file that has one}this:=spare_users;IF spare_users=Nil THEN error:=184 {Too many users}ELSE WITH this^ DO BEGIN  {Initialise the user while still on the free chain}  {skip stn & get hold of userID}  b:=1;  WHILE (cmd_text[b]<'A') AND (b<=Length(cmd_text)) DO b:=succ(b);  MidS(cmd_text,b-1,min_size);  GSread(cmd_text,real_name,True);   {for delimiters}  IF messag THEN BEGIN    Wrt('I AM ');    Wrtln(real_name)  END;  WITH pass_blk.DDA DO BEGIN    WITH block DO BEGIN      blk:=0;      drive:=255  {Inc_B is circular}    END;    offset:=2  END;  IF NOT Legal(real_name,b,go_on) THEN error:=0CCH {Bad name}  ELSE WITH pass_blk DO REPEAT    Inc_B(DDA.block.drive);    bl_des.drive:=DDA.block.drive;    Update_blk(pass_blk,0);  {Find 1st blk of passwd file}    bl_des.blk:=curr_blk;    IF curr_blk=0 THEN found:=True {no password file - give sys priv access}    ELSE BEGIN      IF default_user=0 THEN BEGIN {No default user found yet - try this drive}        Disc_rd(Addr(default_user),2,01EH,bl_des);  {bytes 0-1D are hash table}        default_drive:=DDA.block.drive      END;      Disc_rd(Addr(pass_ptr),2,b*2,bl_des);  {b contains hashing index}      Dec_W(pass_ptr);      REPEAT        Inc_W(pass_ptr);        Update_blk(pass_blk,pass_ptr*64);        bl_des.blk:=curr_blk;        Disc_rd(Addr(pass_ent),64,(pass_ptr MOD ents_per_block)*64,bl_des);        found:=Match(real_name,Addr(pass_ent.userID),go_on);      UNTIL found OR (NOT go_on) OR (bl_des.blk=0)    END  UNTIL found OR (DDA.block.drive=no_discs);  IF NOT found THEN BEGIN {Try default user}    IF default_user=0 THEN error:=0BCH  {User not known}    ELSE WITH pass_blk DO BEGIN      pass_ptr:=default_user;      DDA.block.drive:=default_drive;      Update_blk(pass_blk,default_user*64);      WITH bl_des DO BEGIN        blk:=curr_blk;        drive:=default_drive      END;      Disc_rd(Addr(pass_ent),64,(pass_ptr MOD ents_per_block)*64,bl_des)    END  END;  IF error=0 THEN BEGIN    IF bl_des.blk=0 THEN BEGIN {Missing or malformed password file}      pass_ptr:=0;      owner:=[0..255];      flags:=[sys_priv];      Wrtln('No password file')    END    ELSE BEGIN      GS_read(cmd_text,aS,True); {password to aS}      IF Pass_OK(aS)      THEN IF NOT Match(aS,Addr(pass_ent.password),go_on) THEN error:=0BBH        ELSE BEGIN        pass_drive:=pass_blk.DDA.block.drive;        flags:=pass_ent.flags;        owner:=pass_ent.owner;        tx.boot:=pass_ent.boot;        Move(pass_ent.userID,fcbs[1].curr_blk,10); {Save for *USERS etc}        GetS_cr(Addr(pass_ent.userID),10,real_name)      END  {Name may have wildcards - get full vers for CSD lookup}    END;    stn:=client_stn;    printer:=0;  {Use default printer}    IF error=0 THEN BEGIN {Move user onto the active user chain}      spare_users:=next_user;      next_user:=user_info; {Add to head of chain}      user_info:=this    END  END;  IF error=0 THEN BEGIN {open URD, LIB}{Note that errors are non-fatal from here on}    new_DDA.block.drive:=pass_drive;    new_DDA.block.blk:=0; {This is the root}    new_DDA.offset:=0;    For b:=1 to 2 DO With fcbs[b] DO BEGIN      flags:=[in_use]; {Not write_access Otherwise no-one else can open it}      DDA:=new_DDA  {in case lookup fails ahead}    END;    Find(real_name,new_DDA);    IF error=0 THEN fcbs[1].DDA:=new_DDA; {Set URD}    new_DDA.block.drive:=0;        {block doesn't matter, as $ is specified}    real_name:='$.LIBRARY';    Strip_dirs(real_name,new_DDA,True);    IF error=0 THEN fcbs[2].DDA:=new_DDA {Set Lib}    ELSE error:=0     {Failure to find LIB does not prevent log on}  ENDEND;IF error<>0 THEN Err_messageELSE WITH tx DO BEGIN  cmd_code:=5;  rtn_code:=0;  URD:=1; {URD handle(fixed)}  CSD:=1; {CSD handle (may change later)}  LIB:=2; {LIB handle (fixed)}  Ecotx(0,mainRX.reply,client_stn,addr(TX),6,b)ENDEND;