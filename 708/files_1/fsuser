{ FSUSER  File Server User Management }SEGMENT fsuser;CONST{$Ifsdecs}{$Ifsext}{$Ifsp1e}{$Ifsdire}{$Ifsdatae}{$Ifsrnde}{$IFSP3e}FUNCTION Pass_OK(VAR passS:Min_string):Boolean;{Check for valid password & set error as appropriate if invalid. Zero error otherwise}VARb:Byte;wild:Boolean;BEGINPass_OK:=False;IF NOT Legal(passS,b,wild) THEN error:=0B9HELSE IF wild THEN error:=2 {Bad wildcard}ELSE BEGIN  error:=0;  Pass_OK:=TrueENDEND;Procedure Do_logoff;VARa,b:Byte;this:user_ptr;BEGIN{If here, the user is definitely already logged on}this:=user_info;user_info:=this^.next_user; {Remove from head of chain}this^.next_user:=spare_users;spare_users:=this; {Add to free chain}{Close any open files}WITH this^ DO FOR a:=1 TO 8 DO Close(fcbs[a])END;PROCEDURE Log_off;BEGINDo_logoff;Err_message {error set in <Close>, called by <Do_logoff>}END;PROCEDURE Star_pass(VAR cmd_text:Min_string);CONSTpass_offset=10;  {Offset in password file entry to password text}VARpassS:Min_string;store:ARRAY[0..9] OF Byte;bool:Boolean;BEGINIF messag THEN Wrtln('PASS');GS_read(cmd_text,passS,True); {Get old password}IF Pass_OK(passS) THEN WITH user_info^ DO IF pass_ptr=0 THEN error:=3  ELSE BEGIN  pass_blk.DDA.block.drive:=pass_drive;  bl_des.drive:=pass_drive;  Update_blk(pass_blk,pass_ptr*64);  bl_des.blk:=pass_blk.curr_blk;  Disc_rd(addr(store),10,(pass_ptr MOD ents_per_block)*64 +pass_offset,bl_des);  IF Not Match(passS,Addr(store),bool) THEN error:=0BBH  ELSE BEGIN    GS_read(cmd_text,passS,True); {get new password}    IF Pass_OK(passS) THEN BEGIN      PutS_cr(Addr(store),passS,10);      Disc_wr(addr(store),10,(pass_ptr MOD ents_per_block)*64 +pass_offset,True      ,bl_des)    END  ENDEND;Err_messageEND;PROCEDURE Read_users;CONSTmax_ents=16;VARtx:RECORD  cmd_ret_codes:Word;  qty_found:Byte;  data:ARRAY [1..max_ents] OF RECORD    station:Word;    id:ARRAY [1..10] OF Byte;    priv:Boolean  ENDEND;b:Byte;aS:Min_string;this_user:user_ptr;BEGINthis_user:=user_info;{ mainRx.data[1] is which is the 1st user to get info on}WHILE (mainRx.data[1] > 0) AND (this_user <> Nil) DO BEGIN  Dec_B(mainRx.data[1]);  this_user:=this_user^.next_userEND;IF mainRx.data[2] > max_ents THEN mainRx.data[2]:=max_ents; {mainRx.data[2] is no of ents to get}tx.qty_found:=0;WHILE (tx.qty_found < mainRx.data[2]) AND (this_user <> Nil) DO BEGIN  Inc_B(tx.qty_found);  WITH this_user^,tx.data[tx.qty_found] DO BEGIN    GetS_cr(Addr(fcbs[1].curr_blk),10,aS);    Pad(aS,10);    PutS(Addr(id),aS);  {Store in tx block}    station:=stn;    priv:=sys_priv IN flags;    this_user:=next_user  ENDEND;tx.cmd_ret_codes:=0;Ecotx(0,mainRX.reply,client_stn,addr(tx),tx.qty_found*13+3,b)END;PROCEDURE Find_user;VARtx:RECORD  cmd_ret_codes:Word;  priv:Boolean;  station:Word;END;aS:Min_string;bool:Boolean;this_user:user_ptr;BEGINGetS_cr(Addr(mainRx.data),min_size,aS); {Get name}error:=0;this_user:=user_info;WHILE error=0 DO WITH this_user^, tx DO BEGIN  IF Match(aS,Addr(fcbs[1].curr_blk),bool) THEN BEGIN    station:=stn;    priv:=sys_priv IN flags;    cmd_ret_codes:=0;    error:=1    {special flag value}  END  ELSE BEGIN    this_user:=next_user;    IF this_user=Nil THEN error:=0AEH  {User not logged on}  ENDEND;IF error=1 THEN Ecotx(0,mainRX.reply,client_stn,addr(tx),5,error)ELSE Err_messageEND;FUNCTION User_ok:BOOLEAN;VARthis,prev:user_ptr;BEGINprev:=Nil;this:=user_info;WHILE (this^.stn<>client_stn) AND (this <> Nil) DO BEGIN  prev:=this;  this:=this^.next_userEND;IF this=Nil THEN User_ok:=FalseELSE BEGIN  User_ok:=True;  IF prev<>Nil THEN BEGIN {Not already @ head}    prev^.next_user:=this^.next_user;    this^.next_user:=user_info;    user_info:=this  ENDENDEND;PROCEDURE Set_opt;CONSTboot_offset=20;  {Offset to boot option in PWfile entry}BEGINWITH user_info^,pass_blk DO IF pass_ptr=0 THEN error:=3ELSE BEGIN  DDA.block.drive:=pass_drive;  bl_des.drive:=pass_drive;  Update_blk(pass_blk,pass_ptr*64);  bl_des.blk:=curr_blk;  Disc_wr(addr(mainRx.data),1,(pass_ptr MOD ents_per_block)*64 +boot_offset  ,True,bl_des)END;Err_messageEND;Procedure I_am(VAR cmd_text:min_string);VARfound,go_on:Boolean;aS,real_name:Min_string;b:BYTE;pass_ent:RECORD  user_id:ARRAY[0..9] OF Byte;  password:ARRAY[0..9] OF Byte;  boot:Byte;  flags:SET of user_flags;  spare:ARRAY[22..31] OF Byte;  owner:SET OF ByteEND;tx:RECORD cmd_code,rtn_code,URD,CSD,LIB,boot:Byte END;new_DDA:Disc_address;this:user_ptr;BEGINerror:=0;IF user_info^.stn=client_stn THEN Do_logoff;this:=spare_users;IF spare_users=Nil THEN error:=184 {Too many users}ELSE WITH this^ DO BEGIN  spare_users:=next_user;  next_user:=user_info; {Add to head of chain}  user_info:=this;  {skip stn & get hold of userID}  b:=1;  WHILE (cmd_text[b]<'A') AND (b<=Length(cmd_text)) DO b:=succ(b);  MidS(cmd_text,b-1,min_size);  GSread(cmd_text,real_name,True);   {for delimiters}  IF messag THEN BEGIN    Wrt('I AM ');    Wrtln(real_name)  END;  WITH pass_blk.DDA DO BEGIN    WITH block DO BEGIN      blk:=0;      drive:=255;  {Inc_B is circular}    END;    offset:=2  END;  IF NOT Legal(real_name,b,go_on) THEN error:=0CCH {Bad name}  ELSE WITH pass_blk DO REPEAT    Inc_B(DDA.block.drive);    bl_des.drive:=DDA.block.drive;    Update_blk(pass_blk,0);  {Find 1st blk of passwd file}    bl_des.blk:=curr_blk;    IF pass_blk.curr_blk=0 THEN found:=False {no password file}    ELSE BEGIN      Disc_rd(Addr(pass_ptr),2,b*2,bl_des);  {b contains hashing index}      Dec_W(pass_ptr);      REPEAT        Inc_W(pass_ptr);        Update_blk(pass_blk,pass_ptr*64);        bl_des.blk:=curr_blk;        Disc_rd(Addr(pass_ent),64,(pass_ptr MOD ents_per_block)*64,bl_des);        found:=Match(real_name,Addr(pass_ent.userID),go_on);      UNTIL found OR (NOT go_on) OR (bl_des.blk=0)    END  UNTIL found OR (DDA.block.drive=no_discs);  IF error=0 THEN BEGIN    IF found THEN BEGIN      GS_read(cmd_text,aS,True); {password to aS}      IF Pass_OK(aS)      THEN IF NOT Match(aS,Addr(pass_ent.password),go_on) THEN error:=0BBH        ELSE BEGIN        pass_drive:=pass_blk.DDA.block.drive;        flags:=pass_ent.flags;        owner:=pass_ent.owner;        tx.boot:=pass_ent.boot;        Move(pass_ent.userID,fcbs[1].curr_blk,10); {Save for *USERS etc}      END    END    ELSE BEGIN {Not in password file}      IF bl_des.blk=0 THEN BEGIN {Missing or malformed password file}        owner:=[0..255];        flags:=[sys_priv];        Wrtln('No password file')      END      ELSE BEGIN        owner:=[];        flags:=[]      END;      pass_drive:=0;      pass_ptr:=0;  {0 is index - used to indicate not in file}      tx.boot:=0;    {opt 0 - do nothing}      PutScr(Addr(fcbs[1].curr_blk),real_name,10)  {store user ID}    END  END;  stn:=client_stn;  IF error=0 THEN BEGIN {open URD, LIB}    new_DDA.block.drive:=pass_drive;    new_DDA.block.blk:=0; {This is the root}    new_DDA.offset:=0;    For b:=1 to 2 DO With fcbs[b] DO BEGIN      flags:=[in_use]; {Not write_access Otherwise no-one else can open it}      DDA:=new_DDA  {in case lookup fails ahead}    END;    Find(real_name,new_DDA);    IF error=0 THEN fcbs[1].DDA:=new_DDA; {Set URD}    new_DDA.block.drive:=0;        {block doesn't matter, as $ is specified}    real_name:='$.LIBRARY';    Strip_dirs(real_name,new_DDA,True);    IF error=0 THEN fcbs[2].DDA:=new_DDA {Set Lib}    ELSE error:=0     {Failure to find LIB does not prevent log on}  ENDEND;IF error<>0 THEN Err_messageELSE WITH tx DO BEGIN  cmd_code:=5;  rtn_code:=0;  URD:=1; {URD handle(fixed)}  CSD:=1; {CSD handle (may change later)}  LIB:=2; {LIB handle (fixed)}  Ecotx(0,mainRX.reply,client_stn,addr(TX),6,b)ENDEND;BEGINEND.