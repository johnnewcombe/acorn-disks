
	LD	(IY+2),0FFH	;Error during read, so cache now holds junk.
	LD	(IY+3),0FFH	;Mark as empty.
	RET




;RWSEC
;Read/Write sector to/from disk
;
;On entry:
;	BC	RAM address to read/write
;	 D	Read flag (FF-read,0-write)
;	 E	Disk number
;	HL	sector no.
;
;On exit:
; A	Error code (0 = OK, 1=error)
;	(errloc) also updated
; IX,IY	Preserved

rwsec:
	PUSH	BC

	CALL	trkreg		;Init track reg & pointer to trk table

;Convert drive number into drive bits

	XOR	A
	LD	B,E
	INC	B		;As driverack number (div 2)
	JR	NC,side0
	SET	sidsel,E	;Other side
side0:	INC	D		;D now 0 for read, 1 for write
	LD	D,rdsec
	JR	Z,rwdisc
	LD	D,wrsec

;drop through


;RWDISC - read, write, format disc.
;
; On entry :
;	BC	Ram address of data
;	D	FD command (expected to be read sec, write sec, or write trk)
;	E	drive sel, side sel, 5/8 inch to suit dskctl port
;	H	track
;	L	sector if reqd.
;
; <trkreg:> assumed to have been called
;
; On exit :
;	A	=0 if no error, =1 otherwise
; ALL OTHER REG numbers start at 0
	SCF
cdrnol:	RLA
	DJNZ	cdrnol
	LD	E,A		;has a single bit set in it.

;Convert sector number HL into track H & sector L

	LD	A,(inches)	;1 bit per drive - =1 for 8inch
	AND	E
	JR	Z,div5		;5" have 5 sec/trk

	SET	inch8,E		;Set 8" bit in value to put in dskctl port

;Divide by eight

	LD	A,L
	AND	7		;Remainder MOD 8

	ADD	HL,HL		;*2
	ADD	HL,HL		;*4
	ADD	HL,HL		;*8
	ADD	HL,HL		;*16
	ADD	HL,HL		;*32
				; div 8 <=> *32 DIV 256
	LD	L,A
	JR	dundiv	


;Divide by fiveוווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווו - by subtracting 5*2^n, n=7..0  (max 160 tracks)

div5:	XOR	A		;to receive bits of result

	LD	BC,-280H	;280H = 5*128 decimal
tscon1:	ADD	HL,BC
	JR	C,tscon0	;carry => HL-BC positive
	SBC	HL,BC		;repair HL (carry cleared)
tscon0:	RLA			;Insert bit from carry into A
	SRA	B
	RR	C		;Reduce 'n'
	JP	NC,tscon1	;Carry => part of the '5' has fallen out

	LD	H,A		;Swap regs - so correct for output

dundiv:	POP	BC

; Now have H=trk, L=sector, D=read flag, E=drive bits, BC=address

	SRL	H		;Modify t	OUT	(paport),A

	LD	A,(IY+3)	;Drive in hi 2 bits
	RLCA
	RLCA
	AND	03H		;Now back in right place
	LD	L,A		;NB. H=0
	LD	BC,drvtab	;Logical to physical translation table
	ADD	HL,BC
	LD	E,(HL)

	LD	L,(IY+2)	;blockno.
	LD	A,(IY+3)	; Hi byte also holds drive
	AND	3FH		;not any more
	LD	H,A		;HL=block no =sector no.

	LD	BC,secbuf	;Ram address where paged RAM appears
	PUSH	DE
	CALL	rwsec
	POP	DE
	LD	C,A		;Error code (=0 for no error)


	LD	A,C		;=0 if no error
	AND	D		;=0 if write
	RET	Z	help
	JP	start


ioinit:	DI
	CALL	dkinit		;Stop drives

;RTC seems to need time to wake up - try waiting till goes busy

wbsy:	IN	A,(3CH)
	OR	0F0H
	INC	A		;is zero => busy
	JR	NZ,wbsy


	LD	A,dskfre	;LED on
	OUT	(leds),A

	IN	A,(status)
	BIT	chdisc,A	;Reset statid if switch pressed at power on
	CALL	Z,resets

	LD	HL,iojtbl	;Init i/o jump table
	LD	DE,iojmps
	LD	BC,ioj1-iojtbl
	LDIR

	LD	A,047H		;Init baud rate
	OUT	(ctc2),A
	LD	A,3
	OUT	(ctc2),A

	LD	HL,retbyt
	LD	(eventv),
rda	EQU	0
tbe	EQU	2
cts	EQU	5

rdabit	EQU	1

status	EQU	34H
chdisc	EQU	2		;switch - active lo

paport	EQU	34H		;ROM on/off, RAM page, etc etc
pagon	EQU	2		;**VALUE** to output (ie it's bit1)
romoff	EQU	1

leds	EQU	35H		;LEDs are active hi
dskfre	EQU	080H
online	EQU	040H

pprint	EQU	036H		;Printer output

ctc	EQU	038H
ctc0	EQU	ctc+0
ctc1	EQU	ctc+1
ctc2	EQU	ctc+2
ctc3	EQU	ctc+3

fdctrl	EQU	4		;WD2793 control reg

dsflag	EQU	97		;Offset to double sided flag - means here
				;that iHL

	CALL	initmd

	LD	HL,0		;flag to tell FCONOT to wait
	CALL	termtx


	XOR	A
	CALL	loinit		;init econet

	LD	HL,0
	LD	(0F800H),HL	;Init debug, message copies for FS

	CALL	ini423

;	Wait for switch to be pressed before trying to boot FS

	XOR	A		;LED state
ledlop:	XOR	dskfre
	OUT	(leds),A
	LD	D,A		;Save leds
swloop:	IN	A,(status)
	BIT	chdisc,A
	JR	Z,presed
	DEC	HL
	LD	A,L
	OR	H
	JR	NZ,swloop
	LD	A,D
	JR	ledlop

presed:	LD	B,0
deboun:	IN	A,(status)
	BIT	chdisc,A
	JR	Z,pret is an FS boot disc!


;ASCII
cr	EQU	13
lf	EQU	10





;
;** ENTER HERE AFTER RESET**
;
; This code is at 0100H

;	JP	pascal		;Supplied by prolink - jumps to PASCAL
				;entry point.

;	Reset statid

resets:	LD	A,1		;-Test, Clock on
	LD	D,optreg
	CALL	writck

	LD	A,dftstn
	LD	D,stnreg
	CALL	writck
	RET



; PROCEDURE SRL_mon;
;
; Save context for re-start & enter monitor

srlmon:	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	(stksav),SP

	LD	A,online
	OUT	(leds),A
	CALL		;Set bit A in A
	INC	B
	LD	C,B
	SUB	A
	SCF
getbl1:	RLA
	DJNZ	getbl1

	POP	DE
	PUSH	BC
	EX	DE,HL
	LD	B,(HL)		;BC:= address of map
	DEC	HL
	LD	C,(HL)

	IF	c.on		;** Range check block **

	PUSH	AF		;Check map exists
	LD	A,B
	AND	C
	INC	A
	JP	Z,maperr

	PUSH	HL		;Check valid block number
	DEC	HL
	LD	A,(HL)
	DEC	HL
	LD	L,(HL)
	LD	H,A
	CP	A
	SBC	HL,DE
	JP	C,ranerr

	POP	HL
	POP	AF

	ENDIF			;** End of range check **

	EX	DE,HL
	ADD	HL,BC
	POP	BC
	LD	B,C
	RET


	IF	c.new entry, C is previous page, E is new page
;	On exit, carry set, A=(page), B=0, HL=^previous ent

setpag:	LD	HL,cacmap
	LD	B,0			;BC now = previous page no.
	ADD	HL,BC

	LD	A,(IY+0)
	LD	(HL),A			; previous^.next:=new_ent^.next
	LD	A,(page)
	LD	(IY+0),A		; new_ent^.next:=head_ptr
	LD	A,E
	LD	(page),A		; head_ptr:=new_ent

	SCF
	RET







;RWBLK
;Read/Write block to/from disk
;
;
;On entry:
; D	Read flag (&FF -> read, 0 -> write)
; IY	Points to map entry
;(page)	**NOT USED** (on

;Bad map number / map not initialized

maperr:	error	'Bad map number'

;Block number out of range

ranerr:	error	'Duf block number'

	ENDIF




;PROCEDURE fblk (VAR block: block_descrip; VAR no_block: WORD);
;
;Attempt to find up to no_block blocks starting from block_descrip

fblk:	POP	HL		;Return address
	POP	BC		;no_block
	EX	(SP),HL		;block_descrip
	PUSH	IX
	PUSH	BC

fstart:	LD	A,(HL)		;Drive
	INC	HL
	PUSH	HL		;Save address of block number
	LD	E,(HL)		;get block number
	hence we can write blocks not at head of chain)
;
;On exit:
; C	Error code (0 = OK)
;	(errloc) also updated
; (IY)	Needs writing flag cleared always. Blockno zapped if read error

rwblk:	LD	(IY+1),0FFH	;Clear needs writing flag

	PUSH	IY
	POP	HL		;Calculate page no. from table offset
	LD	BC,cacmap	;Start of table
	OR	A		;Clear carry
	SBC	HL,BC
	LD	A,L		;the answer (NB. 1K pages, so low 2 bits =0)
				;The fact that H=0 is assumed later.
	OR	pagon		;Bit(s) to turn on paged RAM
	LD	(copy),A
Z,setblk		;Not required, so just insert blkno.
	LD	D,0			;r/w flag set to write
	CALL	rwblk
setblk:	POP	HL			;Get back blockno.
	LD	(IY+2),L
	LD	(IY+3),H		;Store in map
	OR	A			;Clear carry <=> not found
	RET


;	Found already in cache, so set carry for return & drop through
;	to move to head of chain if not already there.

found:	LD	A,(page)
	CP	E			;Test for already head of chain
	SCF
	RET	Z			;Return to save looping up chain

;	Move the new entry to the top of the chain
;	IY points to ce type 1 status
	CALL	docmd

inid2:	DEC	HL		; 6t
	LD	A,L		; 4t
	OR	H		; 4t
	JR	Z,nodisc	; 7t	Give up
	EX	(SP),HL		;19t	Increase timeout
	EX	(SP),HL		;19t
	NOP			; 4t
	IN	A,(fdstat)	;11t	Wait for drive to go rdy 
	BIT	notrdy,A	; 8t	<=> up to speed
	JR	NZ,inid2	;12t =94t *65536 <=> 1.03 seconds

	DI			;For software timing

inid6:	IN	A,(fdstat)
	BIT	index,A		;Wait for index hole also
	JR	Z,inid6

inid3:	IN	A,(fdstat)	;Start timing at end of index
	BIT	index,A
	JR	NZ,inid3

	LD	HL,0		;Tloc:	POP	HL		;Return address
	EX	(SP),HL		;Blk address

	LD	A,(HL)		;Get drive
	INC	HL
	LD	B,(HL)		; & block number
	INC	HL
	LD	H,(HL)
	LD	L,B

	tmess	<frblk0,HL,alblk1,AF,crlf>

	CALL	getblk
	OR	(HL)
	LD	(HL),A
	RET



;PROCEDURE alloc (blk: block_descrip);

alloc:	POP	HL		;Return address
	EX	(SP),HL		;Blk address

	LD	A,(HL)		;Get drive
	INC	HL
	LD	B,(HL)		; & block number
	INC	HL
	LD	H,(HL)
	LD	L,B

;	tmess	<alblk0,HL,alblk1,AF,crlf>

	CALL	getblk
	CPL
	AND	(HL)
	LD	(Himer
inid4:	IN	A,(fdstat)	; 11T/12T if in ROM
	INC	HL		; 6T/7T
	BIT	index,A		; 8T/10T
	JR	Z,inid4		; 12T/13T except when dropping through
				; total = 37T/42T per loop
	EI

; 8" runs at 6 revs/sec =   1E6 T per rev = 27027 iterations of loop
; 5" runs at 5 revs/sec = 1.2E6 T per rev = 32432 iterations of loop
; Hence mid pt. = 29729, just over &7400
; IF in rom:
; 8"=23809, 5"=28571 iterations mid pt=26190 ~=&6600

	LD	A,H

	IF	inrom
	CP	067H
	ELSE
	CP	075H		;Carry if 8"
	ENDIF

	LD	CL),A
	RET



;GETBLK
;Converts Map number & Block Number into address and bit number
;
;On entry:
; A	Map number
; HL	Block number
;
;On exit:
; A	Byte with bit set
; B	1 - 8 => Bit number
; DE	Points to low byte of address in MAPPTR (length @(DE-2))
; HL	Address of byte

getblk:	PUSH	HL

	CP	noofdr
	JP	NC,maperr

	ADD	A,A
	ADD	A,A
	LD	C,A
	LD	B,0
	LD	HL,mapptr+3
	ADD	HL,BC
	EX	(SP),HL

	LD	A,L		;HL/8, A=Remainder
	AND	7
	SRL	H
	RR	L
	SRL	H
	RR	L
	SRL	H
	RR	L

	LD	B,A,0		;No bit set
	JR	NC,inid5
	LD	C,E		;Get drive bit
	SET	inch8,E

inid5:	LD	HL,inches
	LD	A,E
	CPL			;Clear bit for this drive
	AND	(HL)		;get other drive bits
	OR	C		;Set our bit as appropriate
	LD	(HL),A	
	XOR	A		;Indicate success
	INC	A
nodisc:	LD	HL,ticloc	;Entered here with A=0 if timed out
	LD	(HL),mtrtim	;Stop drive after usual time
	POP	BC
	POP	HL
	RET





;
;  ****** BIT MAP MANAGEMENT CODE STARTS HERE *************
;
;


;PROCEDURE dalloc (blk: block_descrip);

dal
	RET	Z		;If no error, we got here from JR Z
 				;otherwise Z is set from DEC of retry counter
				;=> exit if no error or max retries reached.
	LD	A,0FFH		;Clear track reg to force a seek0 next time
	OUT	(fdtrk),A
	JP	retry


nmird:	EXX			;NMI routines for read or write
	EX	AF,AF'
	INI
	EX	AF,AF'
	EXX
	RETN

nmiwr:	EXX
	EX	AF,AF'
	OUTI
	EX	AF,AF'
	EXX
	RETN





;TRKREG - set up track register from table
;
; On entry :
;	E	Drive no
;
; On exit :
;	A	current track
;	track issued
;
; Preserves all regs
; delay is 56 us (allowing for 5" single density)

fdcdel:	PUSH	BC		;Total 336T to burn. Excluding the DJNZ,
	LD	B,290/13	;we have 55T, so 281 left
	DJNZ	$
	POP	BC
	RET



; INIDRV - initialise for 1 drive.
; Sets up 5/8 inch flag by measuring the index hole frequency
;
; On entry :
;	E	Drive number
; On exit :
;	E	Drive bits suitable for dskctl latch
;	AF	=0 if no drive not ready, =1 otherwise
;	Other regs preserved

inidrv:	PUSH	HL
	PUSH	BC

;Convertreg in FDC loaded from table
;	(trkptr) holds address in track table
;	All regs preserved except AF

trkreg:	PUSH	HL
	LD	A,D		;Save D
	LD	D,0
	LD	HL,trkno
	ADD	HL,DE
	LD	D,A		;Restore
	LD	(trkptr),HL
	LD	A,(HL)
	OUT	(fdtrk),A
	POP	HL
	RET


; SEEKZ - seek trk 0
;
; Preserves all regs except AF.
; Track not verified.
; Assumes drive selected.

seekz:	LD	A,frcint	;Force int <=> force type 1 status
	CALL	docmd
	IN	A,(fdstat)
	BIT	trk0,A
	JR	Z,noinc		;No track inc unless already at tr drive number into drive bits

	XOR	A
	LD	B,E
	INC	B		;As drive numbers start at 0
	SCF
inid1:	RLA
	DJNZ	inid1
	LD	E,A		;has a single bit set in it.


	OUT	(dskctl),A	;Select drive
	LD	(dkctlm),A	;& update copy

	LD	HL,ticloc
	DI			;In case it stops during test
	LD	A,(HL)
	LD	(HL),080H	;Wind up motor	(forever)
	EI
	SLA	A		;=0 if previously stopped, >1 otherwise
	LD	L,A		;Very short timeout if already running
	LD	H,0		;otherwise about 1s
	IN	A,(mstart)

	LD	A,frcint	;Force int <=> fork 0
	LD	A,trkinc	;Move head away so that it is re-positioned
	CALL	docmd
noinc:	LD	A,home
;	JP	docmd		;Drop through



; DOCMD - execute FDC command & wait for completion
;
; On entry :
;	A	command byte
;
; On exit :
;	A	status reg - including error bits
;
; All regs except AF preserved

docmd:	OUT	(fdctrl),A
	CALL	fdcdel		;Delay for FDC status to be valid
cmdwai:	IN	A,(fdstat)
	BIT	busy,A
	JR	NZ,cmdwai
	RET	


; FDCDEL - delay time for FDC status reg to become valid after command NZ,nonfat
	LD	DE,fatmsg	;Fatal disc error
nonfat:	LD	A,(mesflg)
	OR	A
	JR	Z,nomsg		;Test for debug flag
	CALL	pmess
	POP	AF
	PUSH	AF		;Get error number
	CALL	cahex
nomsg:	POP	AF		;Restore Z flag - NZ => retry worthwile


	LD	A,1		;Return TRUE, indicating error

noerr:	EXX
	POP	BC
	POP	HL
	EXX
	EX	AF,AF'
	;AF' already corrupt, so this is a convenient place to set the
	;motor stop timer
	LD	A,mtrtim
	LD	(ticloc),A

	POP	AF		;Retore user's AF'
	EX	AF,AF'
	
	POP	BC
	POP	HL
	POP	DE

iojmps:

cinst:	DS	3
rcin:	DS	3
cotst:	DS	3
rcout:	DS	3

stksav:	DS	2		;Save area for main program stack

wrk:	DS	1		;Used to set statid


	COMMON	/error/

errloc:	DS	1

	END
tc:	LD	A,C
cout:	PUSH	AF
cout1:	CALL	cotst
	JR	Z,cout1
	POP	AF
	JP	rcout



;NON-routines:

notify:
remchr:
setrem:

retbyt:	RET

$memry:	DS	2		;DO NOT put this in DSEG!



	DSEG

nmivec:	DS	20		;Code inserted here

eventv:	DS	2

	cr,lf,"&",0
	POP	AF
	JP	prhex





; I/O routines for Z80 FS





; FUNCTION Inkey(VAR ch:Char):Boolean;

inkey:	CALL	cinst
	LD	B,0		;B:=False
	JR	Z,inkXit	;No char avail
	CALL	rcin		;Return char in A
	CP	6		;Ctrl-F
	LD	B,1		;B:=True
	JR	NZ,inkXit
	CALL	srlmon
	LD	B,0		;Return no char if continued from srlmon
inkXit:	POP	HL
	POP	DE		;Address of <ch>
	LD	(DE),A
	LD	A,B		;result
	JP	(HL)		;Return


; PCHAR
;
; Print character in E
; Preserves all regs.

pchar:	PUSH	AF
l FCONOT to wait
	CALL	termtx


	XOR	A
	CALL	loinit		;init econet

	LD	HL,0
	LD	(0F800H),HL	;Init debug, message copies for FS

	CALL	ini423

;	Wait for switch to be pressed before trying to boot FS

	XOR	A		;LED state
ledlop:	XOR	A,dskfre
	OUT	(leds),A
	LD	D,A		;Save leds
swloop:	IN	A,(status)
	BIT	chdisc,A
	JR	Z,presed
	DEC	HL
	LD	A,L
	OR	H
	JR	NZ,swloop
	LD	A,D
	JR	ledlop

presed:	LD	B,0
deboun:	IN	A,(status)
	BIT	chdisc,A
	JR	Z,presed	;Wait for release
	DJNZ	deboun		;Debo	LD	A,E
	CALL	cout
	POP	AF
	RET



;IO jump table

iojtbl	EQU	$

;This jump table is copied to RAM at iojmps:
; then poked if Remoted

	JP	ist423
	JP	cin423
	JP	ost423
	JP	cot423

ioj1	EQU	$

cin:	CALL	cinst
	JR	Z,cin
	JP	rcin

coutc:	LD	A,C
cout:	PUSH	AF
cout1:	CALL	cotst
	JR	Z,cout1
	POP	AF
	JP	rcout



;NON-routines:

notify:
remchr:
setrem:

retbyt:	RET

$memry:	DS	2		;DO NOT put this in DSEG!



	DSEG

nmivec:	DS	20		;Code inserted here

eventv:	DS	2
mer for head load
	OUT	(ctc0),A	;ctc0 controls head load timing (from 256Hz)
	LD	A,14		; time constant  13*1/256 =50.78ms
	OUT	(ctc0),A

	IN	A,(mstart)	;Motor start also clears 'head loaded' flipflop

samedr:	LD	A,E
	OUT	(dskctl),A	;Select drive
	LD	(dkctlm),A	;Update copy

	DI			;In case clock ticks while testing <ticker>
	LD	A,(ticloc)
	OR	A		;Zero => motor already stopped.
	JR	NZ,going
	IN	A,(mstart)	;start the motor
going:	LD	A,080H		;Prevent it from stopping under clock ticks
	LD	(ticl;port no
	EXX

;	Install appropriate NMI rtn

	LD	A,D		;Command
	BIT	5,D		;Test for read or write command
	LD	HL,nmird	;Code for read
	JR	Z,nmi1
	LD	HL,nmiwr	;Code for write	
nmi1:	LD	DE,nmivec
	LD	BC,nmiwr-nmird
	LDIR

	CALL	docmd		;Returns when done. Data transfers under NMI

	PUSH	AF		;Save error code

	BIT	5,D		;If a write command, 1ms delay required
				;for tunnel erase to complete
	JR	Z,notunl

;	1ms =6000T, but the minimum to next FDC command is 230T (via FORMAT)
;	so we need oc),A
	EI

;NB. After starting motor, the head load timer is not properly reset & will
;usually time out rather too soon. This does not matter, however, as
;it can be assumed that it takes longer for the drive to come to speed than
;the head load time, as the drive must do at least 1 rev to detect that it
;is up to speed, even if the motor was off only momentarily.

	IN	A,(fdtrk)
	CP	H		;Already at right trk?
	JR	Z,trkok

	INC	A
	CALL	Z,seekz		;trk=&FF <=> head pos not known
	LD	A,H
	OUT	(fdto waste 5770T

	LD	HL,5770/26
tunnel:	DEC	HL		;  6T
	LD	A,H		;  4T
	OR	L		;  4T
	JR	NZ,tunnel	; 12T if jump taken
				;Total for loop =26T

notunl:	CALL	enaint		;Reenable net
	LD	HL,(trkptr)	;Update trk table
	IN	A,(fdtrk)
	LD	(HL),A

	POP	AF		;Restore error code from <docmd>

	LD	HL,errloc
	LD	(HL),0

	AND	0DCH		;Mask out bits not signalling errors
	JR	Z,noerr

	LD	(HL),0C7H

	LD	HL,retryc
	DEC	(HL)
	PUSH	AF		;Save Z flag particularly

	LD	DE,errmsg	;Display error message
	JR	data),A	;Set up for seek

	LD	A,seek		;verify bit set only for settle time delay
	CALL	docmd		;NB. errors ignored as motor still running up

trkok:	IN	A,(fdstat)	;Wait for ready <=> motor full speed
	BIT	notrdy,A
	JR	NZ,trkok

	LD	A,L		;Sector no.
	OUT	(fdsec),A

	CALL	no_int		;temp disable net

;	Set up alt regs for NMI rtn

	EX	AF,AF'		;Save alt regs contents
	PUSH	AF
	EX	AF,AF'

	PUSH	BC		;Data addr
	EXX
	EX	(SP),HL		;HL':=^data, (SP):=old HL'
	PUSH	BC		;save HL',BC'
	LD	C,fddata	ds drive
	AND	3FH		;not any more
	LD	H,A		;HL=block no =sector no.

	LD	BC,secbuf	;Ram address where paged RAM appears
	PUSH	DE
	CALL	rwsec
	POP	DE
	LD	C,A		;Error code (=0 for no error)


	LD	A,C		;=0 if no error
	AND	D		;=0 if write
	RET	Z
	LD	(IY+2),0FFH	;Error during read, so cache now holds junk.
	LD	(IY+3),0FFH	;Mark as empty.
	RET




;RWSEC
;Read/Write sector to/from disk
;
;On entry:
;	BC	RAM address to read/write
;	 D	Read flag (FF-read,0-write)
;	 E	Disk number
;	HL	serom carry into A
	SRA	B
	RR	C		;Reduce 'n'
	JP	NC,tscon1	;Carry => part of the '5' has fallen out

	LD	H,A		;Swap regs - so correct for output

dundiv:	POP	BC

; Now have H=trk, L=sector, D=read flag, E=drive bits, BC=address

	SRL	H		;Modify track number (div 2)
	JR	NC,side0
	SET	sidsel,E	;Other side
side0:	INC	D		;D now 0 for read, 1 for write
	LD	D,rdsec
	JR	Z,rwdisc
	LD	D,wrsec

;drop through


;RWDISC - read, write, format disc.
;
; On entry :
;	BC	Ram address of data
;	D	FD cctor no.
;
;On exit:
; A	Error code (0 = OK, 1=error)
;	(errloc) also updated
; IX,IY	Preserved

rwsec:
	PUSH	BC

	CALL	trkreg		;Init track reg & pointer to trk table

;Convert drive number into drive bits

	XOR	A
	LD	B,E
	INC	B		;As drive numbers start at 0
	SCF
cdrnol:	RLA
	DJNZ	cdrnol
	LD	E,A		;has a single bit set in it.

;Convert sector number HL into track H & sector L

	LD	A,(inches)	;1 bit per drive - =1 for 8inch
	AND	E
	JR	Z,div5		;5" have 5 sec/trk

	SET	inch8,E		;Set ommand (expected to be read sec, write sec, or write trk)
;	E	drive sel, side sel, 5/8 inch to suit dskctl port
;	H	track
;	L	sector if reqd.
;
; <trkreg:> assumed to have been called
;
; On exit :
;	A	=0 if no error, =1 otherwise
; ALL OTHER REGS PRESERVED

rwdisc:	LD	A,maxtry
	LD	(retryc),A
retry:	PUSH	DE
	PUSH	HL
	PUSH	BC

	LD	A,(dkctlm)	;Copy of current disc select state
	XOR	E		;Compare with new drive
	AND	0FH		;Mask out side or density changes
	JR	Z,samedr
	LD	A,ctcset	;Wind up ti8" bit in value to put in dskctl port

;Divide by eight

	LD	A,L
	AND	7		;Remainder MOD 8

	ADD	HL,HL		;*2
	ADD	HL,HL		;*4
	ADD	HL,HL		;*8
	ADD	HL,HL		;*16
	ADD	HL,HL		;*32
				; div 8 <=> *32 DIV 256
	LD	L,A
	JR	dundiv	


;Divide by five - by subtracting 5*2^n, n=7..0  (max 160 tracks)

div5:	XOR	A		;to receive bits of result

	LD	BC,-280H	;280H = 5*128 decimal
tscon1:	ADD	HL,BC
	JR	C,tscon0	;carry => HL-BC positive
	SBC	HL,BC		;repair HL (carry cleared)
tscon0:	RLA			;Insert bit fentry

	LD	IY,page			;Start of chain - IY usually points to
					; the previous entry
	LD	D,0

;	HL=block/drive no, D=0
;	In loop, DE=page no, C=previous page no.

	LD	A,noblks		;Number of entries to search
	LD	B,A			;For DJNZ

filoop:	LD	C,E			;Save previous pageno
	LD	E,(IY+0)		;Advance to next
	LD	IY,cacmap		;Calculate address of cacmap entry
	ADD	IY,DE

	LD	A,(IY+2)
	CP	L
	JR	NZ,filop1		;No good
	LD	A,(IY+3)		;Test hi byte
	CP	H
	JR	Z,found			;Both agree

filop1:					;Get here ifIY+0),A		; new_ent^.next:=head_ptr
	LD	A,E
	LD	(page),A		; head_ptr:=new_ent

	SCF
	RET







;RWBLK
;Read/Write block to/from disk
;
;
;On entry:
; D	Read flag (&FF -> read, 0 -> write)
; IY	Points to map entry
;(page)	**NOT USED** (hence we can write blocks not at head of chain)
;
;On exit:
; C	Error code (0 = OK)
;	(errloc) also updated
; (IY)	Needs writing flag cleared always. Blockno zapped if read error

rwblk:	LD	(IY+1),0FFH	;Clear needs writing flag

	PUSH	IY
	POP	HL		 this block no good
	DJNZ	filoop			;Fall through if we have tried all ents

; Now have tail of chain

	PUSH	HL			;Save blockno.
	CALL	setpag			;Make this into head of chain
	LD	A,(IY+1)		;Needs writing flag
	OR	A			; sets Zf, also clears Cf
	JR	NZ,setblk		;Not required, so just insert blkno.
	LD	D,0			;r/w flag set to write
	CALL	rwblk
setblk:	POP	HL			;Get back blockno.
	LD	(IY+2),L
	LD	(IY+3),H		;Store in map
	OR	A			;Clear carry <=> not found
	RET


;	Found already in cache, so set car;Calculate page no. from table offset
	LD	BC,cacmap	;Start of table
	OR	A		;Clear carry
	SBC	HL,BC
	LD	A,L		;the answer (NB. 1K pages, so low 2 bits =0)
				;The fact that H=0 is assumed later.
	OR	pagon		;Bit(s) to turn on paged RAM
	LD	(copy),A
	OUT	(paport),A

	LD	A,(IY+3)	;Drive in hi 2 bits
	RLCA
	RLCA
	AND	03H		;Now back in right place
	LD	L,A		;NB. H=0
	LD	BC,drvtab	;Logical to physical translation table
	ADD	HL,BC
	LD	E,(HL)

	LD	L,(IY+2)	;blockno.
	LD	A,(IY+3)	; Hi byte also holry for return & drop through
;	to move to head of chain if not already there.

found:	LD	A,(page)
	CP	E			;Test for already head of chain
	SCF
	RET	Z			;Return to save looping up chain

;	Move the new entry to the top of the chain
;	IY points to new entry, C is previous page, E is new page
;	On exit, carry set, A=(page), B=0, HL=^previous ent

setpag:	LD	HL,cacmap
	LD	B,0			;BC now = previous page no.
	ADD	HL,BC

	LD	A,(IY+0)
	LD	(HL),A			; previous^.next:=new_ent^.next
	LD	A,(page)
	LD	(		;In case it stops during test
	LD	A,(HL)
	LD	(HL),080H	;Wind up motor	(forever)
	EI
	SLA	A		;=0 if previously stopped, >1 otherwise
	LD	L,A		;Very short timeout if already running
	LD	H,0		;otherwise about 1s
	IN	A,(mstart)

	LD	A,frcint	;Force int <=> force type 1 status
	CALL	docmd

inid2:	DEC	HL		; 6t
	LD	A,L		; 4t
	OR	H		; 4t
	JR	Z,nodisc	; 7t	Give up
	EX	(SP),HL		;19t	Increase timeout
	EX	(SP),HL		;19t
	NOP			; 4t
	IN	A,(fdstat)	;11t	Wait for drive to go rdy 
	BIT	notrdy,A	; 8t	<=

do:	PUSH	BC
	PUSH	DE
	PUSH	HL		;save working registers

	LD	A,(page)	;Open page
	OR	pagon
	LD	(copy),A
	OUT	(paport),A

	LD	BC,03FFH	;Length-1
	LD	HL,secbuf
	LD	DE,secbuf+1
	LD	(HL),0		;Value which will be copied all the way down
	LDIR	

	;NB. page left open - will be closed after writing data in

	POP	HL
	POP	DE
	POP	BC
	JR	rdywr


;fiblk
;
;Find block in cache.
; If block not found, return the tail of the chain, making it the head
; then writing out if necessary & inserting t(IY+2)	;Blockno.
	LD	H,(IY+3)
	CALL	dhxout
	mess	adrmsg
	POP	HL
	CALL	dhxout
	mess	atmsg
	LD	A,(page)
	CALL	cahex
	CALL	pcrlf
	POP	HL
	POP	DE
	POP	BC
wrm1:	POP	AF
	ENDIF

	JR	NZ,clrblk	;No pre-read means zap to =0
	JR	C,rdywr		; Carry => it's been pre-read anyway

	PUSH	BC
	PUSH	DE
	PUSH	HL

	LD	D,0FFH		; r/w flag (read)

	LD	A,B		;Now test for BC=0400H => don't read
	SUB	4		;because the whole blk will be over-written
	OR	C
	CALL	NZ,rwblk	;IY contains all other info

	POP	HL
	he new info in the map.
;
;On entry:
; HL	address of block descriptor (drive then block)
;
;On exit:
;(page)	updated
; IY	points to entry in cacmap
; cf	set	Found
;	clear	Not found
;
; HL,DE,BC registers all used
;

fiblk:

;Put drive in top 2 bits of block number

	LD	A,(HL)			;Drive
	RRCA
	RRCA				;Put in top 2 bits
	INC	HL
	LD	E,(HL)			;Lo(block)
	INC	HL
	OR	(HL)			;Hi byte add to drive bits
	LD	D,A
	EX	DE,HL

;	fudge to get started - note that link pointer is at start of map POP	DE
	POP	BC

;	Now ready to write (into cache)
;	HL=source, DE=offset to dest., BC=byte count
rdywr:
	LD	(IY+1),0	;Needs writing (or soon will!)

	LD	A,(page)	;Open paged RAM
	OR	pagon
	LD	(copy),A
	OUT	(paport),A

	LD	A,D		;Add user's offset to address of paged RAM
	ADD	A,HIGH secbuf
	LD	D,A
	LDIR

	RET



;	Clear block to zero to give correct value in areas not initialised
;	by the user

clrblk:	LD	A,B
	SUB	4		; 0400H <=> 1K <=> block size
	OR	C
	JR	Z,rdywr		;ready to writeevent checking more entries
	JR	NZ,idloop	;than there are cache entries

	RET




;PROCEDURE cempty
;
;Write out any part of the cache which still has things in.
; Not called very often, so implemented compactly rather than fast.

cempty:	LD	B,noblks	;Max number of blks that could possibly
mtloop:	PUSH	BC		;need writing
	CALL	cidle
	POP	BC
	DJNZ	mtloop
	RET



;PROCEDURE disc_rd(addr,length,offset:Word;VAR blk:block_descrip);
;
; Read in up to 1 block to specified address. <offset> iluding error bits
;
; All regs except AF preserved

docmd:	OUT	(fdctrl),A
	CALL	fdcdel		;Delay for FDC status to be valid
cmdwai:	IN	A,(fdstat)
	BIT	busy,A
	JR	NZ,cmdwai
	RET	


; FDCDEL - delay time for FDC status reg to become valid after command issued
;
; Preserves all regs
; delay is 56 us (allowing for 5" single density)

fdcdel:	PUSH	BC		;Total 336T to burn. Excluding the DJNZ,
	LD	B,290/13	;we have 55T, so 281 left
	DJNZ	$
	POP	BC
	RET






; INIDRV - initialise for 1 drs offset in block.
; Errors returned in common area <error>
;

discrd:	XOR	A
	LD	(errloc),A	;No error yet

	POP	HL
	EX	(SP),HL		;Get blockno. address

	CALL	fiblk		;Returns HL pointing to map entry
	JR	C,incach	;Carry => block already in cache

	LD	D,0FFH		;r/w flag =READ.
	CALL	rwblk

incach:	POP	HL		;Return addr.
	POP	DE
	POP	BC
	EX	(SP),HL
	EX	DE,HL

;	Now have: HL=source offset, BC=length, DE=destination address

	IF	t.on
	mcond	rdm1
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSive.
; Sets up 5/8 inch flag by measuring the index hole frequency
;
; On entry :
;	E	Drive number
; On exit :
;	E	Drive bits suitable for dskctl latch
;	AF	=0 if no drive not ready, =1 otherwise
;	Other regs preserved

inidrv:	PUSH	HL
	PUSH	BC

;Convert drive number into drive bits

	XOR	A
	LD	B,E
	INC	B		;As drive numbers start at 0
	SCF
inid1:	RLA
	DJNZ	inid1
	LD	E,A		;has a single bit set in it.


	OUT	(dskctl),A	;Select drive
	LD	(dkctlm),A	;& update copy

	LD	HL,ticloc
	DI	T


; SEEKZ - seek trk 0
;
; Preserves all regs except AF.
; Track not verified.
; Assumes drive selected.

seekz:	LD	A,frcint	;Force int <=> force type 1 status
	CALL	docmd
	IN	A,(fdstat)
	BIT	trk0,A
	JR	Z,noinc		;No track inc unless already at trk 0
	LD	A,trkinc	;Move head away so that it is re-positioned
	CALL	docmd
noinc:	LD	A,home
;	JP	docmd		;Drop through



; DOCMD - execute FDC command & wait for completion
;
; On entry :
;	A	command byte
;
; On exit :
;	A	status reg - inc be printed
serptr:	DS	2		;out by IRQ rtn.

paract:	DS	1		;Flags for active - ie. buffer not empty if <>0
seract:	DS	1		;NB. Assumed adjacent & in this order

useflg:	DS	1		;Bit 0 for parallel, Bit 1 for serial.
				;Set if in use as message printer, clear
				;if user printer

	END





parasp:	DS	2		;Points to the first free location
sersp:	DS	2		;in the buffer

parptr:	DS	2		;Points to the first byte to
inidk1:	SCF
	RLA
	DJNZ	inidk1
inidk0:	LD	(HL),A

	RET




;Heap error (overflow)

heaped:	error	'Heap oflow'





;PROCEDURE cidle
;
; Use FS idle time to write out any of the cache that needs it.
; Starts from the head, which means that under heavy loading the items
; near the tail will never be written. However, these items will tend
; to get written anyway as the entries are either used & brought back
; to the top of the cache, or get thrown out to make space for new entries.

ress in mapptr
	LD	C,A		;BC:= A * 2
	LD	B,0

	LD	HL,dsksiz	;Put into disk size table (pascal's FREE_BL)
	ADD	HL,BC
	LD	(HL),E
	INC	HL
	LD	(HL),D

	SRּ	D		;Converפ Blockף tן Byteף tן allocate
	Rׂ	E
	SRL	D
	RR	E
	SRL	D
	RR	E
	INC	DE

	LD	HL,mapptr+2	;+2 => point to map address (low)
	ADD	HL,BC		;HL+:= A * 4
	ADD	HL,BC

	;Prepare to call Heap(VAR p:ptr,size:Word);

	PUSH	HL		;Save map pointer
	PUSH	DE		;and length info

	PUSH	HL		;1st parameter
	PUSH	DE		;2nd
	CALL	heap
	JR	Z,heapcidle:	LD	A,(page)
	LD	E,A		;place to start
	LD	A,noblks	;Maximum no. of ents worth looking at
	LD	C,A
	LD	B,3		;Maximum no. of blocks we have time to write

idloop:	LD	IY,cacmap
	LD	D,0		;Turn E into 16-bit value
	ADD	IY,DE
	LD	A,(IY+1)	;Get needs writing flag
	OR	A
	JR	NZ,idl1		;Doesn't need it

	PUSH	BC
				;D already contains 0 (meaning write)
	CALL	rwblk

	POP	BC
	DEC	B
	RET	Z		;Written as many as we want to

idl1:	LD	E,(IY+0)	;pointer to next entry in chain
	DEC	C		;Counter to pred	;FALSE => no room on heap

	POP	BC		;Length
	POP	HL		;Points to pointer table - address of the
				;bit of heap just got inserted here


	LD	E,(HL)		;Get address of map
	INC	HL
	LD	D,(HL)
	DEC	HL
	DEC	HL
	LD	(HL),B		;Also save length
	DEC	HL
	LD	(HL),C

	LD	H,D		;Get start
	LD	L,E
	INC	DE		;Clear map
	DEC	BC
	LD	(HL),-1

	tmess	<naloc0,BC,naloc1,HL,crlf>

	LDIR

	POP	DE		;Reset bits in last byte to indicate
	LD	A,E		; if not all availible
	AND	7
	JR	Z,inidk0
	LD	B,A
	SUB	Ai1:	LD	DE,nmivec
	LD	BC,nmiwr-nmird
	LDIR

	CALL	docmd		;Returns when done. Data transfers under NMI

	PUSH	AF		;Save error code

	BIT	5,D		;If a write command, 1ms delay required
				;for tunnel erase to complete
	JR	Z,notunl

;	1ms =6000T, but the minimum to next FDC command is 230T (via FORMAT)
;	so we need to waste 5770T

	LD	HL,5770/26
tunnel:	DEC	HL		;  6T
	LD	A,H		;  4T
	OR	L		;  4T
	JR	NZ,tunnel	; 12T if jump taken
				;Total for loop =26T

notunl:	CALL	enaint		;Reenable net
	NMI routines for read or write
	EX	AF,AF'
	INI
	EX	AF,AF'
	EXX
	RETN

nmiwr:	EXX
	EX	AF,AF'
	OUTI
	EX	AF,AF'
	EXX
	RETN





;TRKREG - set up track register from table
;
; On entry :
;	E	Drive no
;
; On exit :
;	A	current track
;	track reg in FDC loaded from table
;	(trkptr) holds address in track table
;	All regs preserved except AF

trkreg:	PUSH	HL
	LD	A,D		;Save D
	LD	D,0
	LD	HL,trkno
	ADD	HL,DE
	LD	D,A		;Restore
	LD	(trkptr),HL
	LD	A,(HL)
	OUT	(fdtrk),A
	POP	HL
	RELD	HL,(trkptr)	;Update trk table
	IN	A,(fdtrk)
	LD	(HL),A

	POP	AF		;Restore error code from <docmd>

	LD	HL,errloc
	LD	(HL),0

	AND	0DCH		;Mask out bits not signalling errors
	JR	Z,noerr

	LD	(HL),0C7H

	LD	HL,retryc
	DEC	(HL)
	PUSH	AF		;Save Z flag particularly

	LD	DE,errmsg	;Display error message
	JR	NZ,nonfat
	LD	DE,fatmsg	;Fatal disc error
nonfat:	CALL	pmess
	POP	AF
	PUSH	AF		;Get error number
	CALL	cahex
	POP	AF		;Restore Z flag - NZ => retry worthwile


	LD	A,1		;Return TLD	B,11		;8 bytes of pointers + 2 active flags + useflg
flush1:	LD	(HL),0
	INC	HL
	DJNZ	flush1

	RET







	COMMON	/messag/
mess:	DS	1

	COMMON	/debug/
debu:	DS	1

	COMMON	/pacopy/

copy:	DEFS	1		;RAM copy of paging latch contents

	COMMON	/msgcha/

msgch:	DS	1		;Printer to use for PCHAR output.


	DSEG

;	Pointers to control the two printer buffers.


parasp:	DS	2		;Points to the first free location
sersp:	DS	2		;in the buffer

parptr:	DS	2		;Points to the first byte toRUE, indicating error

noerr:	EXX
	POP	BC
	POP	HL
	EXX
	EX	AF,AF'
	;AF' already corrupt, so this is a convenient place to set the
	;motor stop timer
	LD	A,mtrtim
	LD	(ticloc),A

	POP	AF		;Retore user's AF'
	EX	AF,AF'
	
	POP	BC
	POP	HL
	POP	DE

	RET	Z		;If no error, we got here from JR Z
 				;otherwise Z is set from DEC of retry counter
				;=> exit if no error or max retries reached.
	LD	A,0FFH		;Clear track reg to force a seek0 next time
	OUT	(fdtrk),A
	JP	retry


nmird:	EXX			;
	LD	(dkctlm),A	;Set up RAM copy
	LD	(ticloc),A	;Indicate drives stopped so time is allowed
				;to restart them later
	IN	A,(mstop)	;Stop drive motors

	LD	HL,trkno
	LD	B,4
zaptab:	LD	(HL),0FFH
	INC	HL
	DJNZ	zaptab
	RET



;PROCEDURE inidsk (VAR max_drive: BYTE);
;
;This procedure allocates heap for the map for all drives
;& finds out how many drives there are.
;External drive numbers always run 0..n and are translated into real drives

inidsk:	CALL	inilow		;To turn off motors etc.

 up translation table
;

	LD	HL,drvtab
	LD	BC,noofdr*256	;C:=0 (count of actual drvs), B:=noofdr
	LD	D,C		;D:=0 (physical drive count)
drvcnt:	LD	E,D
	CALL	inidrv
	JR	Z,nodrv		;Z means drive not working/no disc
	LD	(HL),D		;Insert table entry
	INC	HL		;Pointer into translation table
	INC	C		;Logical drive number
nodrv:	INC	D		;Real drive number
	DJNZ	drvcnt

	LD	A,C		;No. of drives available
	DEC	A		;Convert to max drive no.
	JP	M,fsexit	;Exit if no drives

	POP	HL		;Return address
	EX	(ime constant =1
	OUT	(ctc3),A

	LD	HL,parasp	;First of the buffer pointers
	LD	B,11		;8 bytes of pointers + 2 active flags + useflg
flush1:	LD	(HL),0
	INC	HL
	DJNZ	flush1

	RET







	COMMON	/messag/
mess:	DS	1

	COMMON	/debug/
debu:	DS	1

	COMMON	/pacopy/

copy:	DEFS	1		;RAM copy of paging latch contents

	COMMON	/msgcha/

msgch:	DS	1		;Printer to use for PCHAR output.


	DSEG

;	Pointers to control the two printer buffers.


parasp:	DS	2		;Points to the first free locSP),HL		;Address of maxdrv parameter (Pascal)

	LD	(HL),A		;Return result of this procedure call

; this loop occurs once for each disk

inilp0:	PUSH	AF		;drive
	LD	(bldes),A	;Put drive in block descriptor

;	Set up parameters on stack for <discrd>

	LD	HL,($hplm)	;Read this block above the system heap
	PUSH	HL
	LD	HL,0400H	;Length
	PUSH	HL
	LD	H,0		;Offset
	PUSH	HL
	LD	(bldes+1),HL	;Block 0
	LD	HL,bldes	;Block descriptor set up to be blk0
	PUSH	HL
	CALL	discrd

	LD	A,(errloc)	;Had erration
sersp:	DS	2		;in the buffer

parptr:	DS	2		;Points to the first byte to be printed
serptr:	DS	2		;out by IRQ rtn.

paract:	DS	1		;Flags for active - ie. buffer not empty if <>0
seract:	DS	1		;NB. Assumed adjacent & in this order

useflg:	DS	1		;Bit 0 for parallel, Bit 1 for serial.
				;Set if in use as message printer, clear
				;if user printer

	END


 for PCHAR output.


	DSEG

;	Pointers to control the two printer buffers.


parasp:	DS	2		;Points to the first free loc Char_IO;
; Initialise character I/O (ie. printers & Pchar)
; Also set message and debug flags from user values in (07EH)

chario:	LD	A,(07EH)
	LD	(mess),A
	LD	A,(07FH)
	LD	(debu),A

;	Drop through

; PROCEDURE FlushP;
; Discard contents of printer buffers

flushP:	LD	HL,parasp	;First of the buffer pointers
	LD	B,13		;12 bytes of pointers + useflg
flush1:	LD	(HL),0
	INC	HL
	DJNZ	flush1

	RET



; Routine to wait for & read byte from 6502
; Value returned in A, all other regs preserveader

sjmess:	DEFM	'SJ Research File Server ver '
	DEFW	verhi,verlo

	DEFM	'/FDFS'


; NB this label must be defined before any references to the MESS
; macro is made.
; NB2 also forms part of the above string.

crlf:	DEFM	cr,lf,'$'


	IF	t.on

;dhxout
;Print hex of HL

dhxout:	LD	A,H
	CALL	cahex
	LD	A,L
				;DROP THROUGH
;cahex
;Print hex of A
;
;On entry:
; A	number to be printed

	JP	cahex		;Now lives in h2lib or some such place
;
; Print a crlf!
pcrlf:	LD	DE,crlf
	JP	ped.
;
; NB.	the 6502 is now a Z80 !

wait65:	IN	A,(status)
	BIT	6,A
	JR	Z,wait65
	IN	A,(Jlatch)
	RET





	COMMON	/messag/
mess:	DS	1

	COMMON	/debug/
debu:	DS	1

	COMMON	/msgcha/
msgch:	DS	1

	DSEG

;	Pointers to control the two printer buffers.

; Buffers are in fact (64K-1) bytes long, since the case where
; <free pointer> = <data pointer> is taken to mean buffer empty.
; Buffer full if <data pointer> = <free pointer> -1

; NB. FlushP assumes 12 bytes of pointers, parasp: fmess


wrmess:	DEFM	'Wrt blk $'
rdmess:	DEFM	'Rd blk $'
adrmsg:	DEFM	' addr $'
atmsg:	DEFM	' @ $'
almsg0:	DEFM	'Init map $'
almsg1:	DEFM	' - length $'
naloc0:	DEFM	cr,lf,'Clear $'
naloc1:	DEFM	' bytes from $'
;alblk0:	DEFM	'Allocate block $'
alblk1:	DEFM	' from map $'
frblk0:	DEFM	'Free block $'

fatmsg:	DEFM	0DH,0AH,'Fatal disc error $'
errmsg:	DEFM	' Error $'

	ENDIF






;PROCEDURE inilow
;
; Set up hardware ready for use.

inilow:	XOR	A
	OUT	(dskctl),A	;Deselect all drivesirst.

parasp:	DS	2		;Points to the first free location
sersp:	DS	2		;in the buffer

parptr:	DS	2		;Points to the first byte to be printed
serptr:	DS	2		;out in the current DMA transfer

parnxt:	DS	2		;Contains the value which the pointer will
sernxt:	DS	2		;have when the current DMA transfer is complete

useflg:	DS	1		;Bit 0 for parallel, Bit 1 for serial.
				;Set if in use as message printer, clear
				;if user printer
	END
t:Byte;channel:Byte);

print:	POP	HL
	EX	(SP),HL		;H:=channel no.

	LD	B,H		;Save printer no.
	LD	A,B
	LD	HL,useflg	;Point to user/message printer flag
	AND	(HL)		;=0 if already a user printer
	LD	A,B		;Restore number
	JR	Z,doprnt	;All is OK

	XOR	(HL)		;Not ok - was in use as message printer
	LD	(HL),A		;Clear flag

	LD	HL,msgch	;Point to current message channel
	LD	C,(HL)		;Save old value
	LD	(HL),B		;Insert our printer number
	
	LD	E,12		;Form feed
	PUSH	BC
	PUSH	HL
	CALL	dochar		;P bytes to print
	LD	H,0		;HL:=A
	ADD	A,C		;Check for crossing page boundary
	LD	A,L
	JR	NC,print6	;Not crossing boundary.
	LD	A,C		;If so, do up to end of page
	NEG
	LD	L,A		;NB. never 0 since no. asked <256,
				; => if Lo(ptr)=0 won't cross boundary

	;No. of bytes to do in A, AND in HL

print6:	LD	(DE),A		;Tell the user how many we did
	ADD	HL,BC		;Add byte count to pointer

	POP	AF		;Para/serial flag
	JR	Z,print7	;Jump if parallel

	LD	(sersp),HL
	LD	L,0C0H		;Page offset to use shortlrint char from E
	POP	HL
	POP	BC
	LD	(HL),C		;Restore (msgch)
	LD	A,B		;A:=printer number

;	doprnt:
;	Entered here from Pchar also.
;	A=1 for parallel =2 for serial
;	(SP)=return addr, (SP+2)=^byte count, (SP+4)=^data

doprnt:	POP	IY
	POP	DE

;	IY=ret addr, A=printer no, DE=^byte count, (SP)=^data

	DEC	A
	PUSH	AF		;Save flag (=0 => parallel, =1 => serial)

	JR	Z,print1	;Parallel
	LD	HL,(serptr)
	LD	BC,(sersp)
	JR	print2
print1:	LD	HL,(parptr)
	LD	BC,(parasp)

print2:	SCF			;Set cy
	JR	print8

print7:	LD	(parasp),HL
	LD	L,040H

;	L=page offset for cache, BC=old free space pointer, DE=^byte count

print8:	LD	A,3		;Cache write op-code
	CALL	to6502

	LD	A,B
	SRL	A		;Convert pointer to 1K page offset
	SRL	A
	OR	L		;Add in page offset
	CALL	to6502

	LD	A,C		;Offset in page (lo)
	CALL	to6502
	LD	A,B
	AND	3		;Hi 2 bits
	CALL	to6502

	CALL	wait65

	LD	C,cacheP
	LD	A,(DE)		;Byte count
	LD	B,A
	POP	HL		;Address of data
	OTIR

	JP	(IY)		;Return



; PROCEDUREarry, so result comes out 1 less
	SBC	HL,BC		;HL:=no. of free slots in buffer
	JR	NZ,print3
	XOR	A		;No room in buffer
	LD	(DE),A
print5:	POP	AF		;Discard spare parameters
	POP	HL
	JP	(IY)		;Return

print3:	LD	A,(DE)		;Count of bytes to print
	OR	A
	JR	Z,print5	;User doesn't want any printed!
	INC	H
	DEC	H
	JR	NZ,print4	;More than 1 page left => room for all of them
	CP	L		;Test bytes avail against bytes reqd.
	JR	C,print4	;Room for all
	LD	A,L		;Not enough room

print4:	LD	L,A		;A=no. of…‘”ױױU dd4פהץH=QMRTERMTX”)€M} £¬ ·>,—(†ֵ €  O MVh  ׁBA0׃˜מ³hְ…!¼ְ   «‹ 2GXnָ`ְ±>²^¬r (}¼^¬V«•›V€-ֵ’Gאְ  y„ka@,V~:ֻב` dאdn³€E‚   ‡  9Y  „מ .Qץh 	pp4  `אײ [ׁ@dU”@l–•  n¸ D   ƒְױƒ…‡J .ׂ [»JL ?־כv@¬¾ „8D 2P0ְ   ֳ§ : ֳ    „@         eְ אְ	ph¸8\. —(€K”ְ#!ְY9QZ3°‘ׂS”ױ#;`=9%::‘׃׃“ױ#§ =QMR3T‘”–S’c6 %=)5AN2J“RT׀ׁװד2€IQ9I:•T“U#0@Qa!%!2p  .Qץh 	pp4  `אײ [ׁ@dU”@l–•  n¸ D   ƒְױƒ…‡J .ׂ [»C,0FC00H	;Address of cache RAM
	LD	HL,0		;Block number

	CALL	rwsec
	OR	A
	RET	NZ		; Give up


iniok:	LD	HL,0FC00H+sjoff	;Where we put the block + Offset of SJ string
	LD	DE,sjmess	;Check it's an SJ disk
	LD	B,23		;B:= len SJstring

csjlop:	LD	A,(DE)
	CP	(HL)
	JR	NZ,inierr
	INC	HL
	INC	DE
	DJNZ	csjlop

	RET

nodsc1:	LD	A,2		;No disc in drive
	JR	inier2
inierr:	LD	A,1		;Duff data in blk 0
inier2:	LD	(errloc),A
	RET


; PROCEDURE Open_ca(page:Byte);
;
; Open cache RAM at specifien the write trk command
	JR	form2
	

form99:	XOR	A
	INC	A		;Return result =OK
	POP	HL		;Discard newtrk: parameter
form98:	POP	IX
	RET




; PROCEDURE Rw_blk(read:Boolean; address:Word; disc:Byte; blkno:Word);
;
; Write out 1k block to disc from main memory <buffer>.

rwblk:	POP	HL
	POP	DE		;Blockno
	POP	AF		;Drive
	POP	BC		;Address
	EX	(SP),HL		;Read flag to H, return addr back on stack
	EX	DE,HL		;<rwsec> requires blockno in HL
	LD	E,A		;Drive
	XOR	A
	SUB	D		;D contains read flag =just pushed
	PUSH	HL

	LD	A,(msgch)	;Select which printer

	CALL	doprnt

	POP	AF		;The byte count
	OR	A		;Set flags (A value in stack was poked)
	JR	NZ,pchar2	;If =0, the call to print did 0 bytes.

	LD	A,08FH		;Turn off offline LED
	OUT	(system),A
	CALL	delay
	LD	A,087H		;Online LED on again
	OUT	(system),A
	CALL	delay		;Returns Z if operator is turning off power
	JR	NZ,pchar1	;or entering config mode
				;Don't wait if so.
pchar2:	POP	DE
	RET



; PROCEDURE Print(addr:Word;VAR coun1 => read, =0 => write
	LD	D,A		;Now =0 => write, =&FF =>read

	JP	rwsec		;All params set up - call & return to pascal





;  PROCEDURE Chk_SJ(drive:Byte);
;
; Read blk0 into cache RAM, check for 8"/5" drive, check for SJ disc.
; Set <error> =1 means disc OK, but no SJ message
; <error> =2 => no disc in drive

chkSJ:	POP	HL
	EX	(SP),HL
	LD	E,H

	CALL	inidrv		;Tests for 5"/8". Preserves HL.

	JR	Z,nodsc1

;	Set up registers for <rwsec>

	LD	E,H
	LD	D,0FFH		;Read flag (=True)
	LD	B

	JR	Z,nodsc1

;	Set up registers for <rwsec>

	LD	E,H
	LD	D,0FFH		;Read flag (=True)
	LD	BC,0FC00H	;Address of cache RAM
	LD	HL,0		;Block number

	CALL	rwsec
	OR	A
	RET	NZ		; Give up


iniok:	LD	HL,0FC00H+sjoff	;Where we put the block + Offset of SJ string
	LD	DE,sjmess	;Check it's an SJ disk
	LD	B,23		;B:= len SJstring

csjlop:	LD	A,(DE)
	CP	(HL)
	JR	NZ,inierr
	INC	HL
	INC	DE
	DJNZ	csjlop

	RET

nodsc1:	LD	A,2		;No disc in drive
	JR	inier2
inierr:	LD	A,1		;Duff data in blk 0),mtrtim	;Stop drive after usual time
	POP	BC
	POP	HL
	RET






;FUNCTION Format(drv:Byte):Boolean;
;
; Format specified drive.
; Returns TRUE if format attempted, FALSE if no disc in drive.
; Uses RAM at &8000 for format table

format:	POP	HL
	EX	(SP),HL		;Drive no. in H
	PUSH	IX		;Save for Propas

	LD	E,H
	CALL	trkreg		;Set track table pointer

	CALL	inidrv		;Applies tape measure to drive -
				;On return, E contains value for <dskctl>
				;including 8inch bit
	JR	Z,form98	;No d
inier2:	LD	(errloc),A
	RET


; PROCEDURE Open_ca(page:Byte);
;
; Open cache RAM at specified page

openca:	POP	HL
	POP	AF
	PUSH	HL

	SLA	A
	SLA	A
	OR	pagon-romoff	;Paging open, ROM ON

	OUT	(paport),A
	RET




	COMMON	/drv8in/

inches:	DEFS	1		;Bits 0..3 =1 if corresponding drive is 8"


	COMMON	/ticker/

ticloc:	DEFS	1


	COMMON	/debug/

mesflg:	DEFS	1


	COMMON	/error/

errloc:	DEFS	1



	DSEG

retryc:	DEFS	1		;Retry counter

trkptr:	DEFS	2		;This points toisc in drive

	CALL	seekz		;NB. drive left spinning by <inidrv>

;	Now set up parameter block for format data

	LD	IX,params	;Point to block in DSEG
	LD	HL,08000H	;Address of format data buffer
	LD	(params),HL
	LD	(IX+4),3	;Sector size - 3 => 1K
	BIT	inch8,E
	JR	Z,form5		;5" discs
	LD	(IX+5),160	;Gap3 size
	LD	(IX+2),0BH	;Flag - (start sec=0)+(8 inch)+(dden)
	LD	(IX+3),8	;No of sectors
	JR	form1

form5:	LD	(IX+5),100	;Gap3
	LD	(IX+2),9	;(start sec=0)+(dden)
	LD	(IX+3),5

form1:	EXX			;S an entry in trkno:

trkno:	DEFS	4		;Current tracks of drvs 0..3

params:	DEFS	6		;Parameter block for UFORMAT

dkctlm:	DEFS	1		;Ram copy of <dskctl> port

	END
ches:	DEFS	1		;Bits 0..3 =1 if corresponding drive is 8"


	COMMON	/ticker/

ticloc:	DEFS	1


	COMMON	/debug/

mesflg:	DEFS	1


	COMMON	/error/

errloc:	DEFS	1



	DSEG

retryc:	DEFS	1		;Retry counter

trkptr:	DEFS	2		;This points toXOR	A		;Indicate success
	INC	A
nodisc:	LD	HL,ticloc	;Entered here with A=0 if timed out
	LD	(HL),mtrtim	;Stop drive after usual time
	POP	BC
	POP	HL
	RET






;FUNCTION Format(drv:Byte):Boolean;
;
; Format specified drive.
; Returns TRUE if format attempted, FALSE if no disc in drive.
; Uses RAM at &8000 for format table

format:	POP	HL
	EX	(SP),HL		;Drive no. in H
	PUSH	IX		;Save for Propas

	LD	E,H
	CALL	trkreg		;Set track table pointer

	CALL	inidrv		;Applies tape measure to dform99	;Finished all tracks

	LD	A,trkinc	;Move to next track
	CALL	docmd		;NB. settle time is in the write trk command
	JR	form2
	

form99:	XOR	A
	INC	A		;Return result =OK
	POP	HL		;Discard newtrk: parameter
form98:	POP	IX
	RET




; PROCEDURE Rw_blk(read:Boolean; address:Word; disc:Byte; blkno:Word);
;
; Write out 1k block to disc from main memory <buffer>.

rwblk:	POP	HL
	POP	DE		;Blockno
	POP	AF		;Drive
	POP	BC		;Address
	EX	(SP),HL		;Read flag to H, return addr back on stack
	rive -
				;On return, E contains value for <dskctl>
				;including 8inch bit
	JR	Z,form98	;No disc in drive

	CALL	seekz		;NB. drive left spinning by <inidrv>

;	Now set up parameter block for format data

	LD	IX,params	;Point to block in DSEG
	LD	HL,08000H	;Address of format data buffer
	LD	(params),HL
	LD	(IX+4),3	;Sector size - 3 => 1K
	BIT	inch8,E
	JR	Z,form5		;5" discs
	LD	(IX+5),160	;Gap3 size
	LD	(IX+2),0BH	;Flag - (start sec=0)+(8 inch)+(dden)
	LD	(IX+3),8	;No of sectors
	JR	form1EX	DE,HL		;<rwsec> requires blockno in HL
	LD	E,A		;Drive
	XOR	A
	SUB	D		;D contains read flag =1 => read, =0 => write
	LD	D,A		;Now =0 => write, =&FF =>read

	JP	rwsec		;All params set up - call & return to pascal





;  PROCEDURE Chk_SJ(drive:Byte);
;
; Read blk0 into cache RAM, check for 8"/5" drive, check for SJ disc.
; Set <error> =1 means disc OK, but no SJ message
; <error> =2 => no disc in drive

chkSJ:	POP	HL
	EX	(SP),HL
	LD	E,H

	CALL	inidrv		;Tests for 5"/8". Preserves HL.

form5:	LD	(IX+5),100	;Gap3
	LD	(IX+2),9	;(start sec=0)+(dden)
	LD	(IX+3),5

form1:	EXX			;Save drive bits
	CALL	fdata		;Set up format table. Returns DE,HL
	PUSH	HL		;Corrupted by newtrk:
	EXX

	LD	H,0		;Track counter
	LD	BC,08000H	;Ram address
	LD	D,writrk	;FDC command for format

;	Now loop over all tracks

form2:	LD	A,H
	EXX
	POP	HL
	PUSH	HL
	CALL	newtrk		;Insert trackno into format data
	EXX
	RES	sidsel,E
	CALL	rwdisc
	SET	sidsel,E
	CALL	rwdisc
	INC	H
	LD	A,H
	CP	80
	JR	Z,
	LD	D,0FFH		;r/w flag =READ.
	CALL	rwblk

incach:	POP	HL		;Return addr.
	POP	DE
	POP	BC
	EX	(SP),HL
	EX	DE,HL

;	Now have: HL=source offset, BC=length, DE=destination address

	IF	t.on
	mcond	rdm1
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	DE
	mess	rdmess
	LD	L,(IY+2)	;Blockno.
	LD	H,(IY+3)
	CALL	dhxout
	mess	adrmsg
	POP	HL
	CALL	dhxout
	mess	atmsg
	LD	A,(page)
	CALL	cahex
	CALL	pcrlf
	POP	HL
	POP	DE
	POP	BC
rdm1:	POP	AF
	ENDIF


	LD	A,(page)	;Open page
	OR	pagon		;Add py 
	BIT	notrdy,A	; 8t	<=> up to speed
	JR	NZ,inid2	;12t =94t *65536 <=> 1.03 seconds

	DI			;For software timing

inid6:	IN	A,(fdstat)
	BIT	index,A		;Wait for index hole also
	JR	Z,inid6

inid3:	IN	A,(fdstat)	;Start timing at end of index
	BIT	index,A
	JR	NZ,inid3

	LD	HL,0		;Timer
inid4:	IN	A,(fdstat)	; 11T/12T if in ROM
	INC	HL		; 6T/7T
	BIT	index,A		; 8T/10T
	JR	Z,inid4		; 12T/13T except when dropping through
				; total = 37T/42T per loop
	EI

; 8" runs at 6 revs/sec =   1E6 T per age open bits
	LD	(copy),A
	OUT	(paport),A

	LD	A,H		;High of offset
	ADD	A,HIGH secbuf	;Add offset to where paged RAM appears
	LD	H,A
	LDIR

	RET			;Finished





;PROCEDURE disc_wr(addr,length,offset:Word;pre_read:Boolean;blk:block_descrip);
;
; Write up to 1 block from specified address. <offset> is offset in block.
; Errors are returned in common area <error>
;


discwr:	POP	HL		;Return address
	EX	(SP),HL		; addr of block descriptor


	CALL	fiblk		;Takes ^blk in HL, returns IYrev = 27027 iterations of loop
; 5" runs at 5 revs/sec = 1.2E6 T per rev = 32432 iterations of loop
; Hence mid pt. = 29729, just over &7400
; IF in rom:
; 8"=23809, 5"=28571 iterations mid pt=26190 ~=&6600

	LD	A,H

	IF	inrom
	CP	067H
	ELSE
	CP	075H		;Carry if 8"
	ENDIF

	LD	C,0		;No bit set
	JR	NC,inid5
	LD	C,E		;Get drive bit
	SET	inch8,E

inid5:	LD	HL,inches
	LD	A,E
	CPL			;Clear bit for this drive
	AND	(HL)		;get other drive bits
	OR	C		;Set our bit as appropriate
	LD	(HL),A	
	 ^map entry,
				;Cf set if found, Else we have the former tail

	LD	HL,errloc 	;This user is not interested in any error
	LD	(HL),0  	; to do with previous contents of page

	POP	HL		;Return address
	POP	BC		;Pre_read flag
	DEC	B		;Pre_read now in Z flag, carry unchanged
	POP	DE		;Offset
	POP	BC		;Length
	EX	(SP),HL		;Source addr to HL

;	Now have Z <=> pre-read, NZ=> no read, C=> already in cache
;
	IF	t.on
	mcond	wrm1
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	HL
	mess	wrmess
	LD	L,r, =1 otherwise
; ALL OTHER REGS PRESERVED

rwdisc:	LD	A,maxtry
	LD	(retryc),A
retry:	PUSH	DE
	PUSH	HL
	PUSH	BC

	LD	A,(dkctlm)	;Copy of current disc select state
	XOR	E		;Compare with new drive
	AND	0FH		;Mask out side or density changes
	JR	Z,samedr

	LD	A,ctcset	;Wind up timer for head load
	OUT	(ctc0),A	;ctc0 controls head load timing (from 256Hz)
	LD	A,14		; time constant  13*1/256 =50.78ms
	OUT	(ctc0),A

	IN	A,(mstart)	;Motor start also clears 'head loaded' flipflop

samedr:	LD	A,JR	NZ,trkok

	LD	A,L		;Sector no.
	OUT	(fdsec),A

	CALL	fastfl		;Flush FAST buffer
	CALL	no_int		;temp disable net

;	Set up alt regs for NMI rtn

	EX	AF,AF'		;Save alt regs contents
	PUSH	AF
	EX	AF,AF'

	PUSH	BC		;Data addr
	EXX
	EX	(SP),HL		;HL':=^data, (SP):=old HL'
	PUSH	BC		;save HL',BC'
	LD	C,fddata	;port no
	EXX

;	Install appropriate NMI rtn

	LD	A,D		;Command
	BIT	5,D		;Test for read or write command
	LD	HL,nmird	;Code for read
	JR	Z,nmi1
	LD	HL,nmiwr	;Code for write	
nmE
	OUT	(dskctl),A	;Select drive
	LD	(dkctlm),A	;Update copy

	DI			;In case clock ticks while testing <ticker>
	LD	A,(ticloc)
	OR	A		;Zero => motor already stopped.
	JR	NZ,going
	IN	A,(mstart)	;start the motor
going:	LD	A,080H		;Prevent it from stopping under clock ticks
	LD	(ticloc),A
	EI

;NB. After starting motor, the head load timer is not properly reset & will
;usually time out rather too soon. This does not matter, however, as
;it can be assumed that it takes longer for the drive to comnoblks	;Max number of blks that could possibly
mtloop:	PUSH	BC		;need writing
	CALL	cidle
	POP	BC
	DJNZ	mtloop
	RET



;PROCEDURE disc_rd(addr,length,offset:Word;VAR blk:block_descrip);
;
; Read in up to 1 block to specified address. <offset> is offset in block.
; Errors returned in common area <error>
;

discrd:	XOR	A
	LD	(errloc),A	;No error yet

	POP	HL
	EX	(SP),HL		;Get blockno. address

	CALL	fiblk		;Returns HL pointing to map entry
	JR	C,incach	;Carry => block already in cache
e to speed than
;the head load time, as the drive must do at least 1 rev to detect that it
;is up to speed, even if the motor was off only momentarily.

	IN	A,(fdtrk)
	CP	H		;Already at right trk?
	JR	Z,trkok

	INC	A
	CALL	Z,seekz		;trk=&FF <=> head pos not known
	LD	A,H
	OUT	(fddata),A	;Set up for seek

	LD	A,seek		;verify bit set only for settle time delay
	CALL	docmd		;NB. errors ignored as motor still running up

trkok:	IN	A,(fdstat)	;Wait for ready <=> motor full speed
	BIT	notrdy,A
	,prtxt
	POP	DE		;Restore the message character

ok4us:	CALL	dochar

	POP	HL
	POP	IY
	POP	BC
	POP	AF
	RET

systxt:	DB	12,'******* SYSTEM MESSAGES *******',13,10
syslen	EQU	$-systxt



; Code to do Pchar action. Preserves DE (only)

dochar:	PUSH	DE		;NB. E is parameter

pchar1:	LD	A,1
	PUSH	AF		;This will be pointed to as VAR count:Byte

	LD	HL,2
	ADD	HL,SP		;Get address of E on stack

;	Push 6 bytes of parameters to Print:

	PUSH	HL		;Data address
	DEC	HL		;Point to byte value 1 	JR	dundiv	


;Divide by five - by subtracting 5*2^n, n=7..0  (max 160 tracks)

div5:	XOR	A		;to receive bits of result

	LD	BC,-280H	;280H = 5*128 decimal
tscon1:	ADD	HL,BC
	JR	C,tscon0	;carry => HL-BC positive
	SBC	HL,BC		;repair HL (carry cleared)
tscon0:	RLA			;Insert bit from carry into A
	SRA	B
	RR	C		;Reduce 'n'
	JP	NC,tscon1	;Carry => part of the '5' has fallen out

	LD	H,A		;Swap regs - so correct for output

dundiv:	POP	BC

; Now have H=trk, L=sector, D=read flag, E=drive bits,ing (from 256Hz)
	LD	A,14		; time constant  13*1/256 =50.78ms
	OUT	(ctc0),A
	LD	HL,trkno
	LD	B,4
zaptab:	LD	(HL),0FFH
	INC	HL
	DJNZ	zaptab
	RET



;RWSEC
;Read/Write sector to/from disk
;
;On entry:
;	BC	RAM address to read/write
;	 D	Read flag (FF-read,0-write)
;	 E	Disk number
;	HL	sector no.
;
;On exit:
; A	Error code (0 = OK, 1=error)
;	(errloc) also updated


rwsec:
	PUSH	BC

	CALL	trkreg		;Init track reg & pointer to trk table

;Convert drive number into drive bits

	X BC=address

	SRL	H		;Modify track number (div 2)
	JR	NC,side0
	SET	sidsel,E	;Other side
side0:	INC	D		;D now 0 for read, 1 for write
	LD	D,rdsec
	JR	Z,rwdisc
	LD	D,wrsec

;drop through


;RWDISC - read, write, format disc.
;
; On entry :
;	BC	Ram address of data
;	D	FD command (expected to be read sec, write sec, or write trk)
;	E	drive sel, side sel, 5/8 inch to suit dskctl port
;	H	track
;	L	sector if reqd.
;
; <trkreg:> assumed to have been called
;
; On exit :
;	A	=0 if no erroOR	A
	LD	B,E
	INC	B		;As drive numbers start at 0
	SCF
cdrnol:	RLA
	DJNZ	cdrnol
	LD	E,A		;has a single bit set in it.

;Convert sector number HL into track H & sector L

	LD	A,(inches)	;1 bit per drive - =1 for 8inch
	AND	E
	JR	Z,div5		;5" have 5 sec/trk

	SET	inch8,E		;Set 8" bit in value to put in dskctl port

;Divide by eight

	LD	A,L
	AND	7		;Remainder MOD 8

	ADD	HL,HL		;*2
	ADD	HL,HL		;*4
	ADD	HL,HL		;*8
	ADD	HL,HL		;*16
	ADD	HL,HL		;*32
				; div 8 <=> *32 DIV 256
	LD	L,A
,5		;Cache to device op-code =5 for para,=11 serial
	CALL	to6502
	LD	A,D		;High byte of pointer
	SRL	A
	SRL	A		;Convert to (1K) page offset
	OR	040H		;Base page for parallel
	INC	B
	DEC	B
	JR	Z,ispara
	OR	080H		;Add base page for serial  (actually 0C0H)
ispara:	CALL	to6502
	LD	A,E		;Offset in page (lo)
	CALL	to6502
	LD	A,D		;Hi byte - only lo 2 bits relavent
	AND	3
	CALL	to6502

;	Compute byte count - must not cross 1K boundary

	PUSH	DE		;Save pointer
	PUSH	HL		;& bytes in buffer
	LD	Aatus connected, so is
; assumed online.

offlin:	POP	HL
	EX	(SP),HL		;H:=channel no.
	DEC	H
	JR	Z,offpar
	XOR	A		;Serial printer, so assume online
	RET

offpar:	LD	A,4		;Test status op-code
	CALL	to6502
	CALL	wait65		;DMA task status - ignored here
	CALL	wait65		;Hardware status

	AND	060H		;b7=BUSY* - ignored. b6=PAPER END => offline
				;b5=(FAULT* & SELECT)* => offline if true

	RET	Z		;Return zero => online
	LD	A,1
	RET			;Return 1 <=> True => offline



;PCHAR
;
;Print charact,D		;Hi of pointer
	AND	0FCH		;A:=top byte of last page boundary
				;NB. if at a page boundary, A=Hi(ptr)
	ADD	A,4
	LD	H,A
	XOR	A		;NB. carry clear
	LD	L,A
	SBC	HL,DE		;HL=no. of bytes up to the next 1K boundary

	POP	DE		;DE:=no. of bytes in buffer
	PUSH	HL
	OR	A		;Clr carry
	SBC	HL,DE		;Carry if <noof bytes in buffer> bigger
	POP	HL
	JR	C,doto1K
	EX	DE,HL
	
doto1K:	POP	DE		;Restore pointer

;	Now HL=no of bytes to do, DE=pointer

	LD	A,L		;Lo
	CALL	to6502
	LD	A,H		;Hi
	CALL	to6502er in E.  All registers preserved
;Output is to printer given by (msgch)

pchar:	PUSH	AF
	PUSH	BC
	PUSH	IY
	PUSH	HL

	LD	A,(msgch)	;Get channel number to use (=1 or =2)
	LD	B,A		;Save it
	LD	HL,useflg	;point to message/user flags
	AND	(HL)
	JR	NZ,ok4us	;Already in use as message printer

	LD	A,(HL)		;Update flags
	OR	B
	LD	(HL),A

	PUSH	DE		;Save character

	LD	HL,systxt	;Print header for our output
	LD	D,syslen
prtxt:	LD	E,(HL)
	PUSH	HL
	CALL	dochar
	POP	HL
	INC	HL
	DEC	D
	JR	NZ

	ADD	HL,DE		;Calculate pointer value when transfer finished
	DEC	B
	INC	B
	JR	Z,para1
	LD	(sernxt),HL
	JR	exitdo
para1:	LD	(parnxt),HL
exitdo:	SCF
	SBC	A,A		;Sets A=0FFH, NZ, Carry.
	RET





;GETMEM
;
;This routine returns the first unavailible memory location on the
; machine in DE & returns to HL

getmem:	LD	DE,0
	JP	(HL)


; FUNCTION Offlin(channel:Byte):Boolean;
;
; Return hardware status of given printer (1=para,0=serial)
; Note that the serial printer has no hardware stRWBLK                          *
;**********************************************
;

;RWBLK
;Read/Write block to/from disk
;
;
;On entry:
; D	Read flag (&FF -> read, 0 -> write)
; IY	Points to map entry
;(page)	**NOT USED** (hence we can write blocks not at head of chain)
;
;On exit:
; C	Error code (0 = OK)
;	(errloc) also updated
; (IY)	Needs writing flag cleared always. Blockno zapped if read error

rwblk:	LD	(IY+1),0FFH	;Clear needs writing flag

	PUSH	IY
	POP	HL		;Calculate page no. doseri: and dopara:
; A=0 for para, =6 for seri. HL=free pointer, DE=next data pointer
; BC=current data pointer

doboth:	OR	A		;Clear carry
	SBC	HL,BC
	RET	Z		;Return if no chars - NB. carry clear if so.

	ADD	HL,BC		;Restore free pointer
	LD	B,A

;	Now have DE= new data pointer HL= free pointer
;	A=B=0 for parallel, =6 for serial

	ADD	A,4		;Status op-code -> =4 for para, =10 for seri
	CALL	to6502

	CALL	wait65		;ready-to-go byte
	PUSH	AF
	CALL	wait65		;Hardware status (ignored here)
	from table offset
	LD	BC,cacmap	;Start of table
	OR	A		;Clear carry
	SBC	HL,BC
	LD	A,L		;the answer (NB. 1K pages, so low 2 bits =0)
	OR	A,pagon		;Bit(s) to turn on paging
	OUT	(paport),A

	LD	L,(IY+2)	;blockno.
	LD	A,(IY+3)	; Hi byte also holds drive
	AND	3FH		;not any more
	LD	H,A		;HL=block no =sector no.

	LD	A,(IY+3)	;Drive
	RLCA
	RLCA
	AND	03H		;Now back in right place
	LD	E,A

	LD	BC,secbuf	;Ram address where paged RAM appears
	PUSH	DE
	CALL	rwsec
	POP	DE
	LD	C,A		;Error code (POP	AF
	OR	A
	SCF			;Indicate chars in buffer
	RET	Z		;Return if busy

;	Transfer complete - copy new pointer to old

	LD	A,B
	OR	A		;Carry cleared here - used later
	JR	Z,para2		;A=0 <=> parallel
	LD	(serptr),DE
	JR	ser2

para2:	LD	(parptr),DE	;DMA transfer complete, so move ptr to nxt pos

ser2:	SBC	HL,DE		;Compute no. of chars in buffer
	RET	Z		;Now no chars in buffer - NB. carry clear.

;	Now have DE= data pointer, HL= no. of chars in buffer
;	A=B=0 if parallel, =6 if serial

	ADD	A=0 for no error)

	LD	A,pagoff
	OUT	(paport),A

	LD	A,C		;=0 if no error
	AND	D		;=0 if write
	RET	Z
	LD	(IY+2),0FFH	;Error during read, so cache now holds junk.
	LD	(IY+3),0FFH	;Mark as empty.
	RET


	ENDIF

; Dkinit
;
; Set up hardware ready for use.

dkinit:	XOR	A
	OUT	(dskctl),A	;Deselect all drives
	LD	(dkctlm),A	;Set up RAM copy
	LD	(ticloc),A	;Indicate stopped
	IN	A,(mstop)	;Stop drive motors
	LD	A,ctcset	;Wind up timer for head load
	OUT	(ctc0),A	;ctc0 controls head load timmapptr+2	;+2 => point to map address (low)
	ADD	HL,BC		;HL+:= A * 4
	ADD	HL,BC

	;Prepare to call Heap(VAR p:ptr,size:Word);

	PUSH	HL		;Save map pointer
	PUSH	DE		;and length info

	PUSH	HL		;1st parameter
	PUSH	DE		;2nd
	CALL	heap
	JR	Z,heaped	;FALSE => no room on heap

	POP	BC		;Length
	POP	HL		;Points to pointer table - address of the
				;bit of heap just got inserted here


	LD	E,(HL)		;Get address of map
	INC	HL
	LD	D,(HL)
	DEC	HL
	DEC	HL
	LD	(HL),B		;Also save length
	DEC	HL writing flag
	OR	A
	JR	NZ,idl1		;Doesn't need it

	PUSH	BC
				;D already contains 0 (meaning write)
	CALL	rwblk

	POP	BC
	DEC	B
	RET	Z		;Written as many as we want to

idl1:	LD	E,(IY+0)	;pointer to next entry in chain
	DEC	C		;Counter to prevent checking more entries
	JR	NZ,idloop	;than there are cache entries

	RET




;PROCEDURE cempty
;
;Write out any part of the cache which still has things in.
; Not called very often, so implemented compactly rather than fast.

cempty:	LD	B,
	LD	(HL),C

	LD	H,D		;Get start
	LD	L,E
	INC	DE		;Clear map
	DEC	BC
	LD	(HL),-1

	tmess	<naloc0,BC,naloc1,HL,crlf>

	LDIR

	POP	DE		;Reset bits in last byte to indicate
	LD	A,E		; if not all availible
	AND	7
	JR	Z,inidk0
	LD	B,A
	SUB	A
inidk1:	SCF
	RLA
	DJNZ	inidk1
inidk0:	LD	(HL),A

	RET




;Heap error (overflow)

heaped:	error	'Heap oflow'





;PROCEDURE cidle
;
; Use FS idle time to write out any of the cache that needs it.
; Starts from the head, which means thmess


sjmess:	DEFM	'SJ Research File Server ver '
	DEFW	verhi,verlo

	DEFM	'/FDFS'

crlf:	DEFM	0DH,0AH,'$'


	IF	0		;Dhxout is not used
;dhxout
;Print hex of HL

dhxout:	LD	A,H
	CALL	cahex
	LD	A,L
				;DROP THROUGH
;cahex
;Print hex of A
;
;On entry:
; A	number to be printed

	JP	cahex		;Now lives in h2lib or some such place

	ENDIF

fatmsg:	DEFM	0DH,0AH,'Fatal disc error $'
errmsg:	DEFM	' Error $'


	IF	0
;
;**********************************************
;* DKMAN STYLE at under heavy loading the items
; near the tail will never be written. However, these items will tend
; to get written anyway as the entries are either used & brought back
; to the top of the cache, or get thrown out to make space for new entries.

cidle:	LD	A,(page)
	LD	E,A		;place to start
	LD	A,noblks	;Maximum no. of ents worth looking at
	LD	C,A
	LD	B,3		;Maximum no. of blocks we have time to write

idloop:	LD	IY,cacmap
	LD	D,0		;Turn E into 16-bit value
	ADD	IY,DE
	LD	A,(IY+1)	;Get needsretry


nmird:	EXX			;NMI routines for read or write
	EX	AF,AF'
	INI
	EX	AF,AF'
	EXX
	RETN

nmiwr:	EXX
	EX	AF,AF'
	OUTI
	EX	AF,AF'
	EXX
	RETN





;TRKREG - set up track register from table
;
; On entry :
;	E	Drive no
;
; On exit :
;	A	current track
;	track reg in FDC loaded from table
;	(trkptr) holds address in track table
;	All regs preserved except AF

trkreg:	PUSH	HL
	LD	A,D		;Save D
	LD	D,0
	LD	HL,trkno
	ADD	HL,DE
	LD	D,A		;Restore
	LD	(trkptr),HL
	LD	A,(HL)
	OUDRV - initialise for 1 drive.
; Sets up 5/8 inch flag by measuring the index hole frequency
;
; On entry :
;	E	Drive number
; On exit :
;	E	Drive bits suitable for dskctl latch
;	AF	=0 if no drive not ready, =1 otherwise
;	Other regs preserved

inidrv:	PUSH	HL
	PUSH	BC

;Convert drive number into drive bits

	XOR	A
	LD	B,E
	INC	B		;As drive numbers start at 0
	SCF
inid1:	RLA
	DJNZ	inid1
	LD	E,A		;has a single bit set in it.


	OUT	(dskctl),A	;Select drive
	LD	(dkctlm),A	;& update coT	(fdtrk),A
	POP	HL
	RET


; SEEKZ - seek trk 0
;
; Preserves all regs except AF.
; Track not verified.
; Assumes drive selected.

seekz:	LD	A,frcint	;Force int <=> force type 1 status
	CALL	docmd
	IN	A,(fdstat)
	BIT	trk0,A
	JR	Z,noinc		;No track inc unless already at trk 0
	LD	A,trkinc	;Move head away so that it is re-positioned
	CALL	docmd
noinc:	LD	A,home
;	JP	docmd		;Drop through



; DOCMD - execute FDC command & wait for completion
;
; On entry :
;	A	command byte
;
; On exipy

	LD	HL,ticloc
	DI			;In case it stops during test
	LD	A,(HL)
	LD	(HL),080H	;Wind up motor	(forever)
	EI
	SLA	A		;=0 if previously stopped, >1 otherwise
	LD	L,A		;Very short timeout if already running
	LD	H,0		;otherwise about 1s
	IN	A,(mstart)

	LD	A,frcint	;Force int <=> force type 1 status
	CALL	docmd

inid2:	DEC	HL		; 6t
	LD	A,L		; 4t
	OR	H		; 4t
	JR	Z,nodisc	; 7t	Give up
	EX	(SP),HL		;19t	Increase timeout
	EX	(SP),HL		;19t
	NOP			; 4t
	IN	A,(fdstat)	;11t	Wait for drive to go rdt :
;	A	status reg - including error bits
;
; All regs except AF preserved

docmd:	OUT	(fdctrl),A
	CALL	fdcdel		;Delay for FDC status to be valid
cmdwai:	IN	A,(fdstat)
	BIT	busy,A
	JR	NZ,cmdwai
	RET	


; FDCDEL - delay time for FDC status reg to become valid after command issued
;
; Preserves all regs
; delay is 56 us (allowing for 5" single density)

fdcdel:	PUSH	BC		;Total 336T to burn. Excluding the DJNZ,
	LD	B,290/13	;we have 55T, so 281 left
	DJNZ	$
	POP	BC
	RET






; INIM copy of this port at <dkctlm>


fdbase	EQU	004H		;2793 address
fdctrl	EQU	fdbase
fdstat	EQU	fdbase
fdtrk	EQU	fdbase+1
fdsec	EQU	fdbase+2
fddata	EQU	fdbase+3

;status bits

busy	EQU	0
index	EQU	1
trk0	EQU	2
notrdy	EQU	7

;FDC commands

home	EQU	008H	;Seek trk 0 + Step 3|6mS + Head Load + no verify
seek	EQU	01CH	;Seek trk n + Step 3|6ms + Head Load +    verify
rdsec	EQU	080H	;Read 1 sec + No settle time + No side compare
wrsec	EQU	0A0H	;Write 1 sec + No settle + no side comp + Data mar	enaint		;Reenable net
	LD	HL,(trkptr)	;Update trk table
	IN	A,(fdtrk)
	LD	(HL),A

	POP	AF		;Restore error code from <docmd>

	LD	HL,errloc
	LD	(HL),0

	AND	0DCH		;Mask out bits not signalling errors
	JR	Z,noerr

	LD	(HL),0C7H

	LD	HL,retryc
	DEC	(HL)
	PUSH	AF		;Save Z flag particularly

	LD	DE,errmsg	;Display error message
	JR	NZ,nonfat
	LD	DE,fatmsg	;Fatal disc error
nonfat:	CALL	pmess
	POP	AF
	PUSH	AF		;Get error number
	CALL	cahex
	POP	AF		;Restore Z flag - NZ => retry worthwilk
trkinc	EQU	058H	;+1 Trk + inc reg + Step 3|6mS + Head Load + No Verify
writrk	EQU	0F4H	;Write track + settle time
frcint	EQU	0D0H	;Force interrupt never <=> force type 1 status

maxtry	EQU	4	;Max number of attempts on disc commands

ctc0	EQU	038H		;Head load timing channel

ctcset	EQU	07FH		;value to init (followed by time const in secs)
ctcrst	EQU	07BH		;value to reset (ie start timed period again)



;
; PROCEDURE ver_msg;		prints SJ FS ver etc. on screen
;

vermsg:	LD	DE,sjmess
	JP	pe


	LD	A,1		;Return TRUE, indicating error

noerr:	EXX
	POP	BC
	POP	HL
	EXX
	EX	AF,AF'
	;AF' already corrupt, so this is a convenient place to set the
	;motor stop timer
	LD	A,mtrtim
	LD	(ticloc),A

	POP	AF		;Retore user's AF'
	EX	AF,AF'
	
	POP	BC
	POP	HL
	POP	DE

	RET	Z		;If no error, we got here from JR Z
 				;otherwise Z is set from DEC of retry counter
				;=> exit if no error or max retries reached.
	LD	A,0FFH		;Clear track reg to force a seek0 next time
	OUT	(fdtrk),A
	JP	miwr	;Code for write	
nmi1:	LD	DE,nmivec
	LD	BC,nmiwr-nmird
	LDIR

	CALL	docmd		;Returns when done. Data transfers under NMI

	PUSH	AF		;Save error code

	BIT	5,D		;If a write command, 1ms delay required
				;for tunnel erase to complete
	JR	Z,notunl

;	1ms =6000T, but the minimum to next FDC command is 230T (via FORMAT)
;	so we need to waste 5770T

	LD	HL,5770/26
tunnel:	DEC	HL		;  6T
	LD	A,H		;  4T
	OR	L		;  4T
	JR	NZ,tunnel	; 12T if jump taken
				;Total for loop =26T

notunl:	CALLafter writing data in

	POP	HL
	POP	DE
	POP	BC
	JR	rdywr


;fiblk
;
;Find block in cache.
; If block not found, return the tail of the chain, making it the head
; then writing out if necessary & inserting the new info in the map.
;
;On entry:
; HL	address of block descriptor (drive then block)
;
;On exit:
;(page)	updated
; IY	points to entry in cacmap
; cf	set	Found
;	clear	Not found
;
; HL,DE,BC registers all used
;

fiblk:

;Put drive in top 2 bits of block number

	LD	A,(HL).Z80
TITLE	'FRANCIS Disc routines'
NAME	('FRDISC')

true	EQU	-1
false	EQU	0

	EXT	no_int,enaint	;Net enable/disable. Must preserve all but AF.
	EXT	fastfl		;Flush FAST output buffer
	EXT	fdata,newtrk	;UFORMAT externals
	EXT	nmivec

	PUBLIC	dkinit,format,rwblk,vermsg,chksj,openca

	EXT	pmess, cahex, verhi, verlo

inrom	EQU	True


;Block 0 offsets

sjoff	EQU	64		;Offset to 'SJ Research File Server'




; port addresses

paport	EQU	034H		; Paged RAM/ROM control
pagon	EQU	3		;value 			;Drive
	RRCA
	RRCA				;Put in top 2 bits
	INC	HL
	LD	E,(HL)			;Lo(block)
	INC	HL
	OR	(HL)			;Hi byte add to drive bits
	LD	D,A
	EX	DE,HL

;	fudge to get started - note that link pointer is at start of map entry

	LD	IY,page			;Start of chain - IY usually points to
					; the previous entry
	LD	D,0

;	HL=block/drive no, D=0
;	In loop, DE=page no, C=previous page no.

	LD	A,noblks		;Number of entries to search
	LD	B,A			;For DJNZ

filoop:	LD	C,E			;Save previous pageno
	LD	E,(IY+0)		for paged RAM open, ROM off
pagoff	EQU	1		;value for CLOSED
romoff	EQU	1		;Set if ROM off

mstart	EQU	035H		;Read port to start disc motor
mstop	EQU	036H		;similarly to stop.

mtrtim	EQU	10		;No. of seconds for drive motors to run

dskctl	EQU	037H		;Disc density, sidesel & drive sel port
precmp	EQU	7		;Hi for precomp **NOT USED**
sinden	EQU	6		;Hi for single density **NOT USED**
inch8	EQU	5		;Set for 8" data rate
sidsel	EQU	4		;=1 for side 1
				;Bits 0..3 are drive selects
;NB. there is a RA;Advance to next
	LD	IY,cacmap		;Calculate address of cacmap entry
	ADD	IY,DE

	LD	A,(IY+2)
	CP	L
	JR	NZ,filop1		;No good
	LD	A,(IY+3)		;Test hi byte
	CP	H
	JR	Z,found			;Both agree

filop1:					;Get here if this block no good
	DJNZ	filoop			;Fall through if we have tried all ents

; Now have tail of chain

	PUSH	HL			;Save blockno.
	CALL	setpag			;Make this into head of chain
	LD	A,(IY+1)		;Needs writing flag
	OR	A			; sets Zf, also clears Cf
	JR	NZ,setblk		;Not required, so just insertess	<frblk0,HL,alblk1,AF,crlf>

	CALL	getblk
	OR	(HL)
	LD	(HL),A
	RET



;PROCEDURE alloc (blk: block_descrip);

alloc:	POP	HL		;Return address
	EX	(SP),HL		;Blk address

	LD	A,(HL)		;Get drive
	INC	HL
	LD	B,(HL)		; & block number
	INC	HL
	LD	H,(HL)
	LD	L,B

;	tmess	<alblk0,HL,alblk1,AF,crlf>

	CALL	getblk
	CPL
	AND	(HL)
	LD	(HL),A
	RET



;GETBLK
;Converts Map number & Block Number into address and bit number
;
;On entry:
; A	Map number
; HL	Block number
;
;On exit:
;


;PROCEDURE fblk (VAR block: block_descrip; VAR no_block: WORD);
;
;Attempt to find up to no_block blocks starting from block_descrip

fblk:	POP	HL		;Return address
	POP	BC		;no_block
	EX	(SP),HL		;block_descrip
	PUSH	IX
	PUSH	BC

fstart:	LD	A,(HL)		;Drive
	INC	HL
	PUSH	HL		;Save address of block number
	LD	E,(HL)		;get block number
	INC	HL
	LD	D,(HL)

	EX	DE,HL
	PUSH	HL
	CALL	getblk
	LD	C,8
	CP	A		;Clear carry for RRA
	DEC	B
	LD	A,(HL)
	JR	Z,fblk1
fblk0:	RRA
	DEC	C
	DJNZ	fbl A	Byte with bit set
; B	1 - 8 => Bit number
; DE	Points to low byte of address in MAPPTR (length @(DE-2))
; HL	Address of byte

getblk:	PUSH	HL

	CP	noofdr
	JP	NC,maperr

	ADD	A,A
	ADD	A,A
	LD	C,A
	LD	B,0
	LD	HL,mapptr+3
	ADD	HL,BC
	EX	(SP),HL

	LD	A,L		;HL/8, A=Remainder
	AND	7
	SRL	H
	RR	L
	SRL	H
	RR	L
	SRL	H
	RR	L

	LD	B,A		;Set bit A in A
	INC	B
	LD	C,B
	SUB	A
	SCF
getbl1:	RLA
	DJNZ	getbl1

	POP	DE
	PUSH	BC
	EX	DE,HL
	LD	B,(HL)		;BC:= address of map
	DEC	HL
	LD	Cblock descriptor for inidsk:
	DEFS	2		; to use as a parameter to rddisc: & alloc:



;	******* MAPMAN AREAS *********

lstadr:	DEFS	2		;Address of last block found

mapptr:	DEFS	noofdr*4	;( length (2) + mapptr (2) ) * noofdr


	END
acks of drvs 0..3

dkctlm:	DEFS	1		;Ram copy of <dskctl> port

;	Cache	DSEG

drvtab:	DEFS	noofdr		;Table to map logical drv nos to physical.

cacmap:	DEFS	noblks*4	;Cache sector map

page:	DEFS	1		;Current cache page

bldes:	DEFS	1		;This is a ,(HL)

	IF	c.on		;** Range check block **

	PUSH	AF		;Check map exists
	LD	A,B
	AND	C
	INC	A
	JP	Z,maperr

	PUSH	HL		;Check valid block number
	DEC	HL
	LD	A,(HL)
	DEC	HL
	LD	L,(HL)
	LD	H,A
	CP	A
	SBC	HL,DE
	JP	C,ranerr

	POP	HL
	POP	AF

	ENDIF			;** End of range check **

	EX	DE,HL
	ADD	HL,BC
	POP	BC
	LD	B,C
	RET


	IF	c.on

;Bad map number / map not initialized

maperr:	error	'Bad map number'

;Block number out of range

ranerr:	error	'Duf block number'

	ENDIF

	;we have 55T, so 281 left
	DJNZ	$
	POP	BC
	RET



; INIDRV - initialise for 1 drive.
; Sets up 5/8 inch flag by measuring the index hole frequency
;
; On entry :
;	E	Drive number
; On exit :
;	E	Drive bits suitable for dskctl latch
;	AF	=0 if no drive not ready, =1 otherwise
;	Other regs preserved

inidrv:	PUSH	HL
	PUSH	BC

;Convert drive number into drive bits

	XOR	A
	LD	B,E
	INC	B		;As drive numbers start at 0
	SCF
inid1:	RLA
	DJNZ	inid1
	LD	E,A		;has a single bit set in it.37T/42T per loop
	EI

; 8" runs at 6 revs/sec =   1E6 T per rev = 27027 iterations of loop
; 5" runs at 5 revs/sec = 1.2E6 T per rev = 32432 iterations of loop
; Hence mid pt. = 29729, just over &7400
; IF in rom:
; 8"=23809, 5"=28571 iterations mid pt=26190 ~=&6600

	LD	A,H

	IF	inrom
	CP	067H
	ELSE
	CP	075H		;Carry if 8"
	ENDIF

	LD	C,0		;No bit set
	JR	NC,inid5
	LD	C,E		;Get drive bit
	SET	inch8,E

inid5:	LD	HL,inches
	LD	A,E
	CPL			;Clear bit for this drive
	AND	(HL)		;get other


	OUT	(dskctl),A	;Select drive
	LD	(dkctlm),A	;& update copy

	LD	HL,ticloc
	DI			;In case it stops during test
	LD	A,(HL)
	LD	(HL),080H	;Wind up motor	(forever)
	EI
	SLA	A		;=0 if previously stopped, >1 otherwise
	LD	L,A		;Very short timeout if already running
	LD	H,0		;otherwise about 1s
	IN	A,(mstart)

	LD	A,frcint	;Force int <=> force type 1 status
	CALL	docmd

inid2:	DEC	HL		; 6t
	LD	A,L		; 4t
	OR	H		; 4t
	JR	Z,nodisc	; 7t	Give up
	EX	(SP),HL		;19t	Increase timeout
	EX	(SP),HL	 drive bits
	OR	C		;Set our bit as appropriate
	LD	(HL),A	
	XOR	A		;Indicate success
	INC	A
nodisc:	LD	HL,ticloc	;Entered here with A=0 if timed out
	LD	(HL),mtrtim	;Stop drive after usual time
	POP	BC
	POP	HL
	RET





;
;  ****** BIT MAP MANAGEMENT CODE STARTS HERE *************
;
;


;PROCEDURE dalloc (blk: block_descrip);

dalloc:	POP	HL		;Return address
	EX	(SP),HL		;Blk address

	LD	A,(HL)		;Get drive
	INC	HL
	LD	B,(HL)		; & block number
	INC	HL
	LD	H,(HL)
	LD	L,B

	tm	;19t
	NOP			; 4t
	IN	A,(fdstat)	;11t	Wait for drive to go rdy 
	BIT	notrdy,A	; 8t	<=> up to speed
	JR	NZ,inid2	;12t =94t *65536 <=> 1.03 seconds

	DI			;For software timing

inid6:	IN	A,(fdstat)
	BIT	index,A		;Wait for index hole also
	JR	Z,inid6

inid3:	IN	A,(fdstat)	;Start timing at end of index
	BIT	index,A
	JR	NZ,inid3

	LD	HL,0		;Timer
inid4:	IN	A,(fdstat)	; 11T/12T if in ROM
	INC	HL		; 6T/7T
	BIT	index,A		; 8T/10T
	JR	Z,inid4		; 12T/13T except when dropping through
				; total = 	CALL	enaint		;Reenable net
	LD	HL,(trkptr)	;Update trk table
	IN	A,(fdtrk)
	LD	(HL),A

	POP	AF		;Restore error code from <docmd>

	LD	HL,errloc
	LD	(HL),0

	AND	0DCH		;Mask out bits not signalling errors
	JR	Z,noerr

	LD	(HL),0C7H

	LD	HL,retryc
	DEC	(HL)
	PUSH	AF		;Save Z flag particularly

	LD	DE,errmsg	;Display error message
	JR	NZ,nonfat
	LD	DE,fatmsg	;Fatal disc error
nonfat:	LD	A,(mesflg)
	OR	A
	JR	Z,nomsg		;Test for debug flag
	CALL	pmess
	POP	AF
	PUSH	AF		;Get error numberkno
	ADD	HL,DE
	LD	D,A		;Restore
	LD	(trkptr),HL
	LD	A,(HL)
	OUT	(fdtrk),A
	POP	HL
	RET


; SEEKZ - seek trk 0
;
; Preserves all regs except AF.
; Track not verified.
; Assumes drive selected.

seekz:	LD	A,frcint	;Force int <=> force type 1 status
	CALL	docmd
	IN	A,(fdstat)
	BIT	trk0,A
	JR	Z,noinc		;No track inc unless already at trk 0
	LD	A,trkinc	;Move head away so that it is re-positioned
	CALL	docmd
noinc:	LD	A,home
;	JP	docmd		;Drop through



; DOCMD - execute FDC command r
	CALL	cahex
nomsg:	POP	AF		;Restore Z flag - NZ => retry worthwile


	LD	A,1		;Return TRUE, indicating error

noerr:	EXX
	POP	BC
	POP	HL
	EXX
	EX	AF,AF'
	;AF' already corrupt, so this is a convenient place to set the
	;motor stop timer
	LD	A,mtrtim
	LD	(ticloc),A

	POP	AF		;Retore user's AF'
	EX	AF,AF'
	
	POP	BC
	POP	HL
	POP	DE

	RET	Z		;If no error, we got here from JR Z
 				;otherwise Z is set from DEC of retry counter
				;=> exit if no error or max retries reached.
	LD	A,0F& wait for completion
;
; On entry :
;	A	command byte
;
; On exit :
;	A	status reg - including error bits
;
; All regs except AF preserved

docmd:	OUT	(fdctrl),A
	CALL	fdcdel		;Delay for FDC status to be valid
cmdwai:	IN	A,(fdstat)
	BIT	busy,A
	JR	NZ,cmdwai
	RET	


; FDCDEL - delay time for FDC status reg to become valid after command issued
;
; Preserves all regs
; delay is 56 us (allowing for 5" single density)

fdcdel:	PUSH	BC		;Total 336T to burn. Excluding the DJNZ,
	LD	B,290/13FH		;Clear track reg to force a seek0 next time
	OUT	(fdtrk),A
	JP	retry


nmird:	EXX			;NMI routines for read or write
	EX	AF,AF'
	INI
	EX	AF,AF'
	EXX
	RETN

nmiwr:	EXX
	EX	AF,AF'
	OUTI
	EX	AF,AF'
	EXX
	RETN





;TRKREG - set up track register from table
;
; On entry :
;	E	Drive no
;
; On exit :
;	A	current track
;	track reg in FDC loaded from table
;	(trkptr) holds address in track table
;	All regs preserved except AF

trkreg:	PUSH	HL
	LD	A,D		;Save D
	LD	D,0
	LD	HL,tg:> assumed to have been called
;
; On exit :
;	A	=0 if no error, =1 otherwise
; ALL OTHER REGS PRESERVED

rwdisc:	LD	A,maxtry
	LD	(retryc),A
retry:	PUSH	DE
	PUSH	HL
	PUSH	BC

	LD	A,(dkctlm)	;Copy of current disc select state
	XOR	E		;Compare with new drive
	AND	0FH		;Mask out side or density changes
	JR	Z,samedr
	LD	A,ctcset	;Wind up timer for head load
	OUT	(ctc0),A	;ctc0 controls head load timing (from 256Hz)
	LD	A,14		; time constant  13*1/256 =50.78ms
	OUT	(ctc0),A

	IN	A,(mstart)	,(fdstat)	;Wait for ready <=> motor full speed
	BIT	notrdy,A
	JR	NZ,trkok

	LD	A,L		;Sector no.
	OUT	(fdsec),A

	CALL	no_int		;temp disable net

;	Set up alt regs for NMI rtn

	EX	AF,AF'		;Save alt regs contents
	PUSH	AF
	EX	AF,AF'

	PUSH	BC		;Data addr
	EXX
	EX	(SP),HL		;HL':=^data, (SP):=old HL'
	PUSH	BC		;save HL',BC'
	LD	C,fddata	;port no
	EXX

;	Install appropriate NMI rtn

	LD	A,D		;Command
	BIT	5,D		;Test for read or write command
	LD	HL,nmird	;Code for read
	JR	Z,nmi1
	LD;Motor start also clears 'head loaded' flipflop

samedr:	LD	A,E
	OUT	(dskctl),A	;Select drive
	LD	(dkctlm),A	;Update copy

	DI			;In case clock ticks while testing <ticker>
	LD	A,(ticloc)
	OR	A		;Zero => motor already stopped.
	JR	NZ,going
	IN	A,(mstart)	;start the motor
going:	LD	A,080H		;Prevent it from stopping under clock ticks
	LD	(ticloc),A
	EI

;NB. After starting motor, the head load timer is not properly reset & will
;usually time out rather too soon. This does not matter, however, 	HL,nmiwr	;Code for write	
nmi1:	LD	DE,nmivec
	LD	BC,nmiwr-nmird
	LDIR

	CALL	docmd		;Returns when done. Data transfers under NMI

	PUSH	AF		;Save error code

	BIT	5,D		;If a write command, 1ms delay required
				;for tunnel erase to complete
	JR	Z,notunl

;	1ms =6000T, but the minimum to next FDC command is 230T (via FORMAT)
;	so we need to waste 5770T

	LD	HL,5770/26
tunnel:	DEC	HL		;  6T
	LD	A,H		;  4T
	OR	L		;  4T
	JR	NZ,tunnel	; 12T if jump taken
				;Total for loop =26T

notunl:as
;it can be assumed that it takes longer for the drive to come to speed than
;the head load time, as the drive must do at least 1 rev to detect that it
;is up to speed, even if the motor was off only momentarily.

	IN	A,(fdtrk)
	CP	H		;Already at right trk?
	JR	Z,trkok

	INC	A
	CALL	Z,seekz		;trk=&FF <=> head pos not known
	LD	A,H
	OUT	(fddata),A	;Set up for seek

	LD	A,seek		;verify bit set only for settle time delay
	CALL	docmd		;NB. errors ignored as motor still running up

trkok:	IN	A0

	LD	D,hour
setcl4:	INC	HL		;1st time round points to new hours
	CALL	write		;(HL) in decimal
	DEC	D
	JP	P,setcl4	;stops when D=-1 ie just written secs reg


;now start clock - NB D=0FFH ie select status register

	LD	A,1
	JP	writck		;and finish



; WRITEA - write contents of A to RTC. Uses (HL) as workspace !!!

writea:	LD	(HL),A

; WRITE	- write contents of (HL) to RTC register sepcified by D

write:	PUSH	BC

;convert to BCD

	XOR	A
	RLD			;top nibble to A lo

	LD	B,4
writ
	DEC	C
	DJNZ	fblk0
fblk1:	LD	B,C
	PUSH	AF
	PUSH	BC
	PUSH	HL
	EX	DE,HL
	INC	HL
	LD	D,(HL)
	DEC	HL
	LD	E,(HL)
	DEC	HL
	LD	B,(HL)
	DEC	HL
	LD	C,(HL)
	EX	DE,HL
	ADD	HL,BC
	POP	BC
	PUSH	BC
	POP	IX
	CP	A
	SBC	HL,BC
	EX	DE,HL
	POP	BC
	POP	AF
	POP	HL
	LD	C,8
	JP	fblk3

;Main find loop
;
;On entry:
; BC	8
; DE	number of bytes to search before giving up
; HL	start block number
; IX	pointer to current byte to search

fblk4:	LD	A,(IX+0)
	OR	A
	JR	NZ,fblk6
	ADD	HL,BC
	JP	fblk5
e1:	ADD	A,A
	DAA
	DJNZ	write1

	LD	B,A
 	XOR	A
	RLD			;A=lo nibble of 
	ADD	A,B
	DAA			;A now in BCD
	POP	BC


;WRITCK
;write an RTC register
;
;On entry:
; D	register to write
; A	value to write
;
;On exit:
; A	naff
; rest	OK
; IRQs	on

writck:	PUSH	BC

	LD	B,A
	CALL	w3000		;Returns with Irq disabled
	OUT	(C),D
	LD	A,B

	RRCA
	RRCA
	RRCA
	RRCA			;top nibble in A
	OUT	(C),A
	OUT	(C),B		;lo nibble
	EI

	LD	B,40		;Delay so that next write succeeds
	DJNZ	$

	POP	BC
	R:	POP	BC

; Now have H=trk, L=sector, D=read flag, E=drive bits, BC=address

	SRL	H		;Modify track number (div 2)
	JR	NC,side0
	SET	sidsel,E	;Other side
side0:	INC	D		;D now 0 for read, 1 for write
	LD	D,rdsec
	JR	Z,rwdisc
	LD	D,wrsec

;drop through


;RWDISC - read, write, format disc.
;
; On entry :
;	BC	Ram address of data
;	D	FD command (expected to be read sec, write sec, or write trk)
;	E	drive sel, side sel, 5/8 inch to suit dskctl port
;	H	track
;	L	sector if reqd.
;
; <trkreET



	COMMON	/now/

now1:	DS	5

	DSEG

rdate:	DS	1		;date origin 1
rmonth:	DS	1		;month (LO,origin 1) and year (HI, origin 1981)
rhour:	DS	1
rmin:	DS	1
rsec:	DS	1

	COMMON	/error/

errloc:	DS	1


	COMMON	/ticker/

ticloc:	DS	1		;Used to stop disc motors


	COMMON	/timout/

tim1:	DS	1		;Timeout counters - count down to 0 at 1Hz
tim2:	DS	1		;if <128. Used for printer timeouts.


	END
ress
;
;On exit:
; A,(HL) register contents IN HEX
; C	points to clock port
; rest	preserved

read:	CALL	readck
	LD	A,(HL)

;tohex
;On entry:
; A	BCD number
;
;On exit:
; A,(HL) hex number
; rest	preserved

tohex:	PUSH	BC
	LD	C,A
	RRCA
	RRCA
	RRCA
	RRCA
	AND	15
	ADD	A,A		;*2
	LD	B,A
	ADD	A,A		;*4
	ADD	A,A		;*8
	ADD	A,B		;*10
	LD	B,A
	LD	A,C		;this contains some of the hi-nibble set
	AND	15
	ADD	A,B		;and add lo-nibble
	POP	BC
	LD	(HL),A
	RET


;READCK
;Read a registerBC),A

;now range check

	LD	A,(HL)		;Date 1..31 (not bothering about months yet)
	INC	HL
	OR	A
	RET	Z
	CP	32
	RET	NC

	LD	A,(HL)		;months (lo-nibble) 1..12
	AND	15
	INC	HL		;years don't need checking
	OR	A
	RET	Z
	CP	13
	RET	NC

	LD	A,(HL)		;hours 0..23
	INC	HL
	CP	24
	RET	NC

	LD	A,(HL)		;mins 0..59
	INC	HL
	CP	60
	RET	NC

	LD	A,(HL)		;secs 0..59
	CP	60
	RET	NC

; new time is OK - set no error

	XOR	A
	LD	(BC),A

; Update RAM copy

	LD	DE,rsec		;HL points to last by from RTC
;
;On entry:
; D	register to be read
; HL	points to 1-byte block where reg will be stored

readck:	CALL	w3000		;Returns with irq disabled
	OUT	(C),D
	IN	A,(C)
	LD	(HL),A
	IN	A,(C)
	EI
	RLD
	RET
;
;w3000
; Wait for m3000 to be ready.  Exits with IRQ disabled.


w3000:	LD	C,clock

w3001:	EI
	NOP			;Allow IRQs to happen
	DI
	IN	A,(C)
	OR	0F0H
	INC	A
	JR	Z,w3001

;There is a bug in the M3000 st at the end of an update cycle the device goes
;not busy 32us before it actuallte of new copy
	LD	BC,5
	DI
	LDDR
	EI
	INC	HL		;Now points to start again

;now set time: stop clock

	LD	D,status
	LD	A,0
	CALL	writck		;writes A unmodified

;	HL points to start of new date

	LD	D,date
	CALL	write		;writes (HL) in decimal
	INC	HL
	INC	D		;month reg
	LD	B,(HL)
	LD	A,B
	AND	15
	CALL	writea		;write the months out
	INC	D		;year reg
	XOR	A
	LD	(HL),B
	RLD			;year to A low-nibble, 0 to hi
	ADD	A,81		;year was origin 81
	CALL	writea

;hms can go straight out to M300y goes ready, so we have to wait 32us....

; ** NEW INFO FROM Mr GREEN **
; delay actually has to be 100us !!!

	LD	A,100*6/(4+12)+1	;100us at 6MHz
w3002:	DEC	A
	JR	NZ,w3002

;but by this time it may have gone busy again...

	IN	A,(C)
	OR	0F0H
	INC	A
	JR	Z,w3001

	RET				;Not busy!




;PROCEDURE SetClk(address_of_new_time:Word);
;returns error=90H if date is invalid.


setclk:	POP	HL
	EX	(SP),HL		;HL=pointer to new date/time

	LD	BC,errloc
	LD	A,90H		;set error initially
	LD	(exit2		;No change
	;Drop through


; doexit:

; Turn on ROM, re-enter monitor.
;NB this code must NOT be underneath the ROM ie not in the area 0..3FFFH

doexit:	CALL	no_int		;No net interrupts
	DI
	LD	A,01
	OUT	(sbctrl),A	;No side B irqs either
	XOR	A
	OUT	(sbctrl),A

	LD	A,0FH		;ROM on
	OUT	(system),A

	JP	3		;and restart monitor




;
; PROCEDURE Dolist;

; Initiate transfers from buffers in cache to printer devices
; when buffers not empty & devices ready.

dolist:	CALL	dopaue of (HL)
;	Z set according to new (HL) value

dotim:	LD	A,(HL)
	OR	A
	RET	Z		;=0
	RET	M		; Minus <=> >127	
	DEC	(HL)
	RET



;RDCLK
;The algorithm I will use consists of the following:
; read all data
; read seconds again, if different do it all again
;

rdclk:
	LD	D,second
	LD	HL,rsec
	LD	B,3		;read 1st 3 regs directly into RAM

gethms:	CALL	read
	DEC	HL
	INC	D
	DJNZ	gethms

;date: D=date reg.

	DEC	HL		;=rdate
	CALL	read

; month and year are packed as nibbles into a sinra
;	JP	doseri		;Drop through.



; doseri:
; Initiate serial printer transfer if chars in buffer & printer ready

; On Exit : NC if buffers empty.
;	    NZ if a transfer just started, Z otherwise.
;	    All regs corrupt.

; Exit info used by Fsexit:

doseri:	LD	A,6		;Indicate serial
	LD	HL,(sersp)
	LD	DE,(sernxt)
	LD	BC,(serptr)
	JR	doboth

; Dopara:
; Do parallel printer transfers, as for doseri

dopara:	XOR	A
	LD	HL,(parasp)
	LD	DE,(parnxt)
	LD	BC,(parptr)

;Entered here from gle byte: month - lo

	INC	D		;=month reg
	INC	HL		;=rmonth
	CALL	read
	LD	B,A		;month in B
	INC	D
	CALL	read		;year origin 1900 in A
	SUB	81		;we require origin 1981
	LD	(HL),A		;year to lo-nibble
	LD	A,B
	RLD			;month to lo-nibble, year to hi

; now check seconds again

	LD	HL,rsec
	LD	B,(HL)
	LD	D,second
	CALL	read
	SUB	B
	JP	NZ,getclk	;go round again if failed

	INC	A		;A=1 ie TRUE
	RET			;OK




;read
;read an M3000 register
;
;On entry:
; D	register number
; HL	RAM add	CALL	rdclk
	JR	dunclk

tickok:	LD	(HL),A

dunclk:	LD	HL,ticloc	;Count down timer for disc motor
	CALL	dotim
	JR	NZ,exit		;New value of timer is non-zero
	OR	A
	JR	Z,exit		;Was already zero
	IN	A,(mtroff)	;Stop motor if just timed out
	XOR	A
	OUT	(dskctl),A	;And de-select drives

exit:	LD	HL,tim1		;Do timeout counters
	CALL	dotim
	INC	HL
	CALL	dotim

	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RETI


;dotim
;
; Decrement (HL) if in range 1..127 else leave unchanged
; On exit :
;	A=old valirst byte to be printed
serptr:	DS	2		;out by IRQ rtn.

paract:	DS	1		;Flags for active - ie. buffer not empty if <>0
seract:	DS	1		;NB. Assumed adjacent & in this order

useflg:	DS	1		;Bit 0 for parallel, Bit 1 for serial.
				;Set if in use as message printer, clear
				;if user printer

	END


er buffers.


parasp:	DS	2		;Points to the first free location
sersp:	DS	2		;in the buffer

parptr:	DS	2		;Points to the f1		;Switch is in stop pos
	AND	0AH		;Check for syst & back pannel switch together
	RET	NZ
chk1:	CALL	emptyC

;	JP	fsexit		*Fall through




;
; FSexit - exit to monitor. Must flush printer buffers 1st.

fsexit:	LD	A,08FH		;Turn 'Online' OFF
	LD	D,A
	OUT	(system),A

exit1:	IN	A,(status)
	BIT	3,A		;Back pannel switch
	JR	Z,exit1		;wait until released

	AND	0EH		;Get present pos of switches
	LD	E,A

; D=current LED state, E=current switch state.

exit2:	PUSH	DE

exit3:	INC	L		;Delayfor normal exit after time delay
;	Z	If exit caused by config switch OR key switch=off
;	HL=0	if normal exit

delay:	LD	HL,0
del2:	DEC	L
	JR	NZ,del2
	PUSH	HL
	CALL	dolist		;Let out any messages
	POP	HL

	IN	A,(status)	;Test for power off or exit to config mode
	BIT	2,A
	RET	Z		;Return if front pannel switch turned to STOP
	AND	0AH
	RET	Z		;Return if both SYSTEM pos of front switch
				;& also config mode switch pressed
	DEC	H
	JR	NZ,del2
	OR	A		;If A was zero, we would already have return, note that L=0 on exit
	JR	NZ,exit3
	PUSH	HL
	CALL	doseri		;flush serial printer
	POP	HL
	LD	A,L
	ADC	A,A		;A:=1 if some chars in buffer
	LD	L,A
	PUSH	HL
	CALL	dopara		;Flush parallel printer
	POP	HL
	LD	A,L
	ADC	A,A		;A=2 if both full, =0 if both empty, else =1
	JR	Z,doexit	;No chars in either buffer

	DEC	H
	JR	NZ,exit3	;Delay loop period ~.5sec

	POP	DE
	LD	A,D		;LED state
	XOR	8		;Flip online bit
	LD	D,A
	OUT	(system),A

	IN	A,(status)
	AND	0EH		;New switch state
	CP	E
	JR	Z,ed
	RET			;Hence we return NZ


;
; FUNCTION Syst_sw:Boolean;
;
; Return condition of key switch.
; bit 1 of status port is low if in syst pos.

systsw:	IN	A,(status)
	CPL			;Bit is active LOW
	AND	2
	RRCA			;return 0 (False) or 1 (True)
	RET



; PROCEDURE chksw;
;
; Routine to poll front pannel switches
;
; If switch is 'Off' OR
; If rear pannel reset is pushed AND front switch is in sys_priv position,
; then exit to maintainance mode.


chksw:	IN	A,(status)
	BIT	2,A
	JR	Z,chk
;	(SP)=return addr, (SP+2)=^byte count, (SP+4)=^data

doprnt:	POP	BC		;Return address
	POP	HL
	POP	DE
	PUSH	BC		;Now just return address on stack

;	DE=^data, A=1 for parallel =2 for serial, HL=^byte count

	DEC	A		;=0 if para, =1 if serial
	JR	NZ,prseri

;***********
;
; REMEMBER TO MODIFY FSEXIT: WHEN RE-WRITING THIS CODE
;
;***********



;
;	Temporary unbuffered parallel output
;
	LD	(HL),0		;No chars sent yet
	LD	A,(paract)
	OR	A
	RET	NZ		;Printer not ready
	INC	A		;A:=1
	L,parint	;Insert IRQ vector for parallel
	LD	(intct3),HL

	LD	HL,serint	;SIO interrupt vectors
	LD	(inttbb),HL
	LD	HL,exbint
	LD	(intexb),HL

	LD	A,1
	OUT	(sbctrl),A
	LD	A,7		;ExtIE=on, TXint=on, SAV
	OUT	(sbctrl),A

	EI

	LD	HL,intct0
	LD	A,L		;Low of int vector address
	OUT	(ctc0),A	;Set CTC interrupt base

	LD	A,0EFH		;Enable INT, counter mode, falling edge trigger
	OUT	(ctc3),A	; time constant follows.

	LD	A,1		;Time constant =1
	OUT	(ctc3),A

	LD	HL,parasp	;First of the bufferLD	(paract),A	;Clear ready flag
	LD	A,(DE)
	OUT	(pprint),A
	INC	(HL)		;Record char	
	RET

;	Temporary non-interrupt serial I/O

prseri:	LD	(HL),0		;Done 0 chars so far
	LD	A,(seract)
	OR	A
	RET	NZ		;Printer not ready
	INC	A		;A:=1
	LD	(seract),A	;Clear ready flag
	LD	A,(DE)
	OUT	(sbdata),A
	INC	(HL)		;Record char	
	RET

;
;	Parallel printer IRQ routine
;

parint:	EI
	PUSH	AF
	XOR	A		;Record ACK pulse
	LD	(paract),A
	POP	AF
	RETI

;
;	RS423 interrupt routines
;

exbint:	EI		 pointers
	LD	B,11		;8 bytes of pointers + 2 active flags + useflg
flush1:	LD	(HL),0
	INC	HL
	DJNZ	flush1

	RET







	COMMON	/messag/
mess:	DS	1

	COMMON	/debug/
debu:	DS	1

	COMMON	/pacopy/

copy:	DEFS	1		;RAM copy of paging latch contents

	COMMON	/msgcha/

msgch:	DS	1		;Printer to use for PCHAR output.


	DSEG

;	Pointers to control the two printer buffers.


parasp:	DS	2		;Points to the first free location
sersp:	DS	2		;in the buffer

parptr:	DS	2		;Points to the f	;External status interrupt - ack & return
	PUSH	AF
	LD	A,020O
	OUT	(sbctrl),A
	POP	AF
	RETI

serint:	EI
	PUSH	AF
	LD	A,50O
	OUT	(sbctrl),A	;Reset Tx int pending
	XOR	A
	LD	(seract),A
	POP	AF
	RETI



; PROCEDURE FlushP;
; Discard contents of printer buffers

flushP:	RET


; PROCEDURE Char_IO;
;
; Initialise character I/O ports
; Also initialise message and debug flags from user values in (0F800H)


chario:	LD	A,(0f800H)
	LD	(mess),A
	LD	A,(0F801H)
	LD	(debu),A

	DI
	LD	Hate transfers from buffers in RAM to printer devices
; when buffers not empty & devices ready.
; Francis I/O is interrupt driven, so do nothing.

dolist:	RET




;PCHAR
;
;Print character in E.  All registers preserved
;Output is to printer given by (msgch)

pchar:	PUSH	AF
	PUSH	BC
	PUSH	IY
	PUSH	HL

	LD	A,(msgch)	;Get channel number to use (=1 or =2)
	LD	B,A		;Save it
	LD	HL,useflg	;point to message/user flags
	AND	(HL)
	JR	NZ,ok4us	;Already in use as message printer

	LD	A,(HL)		;	A,onlin		;Online LED on again
	OUT	(leds),A
	CALL	Sdelay		;Returns Z if operator presses switch
	JR	NZ,pchar1	;Don't wait if so.

pchar2:	POP	DE
	RET



; PROCEDURE Print(addr:Word;VAR count:Byte;channel:Byte);
;
; Insert chars into print buffer.
; <count> indicates how many chars available, & is returned holding number
; actually transferred.

print:	POP	HL
	EX	(SP),HL		;H:=channel no.

	LD	B,H		;Save printer no.
	LD	A,B
	LD	HL,useflg	;Point to user/message printer flag
	AND	(HL)		;=Update flags
	OR	B
	LD	(HL),A

	PUSH	DE		;Save character

	LD	HL,systxt	;Print header for our output
	LD	D,syslen
prtxt:	LD	E,(HL)
	PUSH	HL
	CALL	dochar
	POP	HL
	INC	HL
	DEC	D
	JR	NZ,prtxt
	POP	DE		;Restore the message character

ok4us:	CALL	dochar

	POP	HL
	POP	IY
	POP	BC
	POP	AF
	RET

systxt:	DB	12,'******* SYSTEM MESSAGES *******',13,10
syslen	EQU	$-systxt



; Code to do Pchar action. Preserves DE (only)

dochar:	PUSH	DE		;NB. E is parameter

pchar1:	LD	A,1
	PUSH	AF		;0 if already a user printer
	LD	A,B		;Restore number
	JR	Z,doprnt	;All is OK

	XOR	(HL)		;Not ok - was in use as message printer
	LD	(HL),A		;Clear flag

	LD	HL,msgch	;Point to current message channel
	LD	C,(HL)		;Save old value
	LD	(HL),B		;Insert our printer number
	
	LD	E,12		;Form feed
	PUSH	BC
	PUSH	HL
	CALL	dochar		;Print char from E
	POP	HL
	POP	BC
	LD	(HL),C		;Restore (msgch)
	LD	A,B		;A:=printer number

;	doprnt:
;	Entered here from Pchar also.
;	A=1 for parallel =2 for serialThis will be pointed to as VAR count:Byte

	LD	HL,2
	ADD	HL,SP		;Get address of E on stack

;	Push 4 bytes of parameters to Print:

	PUSH	HL		;Data address
	DEC	HL		;Point to byte value 1 just pushed
	PUSH	HL

	LD	A,(msgch)	;Select which printer

	CALL	doprnt		;Takes A & 4 bytes on stack as parameters

	POP	AF		;The byte count
	OR	A		;Set flags (A value in stack was poked)
	JR	NZ,pchar2	;If =0, the call to print did 0 bytes.

	XOR	A		;Turn off offline LED
	OUT	(leds),A
	CALL	Sdelay
	LDE_BL)
	ADD	HL,BC
	LD	(HL),E
	INC	HL
	LD	(HL),D

	OR	A		;Test for FS disc again
	JR	NZ,notfs1

	LD	A,2		;First block of FS area
allfs:	LD	(bldes+1),A	;NB. hi byte already set to 0 from reading blk0
	LD	HL,bldes
	PUSH	HL
	CALL	alloc		;Allocate all 64 blocks of the FS area
	LD	A,(bldes+1)
	INC	A
	CP	66		;FS is in blocks 2..65
	JR	NZ,allfs

notfs1:	POP	AF		;Drive no.
	DEC	A		;Repeat until finished
	JP	P,inilp0

	RET

;	Error exit. iabort is entry if errloc already set.

inierr:	LD	A,1ugh if operator pressed switch to exit


; doexit:

; Turn on ROM, re-enter monitor.
;NB this code must NOT be underneath the ROM ie not in the area 0..3FFFH

doexit:	LD	A,06FH		;Value to disable CTC interrupt
	OUT	(ctc1),A	;Disable 1Hz int
	OUT	(ctc1),A	;Compulsory time constant - value irrelevant
	OUT	(ctc3),A	;Same for parallel printer
	OUT	(ctc3),A

	CALL	no_int		;No net irqs
	DI
	LD	A,01
	OUT	(sbctrl),A	;No side B irqs either
	XOR	A
	OUT	(sbctrl),A

	OUT	(paport),A	;0 is ROM on val		;Duff data in blk 0
	LD	(errloc),A
iabort:	POP	HL		;old drive no(rubbish)
	RET			;(errloc) set by rwdisc


;INIONE
;Initialise one drive
;
;On entry:
; A	Drive number
; HL	Number of blocks to allocate
;
; IY	preserved

inione:
	tmess	<almsg0,AF,almsg1,HL>

	PUSH	HL		;Save number of blocks
	EX	DE,HL		;DE:= no_of_blocks

	ADD	A,A		;Get address in mapptr
	LD	C,A		;BC:= A * 2
	LD	B,0

	SRּ	D		;Converפ Blockף tן Byteף tן allocate
	Rׂ	E
	SRL	D
	RR	E
	SRL	D
	RR	E
	INC	DE

	LD	HL,ue

	JP	3		;warm restart monitor






;GETMEM
;
;This routine returns the first unavailible memory location on the
; machine in DE & returns to HL

getmem:	LD	DE,0F800H
	JP	(HL)






; FUNCTION Offlin(channel:Byte):Boolean;
;
; Return hardware status of given printer (1=para,0=serial)
; Francis printers have no hardware status, so return FALSE

offlin:	POP	HL
	EX	(SP),HL		;H:=channel no.
	XOR	A		;Return FALSE
;	RET
;	Drop through to RET


;
; PROCEDURE Dolist;

; Initi FSexit - exit to monitor. Must flush printer buffers 1st.

fsexit:	XOR	A		;Turn both LEDs OFF
	OUT	(leds),A
	LD	D,A

	CALL	Srelea		;Wait for switch to be released

;
; TEMP - printers have no buffer, so exit
;
	JR	doexit

exit2:	LD	HL,paract	;Parallel print active if <>0
	LD	A,(HL)
	INC	HL
	OR	(HL)		;Sample serial state also
	JR	Z,doexit	;Neither printer active

	LD	A,D		;LED state
	XOR	onlin		;Flip online bit
	LD	D,A
	OUT	(leds),A
	CALL	Sdelay
	JR	NZ,exit2	;Timed out

	;Drop throLD	C,A		;Error code (=0 for no error)


	LD	A,C		;=0 if no error
	AND	D		;=0 if write
	RET	Z
	LD	(IY+2),0FFH	;Error during read, so cache now holds junk.
	LD	(IY+3),0FFH	;Mark as empty.
	RET




;RWSEC
;Read/Write sector to/from disk
;
;On entry:
;	BC	RAM address to read/write
;	 D	Read flag (FF-read,0-write)
;	 E	Disk number
;	HL	sector no.
;
;On exit:
; A	Error code (0 = OK, 1=error)
;	(errloc) also updated
; IX,IY	Preserved

rwsec:
	PUSH	BC

	CALL	trkreg		;Init track reg & pock descriptor set up to be blk0
	PUSH	HL
	CALL	discrd

	LD	A,(errloc)	;Had error ?
	OR	A
	JR	NZ,iabort


iniok:	LD	HL,($hplm)	;Where we put the block
	LD	BC,sjoff	;Offset of SJ string
	ADD	HL,BC
	LD	DE,sjmess	;Check it's an SJ disk
	LD	BC,23*256+1	;B:= len SJstring , C:= error not SJ
csjlop:	LD	A,(DE)
	CP	(HL)
	JR	NZ,inierr
	INC	HL
	INC	DE
	DJNZ	csjlop

	LD	IY,($hplm)
	LD	L,(IY+blkoff)	;HL:= number of blocks on disk
	LD	H,(IY+blkoff+1)

	Lִ	D,(IY+dsflag©	;Tesפ foע copש oז F׃ oמ thiointer to trk table

;Convert drive number into drive bits

	XOR	A
	LD	B,E
	INC	B		;As drive numbers start at 0
	SCF
cdrnol:	RLA
	DJNZ	cdrnol
	LD	E,A		;has a single bit set in it.

;Convert sector number HL into track H & sector L

	LD	A,(inches)	;1 bit per drive - =1 for 8inch
	AND	E
	JR	Z,div5		;5" have 5 sec/trk

	SET	inch8,E		;Set 8" bit in value to put in dskctl port

;Divide by eight

	LD	A,L
	AND	7		;Remainder MOD 8

	ADD	HL,HL		;*2
	ADD	HL,HL		;*4
	ADD	HL,HL		;*8
	ADD	HL,ף disc

	POP	AF		;drive no. 0..3
	PUSH	AF
	PUSH	DE		;Save 'dsflag' - ie. is there FS code on disc
	PUSH	HL		;Save disc size
	CALL	inione		;Do map for that drive

	POP	DE		;Disc size
	POP	AF		;dsflag
	OR	A
	JR	NZ,notfs

	LD	HL,-64		;Subtract 64 from disc size
	ADD	HL,DE
	EX	DE,HL

notfs:	LD	B,A		;Save dsflag
	POP	AF		;Get disc no. DE=available disc size
	PUSH	AF

	ADD	A,A		;Drive *2
	LD	C,A
	LD	A,B		;dsflag
	LD	B,0		;BC:=drive*2

	LD	HL,dsksiz	;Put into disk size table (pascal's FREHL		;*16
	ADD	HL,HL		;*32
				; div 8 <=> *32 DIV 256
	LD	L,A
	JR	dundiv	


;Divide by five - by subtracting 5*2^n, n=7..0  (max 160 tracks)

div5:	XOR	A		;to receive bits of result

	LD	BC,-280H	;280H = 5*128 decimal
tscon1:	ADD	HL,BC
	JR	C,tscon0	;carry => HL-BC positive
	SBC	HL,BC		;repair HL (carry cleared)
tscon0:	RLA			;Insert bit from carry into A
	SRA	B
	RR	C		;Reduce 'n'
	JP	NC,tscon1	;Carry => part of the '5' has fallen out

	LD	H,A		;Swap regs - so correct for output

dundivves

inidsk:	CALL	inilow		;To turn off motors etc.

	LD	HL,mapptr	;Init bit map pointers
	LD	B,noofdr*4
inids1:	LD	(HL),-1
	INC	HL
	DJNZ	inids1



; Initialise cache map/chain & set all blocks free.
;
; Francis version : cache size is fixed at 64K
;

	LD	B,noblks	;Loop counter
	LD	C,4		;Pageno. of NEXT block
	LD	HL,cacmap	;Points to the block being initialised
	LD	A,0FFH		;Value for NOT(needs writing) & not in use

cilop:	LD	(HL),C		;Link it to the next block

	INC	HL		;Proceed to neo max drive no.
	JP	M,fsexit	;Exit if no drives

	POP	HL		;Return address
	EX	(SP),HL		;Address of maxdrv parameter (Pascal)

	LD	(HL),A		;Return result of this procedure call

; this loop occurs once for each disk

inilp0:	PUSH	AF		;drive
	LD	(bldes),A	;Put drive in block descriptor

;	Set up parameters on stack for <discrd>

	LD	HL,($hplm)	;Read this block above the system heap
	PUSH	HL
	LD	HL,0400H	;Length
	PUSH	HL
	LD	H,0		;Offset
	PUSH	HL
	LD	(bldes+1),HL	;Block 0
	LD	HL,bldes	;Blxt block
	LD	(HL),A		;Doesn't need writing
	INC	HL
	LD	(HL),A		;Blockno=&FFFF <=> not in use
	INC	HL
	LD	(HL),A
	INC	HL
	INC	C
	INC	C
	INC	C
	INC	C
	DJNZ	cilop

	XOR	A
	LD	(page),A	;Head of chain pointer

;
;	Flash change disc led until user presses switch
;
	XOR	A		;Leds initially OFF
LEDlop:	XOR	chdisc
	LD	D,A		;Save LED state
	OUT	(leds),A
	CALL	Sdelay		;Delay for 0.5s unless switch pressed
	LD	A,D
	JR	NZ,LEDlop	;Sdelay: returns Z if switch pressed.

	CALL	Srelea		;Wait for swi
				;The fact that H=0 is assumed later.
	OR	pagon		;Bit(s) to turn on paged RAM
	LD	(copy),A
	OUT	(paport),A

	LD	A,(IY+3)	;Drive in hi 2 bits
	RLCA
	RLCA
	AND	03H		;Now back in right place
	LD	L,A		;NB. H=0
	LD	BC,drvtab	;Logical to physical translation table
	ADD	HL,BC
	LD	E,(HL)

	LD	L,(IY+2)	;blockno.
	LD	A,(IY+3)	; Hi byte also holds drive
	AND	3FH		;not any more
	LD	H,A		;HL=block no =sector no.

	LD	BC,secbuf	;Ram address where paged RAM appears
	PUSH	DE
	CALL	rwsec
	POP	DE
	tch to be released

	XOR	A
	OUT	(leds),A

;
; Investigate no. of drives & set up translation table
;

	LD	HL,drvtab
	LD	BC,noofdr*256	;C:=0 (count of actual drvs), B:=noofdr
	LD	D,C		;D:=0 (physical drive count)
drvcnt:	LD	E,D
	CALL	inidrv
	JR	Z,nodrv		;Z means drive not working/no disc
	LD	(HL),D		;Insert table entry
	INC	HL		;Pointer into translation table
	INC	C		;Logical drive number
nodrv:	INC	D		;Real drive number
	DJNZ	drvcnt

	LD	A,C		;No. of drives available
	DEC	A		;Convert t be released & debounce it.
; Corrupts A,B. Rest preserved
; Called from DKMAN, fsexit:, chksw:

Srelea:	LD	B,0
relea1:	IN	A,(status)
	EX	(SP),HL		;Slow instruction to increase debounce time
	EX	(SP),HL
	BIT	chdisc,A	;Test if released - if not, re-start timer
	JR	Z,srelea
	DJNZ	relea1		;Debounce switch
	RET



;
; FUNCTION Syst_sw:Boolean;
;
; Return condition of key switch.
; Francis has no key switch, so permanently in system pos.

systsw:	XOR	A
	INC	A		;Return TRUE
	RET



;
;such place
;
; Print a crlf!
pcrlf:	LD	DE,crlf
	JP	pmess


wrmess:	DEFM	'Wrt blk $'
rdmess:	DEFM	'Rd blk $'
adrmsg:	DEFM	' addr $'
atmsg:	DEFM	' @ $'
almsg0:	DEFM	'Init map $'
almsg1:	DEFM	' - length $'
naloc0:	DEFM	cr,lf,'Clear $'
naloc1:	DEFM	' bytes from $'
;alblk0:	DEFM	'Allocate block $'
alblk1:	DEFM	' from map $'
frblk0:	DEFM	'Free block $'

fatmsg:	DEFM	0DH,0AH,'Fatal disc error $'
errmsg:	DEFM	' Error $'

	ENDIF






;PROCEDURE inilow
;
; Set up hardware ready for use version string related routines :
;
; PROCEDURE ver_msg;		prints SJ FS ver etc. on screen
; FUNCTION ver_adr:Word;	Returns address of a block containing the
;				version string with a std. Tx header on the
;				front, suitable for the 'read FS version'
;				FS call.
; FUNCTION Ver_len:Word;	Returns length of block.
;


vermsg:	LD	DE,sjmess		;Print version on screen
	JP	pmess

veradr:	LD	HL,verblk		;Address of version text to
	RET				;Transmit for *VERS

verlen:	LD	HL,crlf-verblk+1	;Length .

inilow:	XOR	A
	OUT	(dskctl),A	;Deselect all drives
	LD	(dkctlm),A	;Set up RAM copy
	LD	(ticloc),A	;Indicate drives stopped so time is allowed
				;to restart them later
	IN	A,(mstop)	;Stop drive motors

	LD	HL,trkno
	LD	B,4
zaptab:	LD	(HL),0FFH
	INC	HL
	DJNZ	zaptab
	RET



;PROCEDURE inidsk (VAR max_drive: BYTE);
;
;This procedure allocates heap for the map for all drives
;& finds out how many drives there are.
;External drive numbers always run 0..n and are translated into real driof transmitted text
	RET

verblk:	DEFW	0			;Std. Tx Header

sjmess:	DEFM	'SJ Research File Server ver '
	DEFW	verhi,verlo

	DEFM	'/FDFS'


; NB this label must be defined before any references to the MESS
; macro is made.
; NB2 also forms part of the above string.

crlf:	DEFM	cr,lf,'$'


	IF	t.on

;dhxout
;Print hex of HL

dhxout:	LD	A,H
	CALL	cahex
	LD	A,L
				;DROP THROUGH
;cahex
;Print hex of A
;
;On entry:
; A	number to be printed

	JP	cahex		;Now lives in h2lib or some 	2
cts	EQU	5

rdabit	EQU	1

;***************************************************************

status	EQU	34H		;System status input port

fddreq	EQU	7		;2793 DREQ, active hi
nettxe	EQU	5		;Net TX enable monitor
chdisc	EQU	2		;switch - active lo
onesct	EQU	0		;Ones counter

;***************************************************************

pprint	EQU	036H		;Printer output

;***************************************************************

ctc	EQU	038H
ctc0	EQU	ctc+0		;Head load timing
ctc1ALL	Srelea		;Wait for switch to be released

	CALL	bldmap		;Re-build disc maps etc.

;	Drop through to show that we are now online again


; PROCEDURE On_line;
; Illuminate the on-line lamp!

online:	LD	A,onlin		;Disc Free OFF, online ON
	OUT	(leds),A
	RET



; syserr:
; Halt, flashing LEDs, until switch pressed to exit.

syserr:	XOR	A			;ROM (& hence LED) ON
	OUT	(paport),A
	CALL	Sdelay
	JR	Z,fsexit		;Operator forces exit.

	LD	A,romoff		;ROM & LED off
	OUT	(paport),A
	CALL	Sdelay	EQU	ctc+1		;1Hz interrupt
ctc2	EQU	ctc+2		;Baud rate (set up by ROM code)
ctc3	EQU	ctc+3		;Parallel printer ACK*


;***************************************************************

paport	EQU	034H		; Paged RAM/ROM control

;	RAM copy at copy: in COMMON /pacopy/
;	note that page is left open on exit : copy is for the use of IRQ rtns

pagon	EQU	3		;value for paged RAM open, ROM off
pagoff	EQU	1		;value for CLOSED
romoff	EQU	1		;Set if ROM off

;************************************************
	JR	syserr


; Sdelay:
; Delay for ~.5 sec.
; Exit immediately if switch pressed
; Called from Syserr: & Pchar: & in dkfran

; On exit,
;	NZ	for normal exit after time delay
;	Z	If exit caused by operator pressing change disc switch
;	HL=0	if normal exit

Sdelay:	LD	HL,0
del2:	IN	A,(status)
	BIT	chdisc,A	;Test for switch pressed
	RET	Z		;Return if so (switch active lo)

	DEC	HL
	LD	A,L
	OR	H
	JR	NZ,del2
	INC	A		;Return NZ for normal timeout
	RET

; Srelea:
;
; Wait for switch to***************

leds	EQU	035H		;LED port (active hi leds)
onlin	EQU	040H		;values to write
dkfree	EQU	080H

;***************************************************************



; PROCEDURE chksw;
;
; Routine to poll front pannel switches
;
; If switch pressed, change discs.
; <bldmap> calls <inidsk> in DKfran which flashes the change disc LED
; & waits for switch pressed - hence we must wait for switch released

chksw:	IN	A,(status)
	BIT	chdisc,A
	RET	NZ		;Not pressed
	CALL	emptyC

	Cutines for Z80 FS





; FUNCTION Inkey(VAR ch:Char):Boolean;

inkey:	CALL	cinst
	LD	B,0		;B:=False
	JR	Z,inkXit	;No char avail
	CALL	rcin		;Return char in A
	CP	6		;Ctrl-F
	LD	B,1		;B:=True
	JR	NZ,inkXit
	CALL	srlmon
	LD	B,0		;Return no char if continued from srlmon
inkXit:	POP	HL
	POP	DE		;Address of <ch>
	LD	(DE),A
	LD	A,B		;result
	JP	(HL)		;Return


; PCHAR
;
; Print character in E
; Preserves all regs.

pchar:	PUSH	AF
	LD	A,E
	CALL	cout
	POP	AF
	RET



;IO jump tabTITLE Various FS m/c-dependant routines : mdepfran.mac
.Z80
NAME	('MDepfran')

; modifications:
; 25/11/84 New print server system
; 27/11/84 syserr: added.
;  1/12/84 FlushP: added. Pchar now flashes online LED if waiting.
;  2/12/84 Dolist: now does not advance pointer until chars have been printed.
;  8/12/84 Francis version
; 24/12/84 Now sends PCHAR output to printer specified by COMMON/msgcha/
;  3/ 1/85 Banner before PCHAR output added.


PUBLIC	fsexit, getmem, pchar, dolist, systsw, chle

iojtbl	EQU	$

;This jump table is copied to RAM at iojmps:
; then poked if Remoted

	JP	ist423
	JP	cin423
	JP	ost423
	JP	cot423
	JP	retbyt		;Flush buffer - no buffer on 423

ioj1	EQU	$

cin:	CALL	cinst
	JR	Z,cin
	JP	rcin

coutc:	LD	A,C
cout:	PUSH	AF
cout1:	CALL	cotst
	JR	Z,cout1
	POP	AF
	JP	rcout



;NON-routines:

notify:
remchr:
setrem:

retbyt:	RET

$memry:	DS	2		;DO NOT put this in DSEG!



	DSEG

nmivec:	DS	20		;Code inserted here

eventv:	DS	2

iojmps:ksw, online
PUBLIC	offlin, print, syserr, flushP, chario, Sdelay, Srelea

EXT	emptyC,bldmap			;Pascal procedures - in BIGDATA.
EXT	intct0,intct3,intexb,inttbb	;Interrupt vector locations
EXT	no_int				;Disable net interrrupts

true	EQU	-1
false	EQU	0



	IF1
.PRINTX Francis version
	ENDIF



; port addresses


;***************************************************************

sio	EQU	30H
sbdata	EQU	sio+2		;Side B is serial port
sbctrl	EQU	sio+3

rda	EQU	0		;SIO status bits
tbe	EQU

cinst:	DS	3
rcin:	DS	3
cotst:	DS	3
rcout:	DS	3
cflush:	DS	3


stksav:	DS	2		;Save area for main program stack

wrk:	DS	1		;Used to set statid


	COMMON	/error/

errloc:	DS	1

	END
,C
cout:	PUSH	AF
cout1:	CALL	cotst
	JR	Z,cout1
	POP	AF
	JP	rcout



;NON-routines:

notify:
remchr:
setrem:

retbyt:	RET

$memry:	DS	2		;DO NOT put this in DSEG!



	DSEG

nmivec:	DS	20		;Code inserted here

eventv:	DS	2

iojmps: start timed period again)

;***************************************************************


;Cache equates

noblks	EQU	64		;maximum number of k in cache (?)

secbuf	EQU	0FC00H		;Cache ram appears here



;Misc equates

lf	EQU	10
cr	EQU	13

noofdr	EQU	4


;Block 0 offsets

sjoff	EQU	64		;Offset to 'SJ Research File Server'
dsflag	EQU	97		;offset of double-sided flag
blkoff	EQU	98		;offset of number of blocks on disk (16 bits)

;	Note that dsflag is always set on franis format diF	i AND 1		;ie I is odd (and param points to a string)
	mess	param
	ELSE
	IF	'&param' EQ 'AF'
	POP	AF
	CALL	cahex
	ELSE
	POP	HL
	CALL	dhxout
	ENDIF
	ENDIF
	ENDIF
	ENDM

	POP	HL
	POP	DE
	POP	BC

nomess:	POP	AF

	ENDIF

	ENDM



pstat	MACRO	sw,mes1,mes2
	IF1
	IF	sw
	IFNB	<mes1>
.PRINTX	mes1
	ENDIF
	ELSE
	IFNB	<mes2>
.PRINTX	mes2
	ENDIF
	ENDIF
	ENDIF
	ENDM


	
	pstat	true,<Francis version>
	pstat	t.on,<Tracing ON>
	pstat	c.on,<Bounds checking ON>





; Variousscs,
;	except those containing the FS code in blocks 2..65


;Macro to print string @ messadr

mess	MACRO	messadr

	IF	messadr EQ crlf
	CALL	pcrlf
	ELSE
	LD	DE,messadr
	CALL	pmess
	ENDIF

	ENDM




;Macro to print error string & crash back to OS

error	MACRO	string
	LOCAL	stradr

	LD	DE,stradr
	CALL	pmess

	JP	syserr

stradr:	DEFM	cr,lf,string,cr,lf,'$'
	ENDM




;Macro for message condition

mcond	MACRO	addr
	PUSH	AF
	LD	A,(mesflg)
	OR	A
	JR	Z,addr
	POP	AF
	ENDM	msage
	cr,lf
	'New station number        :',0
	CALL	getlin
	CALL	gdeca
	JR	Z,stat2

	LD	D,stnreg
	CALL	writck		;write new statid in A to reg 8

	CALL	msage
	'New number will take effect',cr,lf
	'when file server is re-started',cr,lf,0

	RET


stat2:	CALL	msage
	'station number left unchanged',0
	RET


;transmit packet.
;
;Syntax is T<Txcb addr> <delay info>

txpkt:	CALL	hexin		;txcb addr in HL
	CALL	txlo
	PUSH	AF
	CALL	msage
	cr,lf,"&",0
	POP	AF
	JP	prhex





; I/O ro



;Trace message macro

tmess	MACRO	list
	LOCAL	nomess

	IF	t.on

	mcond	nomess

	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL

count	DEFL	0

	IRP	param,<list>	;Count:= number of params
count	DEFL	count + 1
	ENDM

i	DEFL	count		;i:= count

	REPT	count
	IFF	i AND 1		;ie I is even
j	DEFL	0

	IRP	param,<list>
j	DEFL	j+1
	IF	(j EQ i)
	PUSH	param
	ENDIF
	ENDM			;of IRP param....

	ENDIF
i	DEFL	i-1
	ENDM			;of REPT count

i	DEFL	0

	IRP	param,<list>
	IFNB	<param>
i	DEFL	i+1
	I returned in common /error/
	OR	A
	JP	NZ,abrt4

	POP	AF		;Loop counter
	DEC	A
	JR	NZ,nxtblk

	POP	HL		;Discard used parameters
	POP	HL
	POP	HL
	RET

;user 'W' command enters here

uwrblk:	CALL	msage
	cr,lf
	'Write',0

	XOR	A		;Zero <=> False : this is read flag for rwblk
	JP	dscarg



;
;set station number
;

setstn:	LD	A,1
	LD	D,optreg
	CALL	writck

	LD	HL,wrk
	LD	D,stnreg
	CALL	readck
	CALL	msage
	cr,lf
	'Current station number is :',0
	LD	A,(HL)
	CALL	pdeca

	CALLo write
chdisc	EQU	080H

;***************************************************************

fdbase	EQU	004H		;2793 address
fdctrl	EQU	fdbase
fdstat	EQU	fdbase
fdtrk	EQU	fdbase+1
fdsec	EQU	fdbase+2
fddata	EQU	fdbase+3

;status bits

busy	EQU	0
index	EQU	1
trk0	EQU	2
notrdy	EQU	7

;FDC commands

home	EQU	008H	;Seek trk 0 + Step 3|6mS + Head Load + no verify
seek	EQU	01CH	;Seek trk n + Step 3|6ms + Head Load +    verify
rdsec	EQU	080H	;Read 1 sec + No settle time + No side compare
wrsec	 open on exit : copy is for the use of IRQ rtns

pagon	EQU	3		;value for paged RAM open, ROM off
pagoff	EQU	1		;value for CLOSED
romoff	EQU	1		;Set if ROM off

;***************************************************************

status	EQU	034H		;System status input
discsw	EQU	2		;Front pannel switch

;***************************************************************

mstart	EQU	035H		;Read port to start disc motor
mstop	EQU	036H		;similarly to stop.

mtrtim	EQU	10		;No. of seconds for drive motoEQU	0A0H	;Write 1 sec + No settle + no side comp + Data mark
trkinc	EQU	058H	;+1 Trk + inc reg + Step 3|6mS + Head Load + No Verify
writrk	EQU	0F4H	;Write track + settle time
frcint	EQU	0D0H	;Force interrupt never <=> force type 1 status

maxtry	EQU	4	;Max number of attempts on disc commands

;***************************************************************

ctc0	EQU	038H	;Head load timing channel

ctcset	EQU	07FH	;value to init (followed by time const in secs)
ctcrst	EQU	07BH	;value to reset (iers to run

;***************************************************************

dskctl	EQU	037H		;Disc density, sidesel & drive sel port

;	RAM copy at dkctlm: (not COMMONed)

precmp	EQU	7		;Hi for precomp **NOT USED**
sinden	EQU	6		;Hi for single density **NOT USED**
inch8	EQU	5		;Set for 8" data rate
sidsel	EQU	4		;=1 for side 1
				;Bits 0..3 are drive selects
;***************************************************************

leds	EQU	035H		;LED port (active hi leds)
onlin	EQU	040H		;values t
	'        ============',cr,lf
	'   version ',va,'.',vb,vc,cr,lf
	cr,lf
	' B - Return to disc utility program',cr,lf
	' H - this help msg',cr,lf
	' S - set FS Station number',cr,lf
	' R - read disc',cr,lf
	' W - Write disc',cr,lf
	'and all the usual monitor commands',cr,lf,0
	RET

	'----->'

fsboot:	XOR	A		;Drive no.
	PUSH	AF
	CALL	chksj
	LD	A,(errloc)
	OR	A		;Test error, & give up if so
	RET	NZ
	LD	A,(0FC00H+dsflag)	;Get double sided flag from blk0
	OR	A
	RET	NZ		;Not an FS boot disc
er 'R' command enters here

urdblk:	CALL	msage
	cr,lf
	'Read',0

	LD	A,1		;TRUE - 1st param for RWblk
dscarg:	PUSH	AF

	CALL	msage
	' disc -',cr,lf
	'drive no :',0
	CALL	hexin
	JR	Z,abrt1
	LD	A,L		;Test for in range drive no.
	CP	4
	JR	NC,abrt1
	POP	AF
	LD	H,A		;Drive no. plus r/w flag
	PUSH	HL

	CALL	msage
	cr,lf
	'RAM addr :',0
	CALL	hexin
	JR	Z,abrt1
	LD	DE,0400H
	OR	A
	SBC	HL,DE
	PUSH	HL

	CALL	msage
	cr,lf
	'Start block :',0
	CALL	hexin
	JR	Z,abrt2
	DEC	HL		;Will be 
	LD	E,0		;Drive no
	LD	HL,2		;Start block no.
	LD	D,H		;D:=0 <=> Page number (E holds drive)

bootlp:	PUSH	HL		;Save counters
	PUSH	DE

;	Push parameters for rwblk:

	LD	A,1		;Read flag (TRUE)
	PUSH	AF
	LD	BC,0FC00H
	PUSH	BC		;Address
	LD	A,E		;Drive
	PUSH	AF
	PUSH	HL		;Blockno

	LD	A,D		;Page no.
	OR	pagon		;Read into paged RAM
	OUT	(paport),A
	
	CALL	rwblk

	POP	DE
	POP	HL
	INC	HL

	LD	A,(errloc)	;Test for error
	OR	A
	RET	NZ		;Can't boot - return to monitor

	INC	D		;Pageinc'd before use
	PUSH	HL

	CALL	msage
	cr,lf
	'Number of blocks :',0
	CALL	hexin
	JP	Z,abrt3
	CALL	pcrlf

	LD	A,L
	
nxtblk:	POP	DE		;blockno-1
	INC	DE
	POP	HL		;Addr
	LD	BC,0400H
	ADD	HL,BC
	LD	C,L
	LD	B,H
	EX	DE,HL
	POP	DE		;Drv + read flag
	PUSH	DE
	PUSH	BC
	PUSH	HL
	PUSH	AF		;Loop counter

;	Now push parameters for RWblk

	PUSH	DE		;Read flag from D (E unimportant here)
	PUSH	BC		;Address
	LD	A,E		;Drive
	PUSH	AF
	PUSH	HL		;Blockno
	
	CALL	rwblk

	LD	A,(errloc)	;Error no - bottom 2 bits are =0
	INC	D
	INC	D
	INC	D
	JR	NZ,bootlp	;Do 64K

	LD	A,pagon		;Select page 0
	OUT	(paport),A

	LD	A,06FH		;Disable 1Hz interrupt
	OUT	(ctc1),A
	OUT	(ctc1),A	;Spurious time constant

	CALL	no_int

	DI
	LD	A,1
	OUT	(sbctrl),A
	XOR	A		;Turn off SIO side B
	OUT	(sbctrl),A
	EI

	JP	0FC00H		;Execute FS boot code

	'<----'


abrt4:	POP	HL		;Pop various stack levels & do abort return
abrt3:	POP	HL		; to pottymon.
abrt2:	POP	HL
abrt1:	POP	HL
	JP	abort




;usalues to write
dkfree	EQU	080H


;	JP	start		;Inserted by linker

	.PHASE	0FC03H

start:	XOR	A		;LEDs off
	OUT	(leds),A
	LD	HL,srcop
	LD	DE,nxtop	;Copy this code to non-program RAM
	LD	BC,080H
	LDIR
	LD	A,pagon		;Turn ROM off (this code in paged RAM)
	OUT	(paport),A
	JP	nxtop		;Jump to main RAM

srcop:
	.DEPHASE

	.PHASE 0080H

nxtop:	LD	A,4+3		;Page no =1, rom off,page open
	LD	DE,0100H	;Dest for code

bootlp:	LD	BC,0400H
	LD	HL,0FC00H
	OUT	(paport),A
	LDIR
	INC	A
	INC	A
	IND	(0F800H),HL	;Init debug, message copies for FS

	CALL	ini423

;	Wait for switch to be pressed before trying to boot FS

	XOR	A		;LED state
ledlop:	XOR	dskfre
	OUT	(leds),A
	LD	D,A		;Save leds
swloop:	IN	A,(status)
	BIT	chdisc,A
	JR	Z,presed
	DEC	HL
	LD	A,L
	OR	H
	JR	NZ,swloop
	LD	A,D
	JR	ledlop

presed:	LD	B,0
deboun:	IN	A,(status)
	BIT	chdisc,A
	JR	Z,presed	;Wait for release
	DJNZ	deboun		;Debounce the switch

	JP	fsboot		;If it can't boot, will return & start pascal


;EXTRAC	A
	INC	A
	CP	0C4H+3		;About to write to 0C100H
	JR	NZ,bootlp
	JP	100H		;Start FS


	END	start


	LD	HL,srcop
	LD	DE,nxtop	;Copy this code to non-program RAM
	LD	BC,080H
	LDIR
	LD	A,pagon		;Turn ROM off (this code in paged RAM)
	OUT	(paport),A
	JP	nxtop		;Jump to main RAM

srcop:
	.DEPHASE

	.PHASE 0080H

nxtop:	LD	A,4+3		;Page no =1, rom off,page open
	LD	DE,0100H	;Dest for code

bootlp:	LD	BC,0400H
	LD	HL,0FC00H
	OUT	(paport),A
	LDIR
	INC	A
	INC	A
	IN
;Unrecognised monitor commands passed to here
;

extra:
	CP	'B'
	JP	Z,fsboot
	CP	'H'
	JR	Z,help
	CP	'S'
	JP	Z,setstn
	CP	'T'
	JP	Z,txpkt
	CP	'R'
	JP	Z,urdblk
	CP	'W'
	JP	Z,uwrblk
	CP	'K'
	JR	Z,contin
	CALL	msage
	cr,lf
	'?',0
	RET


contin:	LD	A,dskfre		;Different LEDs
	OUT	(leds),A
	LD	SP,(stksav)		;Continue execution of main program
	POP	HL			;Context was saved on other stack
	POP	DE
	POP	BC
	POP	AF
	RET


help:	CALL	msage
	cr,lf
	cr,lf
	'        FDFS Monitor',cr,lf׃>ֽ·.ֻ ת}׃ֽץֵדֵzֻj!„.(!.@ ם°ֽ·.ץֻj(! +|µ ֽg*–Bwס! @6 ז(6ַ!•B5ץe- Q-ֽ1סץֽ¸0ס>ֱב>
2+@סֱבָׁ>׃ֳּ-ם¢םEם£םEוz !˜BW"–B~׃בֹ>׀ֽ·.ֻW(>Xֽ·.>׃ֳֽ.ֻG תֵֹ‏ֱֹוֵ¯C7‎_׃72¢B!+@ף~6€ֻ'o& 5>׀ֽ·.+}´(5דד ֻ עףֻO(תֻO ת!  #ֻO(ש|‏g 0Kֻכ!’B{/¦±w¯<!+@6
ֱבֹבדו\ֽ”.ֽ.(^ֽ¥.!B! €"B6ֻk(6 666d6	6ֽ<1ו&  €פ|בוֽa2ֻ£ַֽ-ֻדַֽ-$|‏P(>Xֽ·.ב¯<בבֹבׁסֱדכ_¯’Wֳˆ-בד\ֽ.(\ !  ֽˆ-·ְ!@)-¾ 	#רֹ>>2 @ֹבסוֻ'ֻ'צ׃4ֹ1 וֽ#! "¾B!€ 9"­B!> up to speed
	JR	NZ,inid2	;12t =94t *65536 <=> 1.03 seconds

	DI			;For software timing

inid6:	IN	A,(fdstat)
	BIT	index,A		;Wait for index hole also
	JR	Z,inid6

inid3:	IN	A,(fdstat)	;Start timing at end of index
	BIT	index,A
	JR	NZ,inid3

	LD	HL,0		;Timer
inid4:	IN	A,(fdstat)	; 11T/12T if in ROM
	INC	HL		; 6T/7T
	BIT	index,A		; 8T/10T
	JR	Z,inid4		; 12T/13T except when dropping through
				; total = 37T/42T per loop
	EI

; 8" runs at 6 revs/sec =   1E6 T per rev = 27027 iterations of contains value for <dskctl>
				;including 8inch bit
	JR	Z,form98	;No disc in drive

	CALL	seekz		;NB. drive left spinning by <inidrv>

;	Now set up parameter block for format data

	LD	IX,params	;Point to block in DSEG
	LD	HL,08000H	;Address of format data buffer
	LD	(params),HL
	LD	(IX+4),3	;Sector size - 3 => 1K
	BIT	inch8,E
	JR	Z,form5		;5" discs
	LD	(IX+5),160	;Gap3 size
	LD	(IX+2),0BH	;Flag - (start sec=0)+(8 inch)+(dden)
	LD	(IX+3),8	;No of sectors
	JR	form1

form5:	LD	(IX+5),100	 loop
; 5" runs at 5 revs/sec = 1.2E6 T per rev = 32432 iterations of loop
; Hence mid pt. = 29729, just over &7400
; IF in rom:
; 8"=23809, 5"=28571 iterations mid pt=26190 ~=&6600

	LD	A,H

	IF	inrom
	CP	067H
	ELSE
	CP	075H		;Carry if 8"
	ENDIF

	LD	C,0		;No bit set
	JR	NC,inid5
	LD	C,E		;Get drive bit
	SET	inch8,E

inid5:	LD	HL,inches
	LD	A,E
	CPL			;Clear bit for this drive
	AND	(HL)		;get other drive bits
	OR	C		;Set our bit as appropriate
	LD	(HL),A	
	XOR	A		;Indicate successTITLE FRANBOOT - boot code for Francis FS code
.Z80
NAME	('Franboot')

; modifications:
;  9/12/84 Francis version

true	EQU	-1
false	EQU	0


	IF1
.PRINTX Francis boot code
	ENDIF


; port addresses



paport	EQU	034H		; Paged RAM/ROM control


pagon	EQU	3		;value for paged RAM open, ROM off
pagoff	EQU	1		;value for CLOSED
romoff	EQU	1		;Set if ROM off

;***************************************************************

leds	EQU	035H		;LED port (active hi leds)
onlin	EQU	040H		;v
	INC	A
nodisc:	LD	HL,ticloc	;Entered here with A=0 if timed out
	LD	(HL),mtrtim	;Stop drive after usual time
	POP	BC
	POP	HL
	RET






;FUNCTION Format(drv:Byte):Boolean;
;
; Format specified drive.
; Returns TRUE if format attempted, FALSE if no disc in drive.
; Uses RAM at &8000 for format table

format:	POP	HL
	EX	(SP),HL		;Drive no. in H
	PUSH	IX		;Save for Propas

	LD	E,H
	CALL	trkreg		;Set track table pointer

	CALL	inidrv		;Applies tape measure to drive -
				;On return, EDISC - read, write, format disc.
;
; On entry :
;	BC	Ram address of data
;	D	FD command (expected to be read sec, write sec, or write trk)
;	E	drive sel, side sel, 5/8 inch to suit dskctl port
;	H	track
;	L	sector if reqd.
;
; <trkreg:> assumed to have been called
;
; On exit :
;	A	=0 if no error, =1 otherwise
; ALL OTHER REGS PRESERVED

rwdisc:	LD	A,maxtry
	LD	(retryc),A
retry:	PUSH	DE
	PUSH	HL
	PUSH	BC

	LD	A,(dkctlm)	;Copy of current disc select state
	XOR	E		;Compare with new drivees blockno in HL
	LD	E,A		;Drive
	XOR	A
	SUB	D		;D contains read flag =1 => read, =0 => write
	LD	D,A		;Now =0 => write, =&FF =>read

	JP	rwsec		;All params set up - call & return to pascal





;  PROCEDURE Chk_SJ(drive:Byte);
;
; Read blk0 into cache RAM, check for 8"/5" drive, check for SJ disc.
; Set <error> =1 means disc OK, but no SJ message
; <error> =2 => no disc in drive

chkSJ:	POP	HL
	EX	(SP),HL
	LD	E,H

	CALL	inidrv		;Tests for 5"/8". Preserves HL.

	JR	Z,nodsc1

;	Set ;Gap3
	LD	(IX+2),9	;(start sec=0)+(dden)
	LD	(IX+3),5

form1:	EXX			;Save drive bits
	CALL	fdata		;Set up format table. Returns DE,HL
	PUSH	HL		;Corrupted by newtrk:
	EXX

	LD	H,0		;Track counter
	LD	BC,08000H	;Ram address
	LD	D,writrk	;FDC command for format

;	Now loop over all tracks

form2:	LD	A,H
	EXX
	POP	HL
	PUSH	HL
	CALL	newtrk		;Insert trackno into format data
	EXX
	RES	sidsel,E
	CALL	rwdisc
	SET	sidsel,E
	CALL	rwdisc
	INC	H
	LD	A,H
	CP	80
	JR	Z,form99	;Finished all tracup registers for <rwsec>

	LD	E,H
	LD	D,0FFH		;Read flag (=True)
	LD	BC,0FC00H	;Address of cache RAM
	LD	HL,0		;Block number

	CALL	rwsec
	OR	A
	RET	NZ		; Give up


iniok:	LD	HL,0FC00H+sjoff	;Where we put the block + Offset of SJ string
	LD	DE,sjmess	;Check it's an SJ disk
	LD	B,23		;B:= len SJstring

csjlop:	LD	A,(DE)
	CP	(HL)
	JR	NZ,inierr
	INC	HL
	INC	DE
	DJNZ	csjlop

	RET

nodsc1:	LD	A,2		;No disc in drive
	JR	inier2
inierr:	LD	A,1		;Duff data in blk 0
inier2:	LD	(errloc),A
ks

	LD	A,trkinc	;Move to next track
	CALL	docmd		;NB. settle time is in the write trk command
	JR	form2
	

form99:	XOR	A
	INC	A		;Return result =OK
	POP	HL		;Discard newtrk: parameter
form98:	POP	IX
	RET




; PROCEDURE Rw_blk(read:Boolean; address:Word; disc:Byte; blkno:Word);
;
; Write out 1k block to disc from main memory <buffer>.

rwblk:	POP	HL
	POP	DE		;Blockno
	POP	AF		;Drive
	POP	BC		;Address
	EX	(SP),HL		;Read flag to H, return addr back on stack
	EX	DE,HL		;<rwsec> require in H, two spare bits in
	RR	H		;lo of A

	LD	C,0
	RL	C
	RLA
	RL	C	
	LD	A,H
	LD	H,C
	LD	C,A		; HL=offset, C=page


	LD	DE,(serptr)	;Lo two bytes of pri_ptr
	LD	A,(serptr+2)
	SRL	A
	RR	D
	RRA			;Building page in D, two spare bits in
	RR	D		;lo of A

	LD	B,0
	RL	B
	RLA
	RL	B
	LD	A,D
	LD	D,B
	LD	B,A		; DE=offset, B=page (also in A)

; Compare pointers

	CP	C		;Compare pages
	JR	Z,samep1
	LD	HL,0400H	;Print to end of page
samep1:	OR	A
	SBC	HL,DE		;HL now holds length
	RET	Z		;kno:	DEFS	4		;Current tracks of drvs 0..3

params:	DEFS	6		;Parameter block for UFORMAT

dkctlm:	DEFS	1		;Ram copy of <dskctl> port

	END
=1 if corresponding drive is 8"


	COMMON	/ticker/

ticloc:	DEFS	1


	COMMON	/debug/

mesflg:	DEFS	1


	COMMON	/error/

errloc:	DEFS	1



	DSEG

retryc:	DEFS	1		;Retry counter

trkptr:	DEFS	2		;This points to an entry in trkno:

tr Zero bytes !

	LD	A,11		;Print data from cache op-code
	CALL	to6502
	LD	A,B		;Page no.
	CALL	to6502
	LD	A,E		;Offset
	CALL	to6502
	LD	A,D
	CALL	to6502
	LD	A,L		;Length
	CALL	to6502
	LD	A,H
	CALL	to6502

; Now update pointer

	EX	DE,HL		;Length now in DE
	LD	HL,(serptr)
	OR	A		;Clear carry
	ADC	HL,DE
	LD	(serptr),HL
;	RET	NC		;No carry into hi byte so not off end of cache
exitNZ:	XOR	A		;We have done something - return NZ
	INC	A
	RET			;64K buffer, so no wrap-round code




;
> HL-BC positive
	SBC	HL,BC		;repair HL (carry cleared)
tscon0:	RLA			;Insert bit from carry into A
	SRA	B
	RR	C		;Reduce 'n'
	JP	NC,tscon1	;Carry => part of the '5' has fallen out

	LD	H,A		;Swap regs - so correct for output

dundiv:	POP	BC

; Now have H=trk, L=sector, D=read flag, E=drive bits, BC=address

	SRL	H		;Modify track number (div 2)
	JR	NC,side0
	SET	sidsel,E	;Other side
side0:	INC	D		;D now 0 for read, 1 for write
	LD	D,rdsec
	JR	Z,rwdisc
	LD	D,wrsec

;drop through


;RW	RET


; PROCEDURE Open_ca(page:Byte);
;
; Open cache RAM at specified page

openca:	POP	HL
	POP	AF
	PUSH	HL

	SLA	A
	SLA	A
	OR	pagon-romoff	;Paging open, ROM ON

	OUT	(paport),A
	RET




	COMMON	/drv8in/

inches:	DEFS	1		;Bits 0..3 =1 if corresponding drive is 8"


	COMMON	/ticker/

ticloc:	DEFS	1


	COMMON	/debug/

mesflg:	DEFS	1


	COMMON	/error/

errloc:	DEFS	1



	DSEG

retryc:	DEFS	1		;Retry counter

trkptr:	DEFS	2		;This points to an entry in trkno:

trU	ctc+2
ctc3	EQU	ctc+3

fdctrl	EQU	4		;WD2793 control reg

dsflag	EQU	97		;Offset to double sided flag - means here
				;that it is an FS boot disc!


;ASCII
cr	EQU	13
lf	EQU	10





;
;** ENTER HERE AFTER RESET**
;
; This code is at 0100H

;	JP	pascal		;Supplied by prolink - jumps to PASCAL
				;entry point.
;	Cold start entry

colds:	IN	A,(status)
	BIT	chdisc,A	;Reset statid if switch pressed at power on
	JR	NZ,colds-3	;Actually jumps to 0100H & so starts pascal

;RTC seems t*KEY 1 franio,intfran,rtcfran,monitor,glinio,genlib/s,rs423,fastout,fastinp,rxaltb5,txalt,imalt,eprtn|M*KEY 2 cmdtbl,zzz,fslpk,rtcstat,lowlib/s,franutil,frdisc,hflib,uformat,fslib/s|M*KEY 0 P:|MPROLINK|MY103|M4000|MN*KEY 3 |M|MLOAD BLANKROM.COM|MLOAD FRANIO.COM 200|MSAVE 64 FRANROM|M                                                                                              RTC     MAC   &|}~              RTCFRAN MAC   8€‚             ZZZ     MAC   ƒ                $KEYS   $$$                    o need time to wake up - try waiting till goes busy

cold1:	IN	A,(3CH)
	OR	0F0H
	INC	A		;is zero => busy
	JR	NZ,cold1

;	Reset statid

resets:	LD	A,1		;-Test, Clock on
	LD	D,optreg
	CALL	writck

	LD	A,dftstn
	LD	D,stnreg
	CALL	writck

	XOR	A
	LD	D,baudrt
	CALL	writck
	JP	0100H



; PROCEDURE SRL_mon;
;
; Save context for re-start & enter monitor

srlmon:	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	(stksav),SP

	LD	A,online
	OUT	(leds),A
	CALL	help
	JP	start


ioinit:	DI
	
;	CP	3		;Should only be 2 bits in here
;	JR	Z,nowrap
;	LD	A,2		;Start at 64K boundary
;nowrap:	LD	(ptr+2),A
	RET


;
; Same as dopara, for serial port.
; In addition, Z flag set on exit if job finished.



doseri:
	LD	A,10		;Serial status
	CALL	to6502

	CALL	wait65		;ready-to-go byte
	PUSH	AF

	CALL	wait65		;Hardware status (ignored here)

	POP	AF
	OR	A
	JP	Z,exitNZ	;Busy, so do nothing

	LD	HL,(sersp)	;Lo two bytes of pri_spa
	LD	A,(sersp+2)
	SRL	A
	RR	H
	RRA			;Building pagCALL	dkinit		;Stop drives

;RTC seems to need time to wake up - try waiting till goes busy

wbsy:	IN	A,(3CH)
	OR	0F0H
	INC	A		;is zero => busy
	JR	NZ,wbsy

	LD	A,dskfre	;LED on
	OUT	(leds),A

	LD	HL,iojtbl	;Init i/o jump table
	LD	DE,iojmps
	LD	BC,ioj1-iojtbl
	LDIR

	LD	A,047H		;Init baud rate
	OUT	(ctc2),A
	LD	A,3
	OUT	(ctc2),A

	LD	HL,retbyt
	LD	(eventv),HL

	CALL	initmd

	LD	HL,0		;flag to tell FCONOT to wait
	CALL	termtx


	XOR	A
	CALL	loinit		;init econet

	LD	HL,0
	LTITLE M3000 routines for FRANCIS : rtcfran.mac
.Z80

;(c) S.R.Lawrence
;     SJ Research

;modifications:
;  29/6/84 - READCK,WIRTCK external routines provided
;  24/7/84 - 32us wait fudge impl.
;  20/8/84 - Delay-after-write impl.
;  18/9/84 - Interrupts off round RTC operations.
;  3/10/84 - Interrupt driven reading of clock. <option> removed.
; 21/10/84 - Francis version using CTC. Ticker location added for disc motor.
; 25/10/84 - 32us wait increased to 100us
;  5/11/84 - Now turns off dri date/time block (5 bytes)
;

getclk:	LD	HL,rdate
	LD	DE,now1
	LD	BC,5
	DI
	LDIR
	EI
	RET



;Interrupt Routine
;
;Entered here at 1 Hz intervals

rtcint:	EI
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL

; Usually increments the time in RAM, but reads the RTC at midnight.

	LD	HL,rsec		;Point to RAM copy of time
	LD	B,2		;Two fields 0..59
secmin:	LD	A,(HL)
	INC	A
	CP	60
	JR	NZ,tickok
	XOR	A
	LD	(HL),A
	DEC	HL
	DJNZ	secmin

	LD	A,(HL)		;Hrs
	INC	A
	CP	24
	JR	C,tickok	;<24 =>ok
ves when stopping motor.
; 11/11/84 - <tim_out> added for printer timeouts
;  1/12/84 - Timeout code now works.

True	EQU	-1
False	EQU	0


NAME	('RTCFRAN')

	IF1
.PRINTX	Francis version
	ENDIF


PUBLIC	getclk,iniclk,setclk	;used by FS
PUBLIC	readck,writck		;used by MONITOR etc

EXT	intct1


clock	EQU	3CH

;registers in M3000

second	EQU	0
minute	EQU	1
hour	EQU	2
date	EQU	3
month	EQU	4
year	EQU	6

status	EQU	15


ctc0	EQU	038H		;Int vector is in ch0
ctc1	EQU	039H		;ch1 genEST rtc,monitor,genlib,rs423,fastout,fastinp,lowlib

prompt	EQU	'F'*256+'>'


sio	EQU	30H
sbdata	EQU	sio+2
sbctrl	EQU	sio+3

rda	EQU	0
tbe	EQU	2
cts	EQU	5

rdabit	EQU	1

status	EQU	34H
chdisc	EQU	2		;switch - active lo

paport	EQU	34H		;ROM on/off, RAM page, etc etc
pagon	EQU	2		;**VALUE** to output (ie it's bit1)
romoff	EQU	1

leds	EQU	35H		;LEDs are active hi
dskfre	EQU	080H
online	EQU	040H

pprint	EQU	036H		;Printer output

ctc	EQU	038H
ctc0	EQU	ctc+0
ctc1	EQU	ctc+1
ctc2	EQerates 1Hz interrupts

mtroff	EQU	036H		;Read to turn off motor
dskctl	EQU	037H		;Write zero to turn off drive selects



;PROCEDURE iniclk
;
;ALWAYS reads M3000


iniclk:	LD	HL,rtcint
	LD	(intct1),HL

	LD	HL,intct1
	LD	A,L		;Set int vector into CTC
	AND	0F8H		;Low 3 bits must be 0
	OUT	(ctc0),A

	LD	A,0FFH		;Set up CTC for int on every N pulses
	OUT	(ctc1),A
	LD	A,1		; N=1
	OUT	(ctc1),A

	CALL	rdclk

;drop thru'


;PROCEDURE GetClk;
;
;Returns at COMMON /now/ an FS-formattede no longer RETs with stack unset!

;MONITOR globals
EXT	start
EXT	loinit,txlo
EXT	hexin,echo,abort

;GENLIB globals
EXT	pcrlf,prhex,prhl,msage
EXT	pdeca,gdeca,getlin,gethex

;RTC globals

EXT	writck,readck

stnreg	EQU	8		;Contains station no.
baudrt	EQU	9		;Contains baud rate
sumreg	EQU	10		;Contains checking info for reg 8,9
optreg	EQU	15

;SIOb
EXT	ini423
EXT	ist423,cin423,ost423,cot423

;Other

EXT	termtx
EXT	initmd,no_int		;Eco code
EXT	rwblk,dkinit,chksj	;In FRDISC

.REQUtry format :

	offset	0	Page no. of next entry
		1	Needs writing if =0, else =&FF
		2,3	Block no. with drive no. in 2 hi bits

Empty blocks have the block no. set to &FFFF, so we can have one disc of 64K-1
blocks, 3 discs of 16K blocks, or 4 discs of 16K-1 blocks.

Blocks are marked as empty if an error occured while trying to read into them.

	*

PUBLIC	discrd,discwr, inidsk, dalloc, alloc, fblk, inilow
PUBLIC	cidle, cempty, Veradr, Verlen, Vermsg, pcrlf

EXT	$hplm, pmess, cahex, verhi, verfdr		;Table to map logical drv nos to physical.

cacmap:	DEFS	noblks*4	;Cache sector map

page:	DEFS	1		;Current cache page

bldes:	DEFS	1		;This is a block descriptor for inidsk:
	DEFS	2		; to use as a parameter to rddisc: & alloc:



;	******* MAPMAN AREAS *********

lstadr:	DEFS	2		;Address of last block found

mapptr:	DEFS	noofdr*4	;( length (2) + mapptr (2) ) * noofdr


	END
lo, heap

EXT	fsexit, syserr, Sdelay, Srelea		;MDEPfran externals

EXT	no_int,enaint		;Net enable/disable. Must preserve all but AF.

inrom	EQU	False		;For timed loops - ROM code is slower

nmivec	EQU	066H		;about 10 bytes of code shifted in here


; port addresses

;***************************************************************

paport	EQU	034H		; Paged RAM/ROM control

;	RAM copy at copy: in COMMON /pacopy/
;	note that page is left open on exit : copy is for the use of IRQ rtns

pagon WORKS

The cache stores 1K blocks, up to 64 in all. Each block is held in 4 physical
pages, and all page numbers are in this form - ie. 0,4,8,12 are successive
pages. (page) holds the current page number and also acts as a head of
chain pointer. The map has 4 bytes per entry (hence physical page can be used
as an index) and the entries form a linked list. There is no tail pointer,
but <noblks> is the total number of active entries and hence a loop
can easily scan down to the tail of the list.

en),A
	POP	AF
	RETI

;
;	RS423 interrupt routines
;

exbint:	EI			;External status interrupt - ack & return
	PUSH	AF
	LD	A,020O
	OUT	(sbctrl),A
	POP	AF
	RETI

serint:	EI
	PUSH	AF
	LD	A,50O
	OUT	(sbctrl),A	;Reset Tx int pending
	XOR	A
	LD	(seract),A
	POP	AF
	RETI



; PROCEDURE FlushP;
; Discard contents of printer buffers

flushP:	RET


; PROCEDURE Char_IO;
;
; Initialise character I/O ports
; Also initialise message and debug flags from user values in (0F800H)


chario:	being loaded

PUBLIC	$memry,nmivec
PUBLIC	verhi,verlo

PUBLIC	inkey,pchar,srlmon,fsboot,ioinit,setstn	;Used by FRANUTIL code

dftstn	EQU	254

va	EQU	'0'
vb	EQU	'1'
vc	EQU	'3'

verhi	EQU	va+'.'*256
verlo	EQU	vb+vc*256

;modifications:
;	  - b7 of R reg now reset at start-up
;	  - New Bios-like IO implemented: CINST,CONIN,CONOUT @ 0,3,6
;	  - code now executes at 0C000H
; 29/6/84 - statid setting code impl.
;  5/7/84 - ROM map re-vamped so that it starts at offset 0
;	  - WBOOT entry at LD	A,(0f800H)
	LD	(mess),A
	LD	A,(0F801H)
	LD	(debu),A

	DI
	LD	HL,parint	;Insert IRQ vector for parallel
	LD	(intct3),HL

	LD	HL,serint	;SIO interrupt vectors
	LD	(inttbb),HL
	LD	HL,exbint
	LD	(intexb),HL

	LD	A,1
	OUT	(sbctrl),A
	LD	A,7		;ExtIE=on, TXint=on, SAV
	OUT	(sbctrl),A

	EI

	LD	A,L		;Low of int vector address
	AND	0F8H		;Calculate base for CTC
	OUT	(ctc0),A

	LD	A,0EFH		;Enable INT, counter mode, falling edge trigger
	OUT	(ctc3),A	; time constant follows.

	LD	A,1		;T3 (with ROM ON)
;  6/7/84 - 'Bios' like IO now lives in monitor
; 10/7/84 - RTC code: on reset waits for BUSY to go true before reading regs
;	  - remote log-on fixed
; 24/7/84 - Statid reset code also sets RTC status reg to 1
; 3/10/84 - new RS423 code has handshake
;	  - EVENTV moved to DSEG
; 26/10/84- Modifications to support FRANUTIL
; 10/12/84- Boot code added/modified
; 12/12/84- now auto-boots
; 14/12/84- Warm start @100H (jumped from 003). Cold start now at 0103H.
; 17/12/84- Boot &c cod
TITLE I/O Routines for FRANCIS FS 30/10/84: FRANIO.MAC
.Z80
;
;**********************************************
;THIS MUST BE THE 1st MODULE LOADED
;*********************************************
; this will ensure that the NMI vector is at the start of the DSEG
; and can hence be jumped to.



;Monitor PUBLICs
PUBLIC	extra
PUBLIC	cinst,cin,cout,cflush	;cflush actuallu used just by DKFRAN
PUBLIC	prompt

;FASTREMOTE publics
PUBLIC	iojmps,eventv
PUBLIC	notify,remchr,setrem	;to prevent RXPROC  B vectors
inttbb	EQU	intvec+0
intexb	EQU	intvec+2
intrdb	EQU	intvec+4
intsrb	EQU	intvec+6

;Side A vectors
tbevec	EQU	intvec+8
extvec	EQU	intvec+10
rdavec	EQU	intvec+12
srcvec	EQU	intvec+14

intoff	EQU	2+(LOW intvec)*256

;CTC vectors

intct0	EQU	intvec+16
intct1	EQU	intvec+18
intct2	EQU	intvec+20
intct3	EQU	intvec+22

	END
0FD10H    Nascom
; 0FB00H    Francis ROM
; 0EAD0H    Ithaca
; 00080H    New HDFS, Francis FS code
; Other	    Other

;Sidernt:
;	Entered here from Pchar also.
;	A=1 for parallel =2 for serial
;	(SP)=return addr, (SP+2)=^byte count, (SP+4)=^data

doprnt:	POP	BC		;Return address
	POP	HL
	POP	DE
	PUSH	BC		;Now just return address on stack

;	DE=^data, A=1 for parallel =2 for serial, HL=^byte count

	DEC	A		;=0 if para, =1 if serial
	JR	NZ,prseri

;***********
;
; REMEMBER TO MODIFY FSEXIT: WHEN RE-WRITING THIS CODE
;
;***********



;
;	Temporary unbuffered parallel output
;
	LD	(HL),0		;No chars sent ye

; Various version string related routines :
;
; PROCEDURE ver_msg;		prints SJ FS ver etc. on screen
; FUNCTION ver_adr:Word;	Returns address of a block containing the
;				version string with a std. Tx header on the
;				front, suitable for the 'read FS version'
;				FS call.
; FUNCTION Ver_len:Word;	Returns length of block.
;


vermsg:	LD	DE,sjmess		;Print version on screen
	JP	pmess

veradr:	LD	HL,verblk		;Address of version text to
	RET				;Transmit for *VERS

verlen:	LD	HL,crlf-verblt
	LD	A,(paract)
	OR	A
	RET	NZ		;Printer not ready
	INC	A		;A:=1
	LD	(paract),A	;Clear ready flag
	LD	A,(DE)
	OUT	(pprint),A
	INC	(HL)		;Record char	
	RET

;	Temporary non-interrupt serial I/O

prseri:	LD	(HL),0		;Done 0 chars so far
	LD	A,(seract)
	OR	A
	RET	NZ		;Printer not ready
	INC	A		;A:=1
	LD	(seract),A	;Clear ready flag
	LD	A,(DE)
	OUT	(sbdata),A
	INC	(HL)		;Record char	
	RET

;
;	Parallel printer IRQ routine
;

parint:	EI
	PUSH	AF
	XOR	A		;Record ACK pulse
	LD	(paractk+1	;Length of transmitted text
	RET

verblk:	DEFW	0			;Std. Tx Header

sjmess:	DEFM	'SJ Research File Server ver '
	DEFW	verhi,verlo

	DEFM	'/FDFS'


; NB this label must be defined before any references to the MESS
; macro is made.
; NB2 also forms part of the above string.

crlf:	DEFM	cr,lf,'$'


	IF	t.on

;dhxout
;Print hex of HL

dhxout:	LD	A,H
	CALL	cahex
	LD	A,L
				;DROP THROUGH
;cahex
;Print hex of A
;
;On entry:
; A	number to be printed

	JP	cahex		;Now lives in h2.Z80
TITLE	Disk & Map managing routines for FRANCIS
NAME	('DkFran')

; modifications:
; 19/3/84 Restore cmd has verify
; 22/3/84 Various waiting code for Tunnelling etc
; 17/8/84 Conversion to COS disc routines & 1K hardware page size.
; 20/10/84 Support for 380Z double density
; 28/10/84 Nascom vesion now has start block=0826H, not 05050H
;  8/12/84 Francis version generated.
; 13/12/84 Now supports FS code stored in blocks 2..63

true	EQU	-1
false	EQU	0

t.on	EQU	true	;Trace
c.on	EQU	trueen, Vermsg, pcrlf

EXT	$hplm, pmess, cahex, verhi, verlo, heap

EXT	fsexit, syserr, Sdelay, Srelea		;MDEPfran externals

EXT	no_int,enaint		;Net enable/disable. Must preserve all but AF.

inrom	EQU	False		;For timed loops - ROM code is slower

nmivec	EQU	066H		;about 10 bytes of code shifted in here


; port addresses

;***************************************************************

paport	EQU	034H		; Paged RAM/ROM control

;	RAM copy at copy: in COMMON /pacopy/
;	note that page is left	;Parameter checking



	.COMMENT	*

HOW THE CACHE WORKS

The cache stores 1K blocks, up to 64 in all. Each block is held in 4 physical
pages, and all page numbers are in this form - ie. 0,4,8,12 are successive
pages. (page) holds the current page number and also acts as a head of
chain pointer. The map has 4 bytes per entry (hence physical page can be used
as an index) and the entries form a linked list. There is no tail pointer,
but <noblks> is the total number of active entries and hence a lPUBLIC	intvec			;base INT vector (ie side B)
PUBLIC	inttbb,intexb,intrdb,intsrb	;side B vectors
PUBLIC	tbevec,extvec,rdavec,srcvec	;side A vectors
PUBLIC	intoff			;interrupt page offset command
PUBLIC	intct0,intct1,intct2,intct3


intvec	EQU	0080H


; Values of intvec should be:
;
; 0FFF0H    Ithaca floppies etc, Old HDFS
; 0FC00H    RML's, Jade
; 0FC10H    480Z's
; 0FD10H    Nascom
; 0FB00H    Francis ROM
; 0EAD0H    Ithaca
; 00080H    New HDFS, Francis FS code
; Other	    Other

;Sideoop
can easily scan down to the tail of the list.

entry format :

	offset	0	Page no. of next entry
		1	Needs writing if =0, else =&FF
		2,3	Block no. with drive no. in 2 hi bits

Empty blocks have the block no. set to &FFFF, so we can have one disc of 64K-1
blocks, 3 discs of 16K blocks, or 4 discs of 16K-1 blocks.

Blocks are marked as empty if an error occured while trying to read into them.

	*

PUBLIC	discrd,discwr, inidsk, dalloc, alloc, fblk, inilow
PUBLIC	cidle, cempty, Veradr, Verlווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווtry format :

	offset	0	Page no. of next entry
		1	Needs writing if =0, else =&FF
		2,3	Block no. with drive no. in 2 hi bits

Empty blocks have the block no. set to &FFFF, so we can have one disc of 64K-1
blocks, 3 discs of 16K blocks, or 4 discs of 16K-1 blocks.

Blocks are marked as empty if an error occured while trying to read into them.

	*

PUBLIC	discrd,discwr, inidsk, dalloc, alloc, fblk, inilow
PUBLIC	cidle, cempty, Veradr, Verlen, Vermsg, pcrlf

EXT	$hplm, $memry, fsexit, syserr, PUBLIC	intvec			;base INT vector (ie side B)
PUBLIC	inttbb,intexb,intrdb,intsrb	;side B vectors
PUBLIC	tbevec,extvec,rdavec,srcvec	;side A vectors
PUBLIC	intoff			;interrupt page offset command
PUBLIC	intct0,intct1,intct2,intct3


intvec	EQU	0FB00H


; Values of intvec should be:
;
; 0FFF0H    Ithaca floppies etc, Old HDFS
; 0FC00H    RML's, Jade
; 0FC10H    480Z's
; 0FD10H    Nascom
; 0FB00H    Francis ROM
; 0EAD0H    Ithaca
; 00080H    New HDFS, Francis FS code
; Other	    Other

;Sidpmess, cahex, verhi, verlo, heap

EXT	no_int,enaint	;Net enable/disable. Must preserve all but AF.

inrom	EQU	False		;For timed loops - ROM code is slower

nmivec	EQU	066H		;about 10 bytes of code shifted in here


; port addresses

paport	EQU	034H		; Paged RAM/ROM control
pagon	EQU	3		;value for paged RAM open, ROM off
pagoff	EQU	1		;value for CLOSED
romoff	EQU	1		;Set if ROM off

mstart	EQU	035H		;Read port to start disc motor
mstop	EQU	036H		;similarly to stop.

mtrtim	EQU	10		;No. of e B vectors
inttbb	EQU	intvec+0
intexb	EQU	intvec+2
intrdb	EQU	intvec+4
intsrb	EQU	intvec+6

;Side A vectors
tbevec	EQU	intvec+8
extvec	EQU	intvec+10
rdavec	EQU	intvec+12
srcvec	EQU	intvec+14

intoff	EQU	2+(LOW intvec)*256

;CTC vectors

intct0	EQU	intvec+16
intct1	EQU	intvec+18
intct2	EQU	intvec+20
intct3	EQU	intvec+22

	END
 0FD10H    Nascom
; 0FB00H    Francis ROM
; 0EAD0H    Ithaca
; 00080H    New HDFS, Francis FS code
; Other	    Other

;Sidtes.

	XOR	A		;Turn off offline LED
	OUT	(leds),A
	CALL	Sdelay
	LD	A,onlin		;Online LED on again
	OUT	(leds),A
	CALL	Sdelay		;Returns Z if operator presses switch
	JR	NZ,pchar1	;Don't wait if so.

pchar2:	POP	DE
	RET



; PROCEDURE Print(addr:Word;VAR count:Byte;channel:Byte);
;
; Insert chars into print buffer.
; <count> indicates how many chars available, & is returned holding number
; actually transferred.

print:	POP	HL
	EX	(SP),HL		;H:=channel no.

	LD	B,H		;Save printer no.
	L

exbint:	EI
	PUSH	AF
	LD	A,RsExt
	OUT	(sbctrl),A
	POP	AF
	RETI



ist423:	IN	A,(sbctrl)
	AND	1 SHL rda
	RET	Z
	LD	A,-1
	RET

cin423:	IN	A,(sbdata)
	RET

ost423:	IN	A,(sbctrl)
	BIT	cts,A
	JR	Z,ostrz
	BIT	tbe,A
	JR	Z,ostrz
	LD	A,-1
	RET
ostrz:	XOR	A
	RET

cot423:	OUT	(sbdata),A
	RET







	END
0C1H
	DB	5,0E8H
	DB	1,5		;ExtIE SAV
lenda1	EQU	$-data1


;This interrupt routine basically unlatches the input status bitsD	A,B
	LD	HL,useflg	;Point to user/message printer flag
	AND	(HL)		;=0 if already a user printer
	LD	A,B		;Restore number
	JR	Z,doprnt	;All is OK

	XOR	(HL)		;Not ok - was in use as message printer
	LD	(HL),A		;Clear flag

	LD	HL,msgch	;Point to current message channel
	LD	C,(HL)		;Save old value
	LD	(HL),B		;Insert our printer number
	
	LD	E,12		;Form feed
	PUSH	BC
	PUSH	HL
	CALL	dochar		;Print char from E
	POP	HL
	POP	BC
	LD	(HL),C		;Restore (msgch)
	LD	A,B		;A:=printer number

;	dopווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווווTITLE RS423 routines
.Z80
NAME	('RS423')

PUBLIC	ini423
PUBLIC	ist423,cin423,ost423,cot423

EXT	intexb


sio	EQU	30H
sbdata	EQU	sio+2
sbctrl	EQU	sio+3

rda	EQU	0
tbe	EQU	2
cts	EQU	5

RsExt	EQU	20O


ini423:	LD	HL,exbint
	LD	(intexb),HL	;ExtInt vector

	LD	HL,data1
	LD	BC,lenda1*256+sbctrl
	OTIR

	RET


data1:	DB	30O		;Reset
	DB	4,84H		;DIV 32
	DB	3,0C1H
	DB	5,0E8H
	DB	1,5		;ExtIE SAV
lenda1	EQU	$-data1


;This interrupt routine basically unlatches the input status bits,A
	OUT	(leds),A
	CALL	Sdelay
	JR	NZ,exit2	;Timed out

	;Drop through if operator pressed switch to exit


; doexit:

; Turn on ROM, re-enter monitor.
;NB this code must NOT be underneath the ROM ie not in the area 0..3FFFH

doexit:	LD	A,06FH		;Value to disable CTC interrupt
	OUT	(ctc1),A	;Disable 1Hz int
	OUT	(ctc1),A	;Compulsory time constant - value irrelevant
	OUT	(ctc3),A	;Same for parallel printer
	OUT	(ctc3),A

	CALL	no_int		;No net irqs
	DI
	LD	A,01
	OUT	(sbctrl),A	;No side B i	(HL)
	JR	NZ,ok4us	;Already in use as message printer

	LD	A,(HL)		;Update flags
	OR	B
	LD	(HL),A

	PUSH	DE		;Save character

	LD	HL,systxt	;Print header for our output
	LD	D,syslen
prtxt:	LD	E,(HL)
	PUSH	HL
	CALL	dochar
	POP	HL
	INC	HL
	DEC	D
	JR	NZ,prtxt
	POP	DE		;Restore the message character

ok4us:	CALL	dochar

	POP	HL
	POP	IY
	POP	BC
	POP	AF
	RET

systxt:	DB	12,'******* SYSTEM MESSAGES *******',13,10
syslen	EQU	$-systxt



; Code to do Pchar action. Preserves DE (only)rqs either
	XOR	A
	OUT	(sbctrl),A

	OUT	(paport),A	;0 is ROM on value

	JP	3		;warm restart monitor






;GETMEM
;
;This routine returns the first unavailible memory location on the
; machine in DE & returns to HL

getmem:	LD	DE,0F800H
	JP	(HL)






; FUNCTION Offlin(channel:Byte):Boolean;
;
; Return hardware status of given printer (1=para,0=serial)
; Francis printers have no hardware status, so return FALSE

offlin:	POP	HL
	EX	(SP),HL		;H:=channel no.
	XOR	A		;Return FAL

dochar:	PUSH	DE		;NB. E is parameter

pchar1:	LD	A,1
	PUSH	AF		;This will be pointed to as VAR count:Byte

	LD	HL,2
	ADD	HL,SP		;Get address of E on stack

;	Push 4 bytes of parameters to Print:

	PUSH	HL		;Data address
	DEC	HL		;Point to byte value 1 just pushed
	PUSH	HL

	LD	A,(msgch)	;Select which printer

	CALL	doprnt		;Takes A & 4 bytes on stack as parameters

	POP	AF		;The byte count
	OR	A		;Set flags (A value in stack was poked)
	JR	NZ,pchar2	;If =0, the call to print did 0 bySE
;	RET
;	Drop through to RET


;
; PROCEDURE Dolist;

; Initiate transfers from buffers in RAM to printer devices
; when buffers not empty & devices ready.
; Francis I/O is interrupt driven, so do nothing.

dolist:	RET




;PCHAR
;
;Print character in E.  All registers preserved
;Output is to printer given by (msgch)

pchar:	PUSH	AF
	PUSH	BC
	PUSH	IY
	PUSH	HL

	LD	A,(msgch)	;Get channel number to use (=1 or =2)
	LD	B,A		;Save it
	LD	HL,useflg	;point to message/user flags
	AND1		;Set if ROM off

;***************************************************************

leds	EQU	035H		;LED port (active hi leds)
onlin	EQU	040H		;values to write
dkfree	EQU	080H

;***************************************************************



; PROCEDURE chksw;
;
; Routine to poll front pannel switches
;
; If switch pressed, change discs.
; <bldmap> calls <inidsk> in DKfran which flashes the change disc LED
; & waits for switch pressed - hence we must wait for switch released

chksw:	eturn NZ for normal timeout
	RET

; Srelea:
;
; Wait for switch to be released & debounce it.
; Corrupts A,B. Rest preserved
; Called from DKMAN, fsexit:, chksw:

Srelea:	LD	B,0
relea1:	IN	A,(status)
	EX	(SP),HL		;Slow instruction to increase debounce time
	EX	(SP),HL
	BIT	chdisc,A	;Test if released - if not, re-start timer
	JR	Z,srelea
	DJNZ	relea1		;Debounce switch
	RET



;
; FUNCTION Syst_sw:Boolean;
;
; Return condition of key switch.
; Francis has no key switch, so permanently IN	A,(status)
	BIT	chdisc,A
	RET	NZ		;Not pressed
	CALL	emptyC

	CALL	Srelea		;Wait for switch to be released

	CALL	bldmap		;Re-build disc maps etc.

;	Drop through to show that we are now online again


; PROCEDURE On_line;
; Illuminate the on-line lamp!

online:	LD	A,onlin		;Disc Free OFF, online ON
	OUT	(leds),A
	RET



; syserr:
; Halt, flashing LEDs, until switch pressed to exit.

syserr:	XOR	A			;ROM (& hence LED) ON
	OUT	(paport),A
	CALL	Sdelay
	JR	Z,fsexit		;Operator forcin system pos.

systsw:	XOR	A
	INC	A		;Return TRUE
	RET



;
; FSexit - exit to monitor. Must flush printer buffers 1st.

fsexit:	XOR	A		;Turn both LEDs OFF
	OUT	(leds),A
	LD	D,A

	CALL	Srelea		;Wait for switch to be released

;
; TEMP - printers have no buffer, so exit
;
	JR	doexit

exit2:	LD	HL,paract	;Parallel print active if <>0
	LD	A,(HL)
	INC	HL
	OR	(HL)		;Sample serial state also
	JR	Z,doexit	;Neither printer active

	LD	A,D		;LED state
	XOR	onlin		;Flip online bit
	LD	Des exit.

	LD	A,romoff		;ROM & LED off
	OUT	(paport),A
	CALL	Sdelay
	JR	syserr


; Sdelay:
; Delay for ~.5 sec.
; Exit immediately if switch pressed
; Called from Syserr: & Pchar: & in dkfran

; On exit,
;	NZ	for normal exit after time delay
;	Z	If exit caused by operator pressing change disc switch
;	HL=0	if normal exit

Sdelay:	LD	HL,0
del2:	IN	A,(status)
	BIT	chdisc,A	;Test for switch pressed
	RET	Z		;Return if so (switch active lo)

	DEC	HL
	LD	A,L
	OR	H
	JR	NZ,del2
	INC	A		;Re (=0 for no error)

	LD	A,pagoff
	OUT	(paport),A

	LD	A,C		;=0 if no error
	AND	D		;=0 if write
	RET	Z
	LD	(IY+2),0FFH	;Error during read, so cache now holds junk.
	LD	(IY+3),0FFH	;Mark as empty.
	RET


	ENDIF

; Dkinit
;
; Set up hardware ready for use.

dkinit:	XOR	A
	OUT	(dskctl),A	;Deselect all drives
	LD	(dkctlm),A	;Set up RAM copy
	LD	(ticloc),A	;Indicate stopped
	IN	A,(mstop)	;Stop drive motors
	LD	A,ctcset	;Wind up timer for head load
	OUT	(ctc0),A	;ctc0 controls head load 	;Return to save looping up chain

;	Move the new entry to the top of the chain
;	IY points to new entry, C is previous page, E is new page
;	On exit, carry set, A=(page), B=0, HL=^previous ent

setpag:	LD	HL,cacmap
	LD	B,0			;BC now = previous page no.
	ADD	HL,BC

	LD	A,(IY+0)
	LD	(HL),A			; previous^.next:=new_ent^.next
	LD	A,(page)
	LD	(IY+0),A		; new_ent^.next:=head_ptr
	LD	A,E
	LD	(page),A		; head_ptr:=new_ent

	SCF
	RET







;RWBLK
;Read/Write block to/from disk
;
;
;Onous page no.

	LD	A,noblks		;Number of entries to search
	LD	B,A			;For DJNZ

filoop:	LD	C,E			;Save previous pageno
	LD	E,(IY+0)		;Advance to next
	LD	IY,cacmap		;Calculate address of cacmap entry
	ADD	IY,DE

	LD	A,(IY+2)
	CP	L
	JR	NZ,filop1		;No good
	LD	A,(IY+3)		;Test hi byte
	CP	H
	JR	Z,found			;Both agree

filop1:					;Get here if this block no good
	DJNZ	filoop			;Fall through if we have tried all ents

; Now have tail of chain

	PUSH	HL			;Save blockno.
	CALL	setpag			;Make th entry:
; D	Read flag (&FF -> read, 0 -> write)
; IY	Points to map entry
;(page)	**NOT USED** (hence we can write blocks not at head of chain)
;
;On exit:
; C	Error code (0 = OK)
;	(errloc) also updated
; (IY)	Needs writing flag cleared always. Blockno zapped if read error

rwblk:	LD	(IY+1),0FFH	;Clear needs writing flag

	PUSH	IY
	POP	HL		;Calculate page no. from table offset
	LD	BC,cacmap	;Start of table
	OR	A		;Clear carry
	SBC	HL,BC
	LD	A,L		;the answer (NB. 1K pages, so low 2 bits =0)is into head of chain
	LD	A,(IY+1)		;Needs writing flag
	OR	A			; sets Zf, also clears Cf
	JR	NZ,setblk		;Not required, so just insert blkno.
	LD	D,0			;r/w flag set to write
	CALL	rwblk
setblk:	POP	HL			;Get back blockno.
	LD	(IY+2),L
	LD	(IY+3),H		;Store in map
	OR	A			;Clear carry <=> not found
	RET


;	Found already in cache, so set carry for return & drop through
;	to move to head of chain if not already there.

found:	LD	A,(page)
	CP	E			;Test for already head of chain
	SCF
	RET	Z		 RAM copy of this port at <dkctlm>


fdbase	EQU	004H		;2793 address
fdctrl	EQU	fdbase
fdstat	EQU	fdbase
fdtrk	EQU	fdbase+1
fdsec	EQU	fdbase+2
fddata	EQU	fdbase+3

;status bits

busy	EQU	0
index	EQU	1
trk0	EQU	2
notrdy	EQU	7

;FDC commands

home	EQU	008H	;Seek trk 0 + Step 3|6mS + Head Load + no verify
seek	EQU	01CH	;Seek trk n + Step 3|6ms + Head Load +    verify
rdsec	EQU	080H	;Read 1 sec + No settle time + No side compare
wrsec	EQU	0A0H	;Write 1 sec + No settle + no side comp + Data LE RWBLK                          *
;**********************************************
;

;RWBLK
;Read/Write block to/from disk
;
;
;On entry:
; D	Read flag (&FF -> read, 0 -> write)
; IY	Points to map entry
;(page)	**NOT USED** (hence we can write blocks not at head of chain)
;
;On exit:
; C	Error code (0 = OK)
;	(errloc) also updated
; (IY)	Needs writing flag cleared always. Blockno zapped if read error

rwblk:	LD	(IY+1),0FFH	;Clear needs writing flag

	PUSH	IY
	POP	HL		;Calculate page nmark
trkinc	EQU	058H	;+1 Trk + inc reg + Step 3|6mS + Head Load + No Verify
writrk	EQU	0F4H	;Write track + settle time
frcint	EQU	0D0H	;Force interrupt never <=> force type 1 status

maxtry	EQU	4	;Max number of attempts on disc commands

ctc0	EQU	038H		;Head load timing channel

ctcset	EQU	07FH		;value to init (followed by time const in secs)
ctcrst	EQU	07BH		;value to reset (ie start timed period again)



;
; PROCEDURE ver_msg;		prints SJ FS ver etc. on screen
;

vermsg:	LD	DE,sjmess
	Jo. from table offset
	LD	BC,cacmap	;Start of table
	OR	A		;Clear carry
	SBC	HL,BC
	LD	A,L		;the answer (NB. 1K pages, so low 2 bits =0)
	OR	A,pagon		;Bit(s) to turn on paging
	OUT	(paport),A

	LD	L,(IY+2)	;blockno.
	LD	A,(IY+3)	; Hi byte also holds drive
	AND	3FH		;not any more
	LD	H,A		;HL=block no =sector no.

	LD	A,(IY+3)	;Drive
	RLCA
	RLCA
	AND	03H		;Now back in right place
	LD	E,A

	LD	BC,secbuf	;Ram address where paged RAM appears
	PUSH	DE
	CALL	rwsec
	POP	DE
	LD	C,A		;Error codP	pmess


sjmess:	DEFM	'SJ Research File Server ver '
	DEFW	verhi,verlo

	DEFM	'/FDFS'

crlf:	DEFM	0DH,0AH,'$'


	IF	0		;Dhxout is not used
;dhxout
;Print hex of HL

dhxout:	LD	A,H
	CALL	cahex
	LD	A,L
				;DROP THROUGH
;cahex
;Print hex of A
;
;On entry:
; A	number to be printed

	JP	cahex		;Now lives in h2lib or some such place

	ENDIF

fatmsg:	DEFM	0DH,0AH,'Fatal disc error $'
errmsg:	DEFM	' Error $'


	IF	0
;
;**********************************************
;* DKMAN STYQU	intvec+2
intrdb	EQU	intvec+4
intsrb	EQU	intvec+6

;Side A vectors
tbevec	EQU	intvec+8
extvec	EQU	intvec+10
rdavec	EQU	intvec+12
srcvec	EQU	intvec+14

intoff	EQU	2+(LOW intvec)*256

;CTC vestors

intct0	EQU	intvec+16
intct1	EQU	intvec+18
intct2	EQU	intvec+20
intct3	EQU	intvec+22

	END
 0FD10H    Nascom
; 0EAD0H    Ithaca
; 00080H    New HDFS
; Other	    Other

;Side B vectors
inttbb	EQU	intvec+0
intexb	E.Z80
TITLE	'FRANCIS Disc routines'
NAME	('FRDISC')

true	EQU	-1
false	EQU	0

	EXT	no_int,enaint	;Net enable/disable. Must preserve all but AF.
	EXT	cflush		;Flush console output buffer
	EXT	fdata,newtrk	;UFORMAT externals
	EXT	nmivec

	PUBLIC	dkinit,format,rwblk,vermsg,chksj,openca

	EXT	pmess, cahex, verhi, verlo

inrom	EQU	True


;Block 0 offsets

sjoff	EQU	64		;Offset to 'SJ Research File Server'




; port addresses

paport	EQU	034H		; Paged RAM/ROM control
pagon	EQU	3		;val`4°Vמׂךכv.«@ (n¿]1–
H₪¥G ₪‰ˆ(Jq׀ 
H˜‚ˆ‰  „‰ˆH1״
H˜†¡© ִ‰ˆi×
Q׳P
H˜ˆ‡Y ₪‰ˆ×JQײ°
H˜’‡J ₪‰‰ָ¨ס׀נ
H˜¦×…' „‰ט1ׂאH˜®©< ₪‰ך³€  …UּSP BEteH‘]$WFTUIׁ‘`REt%8‘]9$WBT‰ױ׃US bEuTױTֹ@ ײTֵh÷ײמׂ`ו[»HDBk²–€ ֿw%ײ`4­¥ ְ¨][»HDBhײֹ>=ןX„  [»JL—כ…¢Z g±@*ױ~÷]b  עKeֶ ֻ,Fֻ	-ִCֲQ cס€2ֻ-ִfH„  <-ֵ00Anֻ  !–Xq–²ֳ!‰’-d@2ֻ2ֳ¬°ָAהE6	€˜יH$WABS€BEt%HטH$WFD€REtdEXט $WFT‹€REteEXיh$WNEG³ bEuTױTָך$WWMUL   …PP BD$eH‘	QV$BFDI‘‘e  Qאyב"ׂw v‘#wְue for paged RAM open, ROM off
pagoff	EQU	1		;value for CLOSED
romoff	EQU	1		;Set if ROM off

mstart	EQU	035H		;Read port to start disc motor
mstop	EQU	036H		;similarly to stop.

mtrtim	EQU	10		;No. of seconds for drive motors to run

dskctl	EQU	037H		;Disc density, sidesel & drive sel port
precmp	EQU	7		;Hi for precomp **NOT USED**
sinden	EQU	6		;Hi for single density **NOT USED**
inch8	EQU	5		;Set for 8" data rate
sidsel	EQU	4		;=1 for side 1
				;Bits 0..3 are drive selects
;NB. there is anֹ'!€= GY1׀PH„‰ ₪ˆHָ±׀ H„© ₪ˆH³€  …P“P RD$D•h‘	%YVP 5W p¸ֱִx`0בqƒ€w• e¾]₪C{,ר(]ָz](g>­ֵ£גZְ! –<ׂל± ]z8%D±ס–q`2ֿ" 2א>'† ®ׂ#$|J ™   רֹƒ€RD$D•hט $BDIVU© RD„U%)ְ  …PSP RD$ױTָ‘	5U1VP 5@ p¸ְֱx`(בq“ײן*  ם"ֿ*ֲ{,ר(¥ׂ†sךP>-ֵ0!.·e‘E  }–=Lל³ֻ ^g>‹ֽג6H„  dַAְ)"j×dt !&×¦*־   …UM“P REUץ9@ ױ$תב€ ’pײ& C$aבn(R€ֹ<_מV«
(ִa¥נ¡מֱh¸B`ׁ¥.0Z.‹Tצ$G``2ש'€Cץ׃  ₪×	ךs€  …UMSP RET4ױ‘U5AJP 5H  C »ץֲ!  $חX˜ iˆָֿW+ Dlוn(ג€XLFK`P	BC
wrm1:	POP	AF
	ENDIF

	JR	NZ,clrblk	;No pre-read means zap to =0
	JR	C,rdywr		; Carry => it's been pre-read anyway

	PUSH	BC
	PUSH	DE
	PUSH	HL

	LD	D,0FFH		; r/w flag (read)

	LD	A,B		;Now test for BC=0400H => don't read
	SUB	4		;because the whole blk will be over-written
	OR	C
	CALL	NZ,rwblk	;IY contains all other info

	POP	HL
	POP	DE
	POP	BC

;	Now ready to write (into cache)
;	HL=source, DE=offset to dest., BC=byte count
rdywr:
	LD	(IY+1),0	;Needs writing (or soon will!)

 cf	set	Found
;	clear	Not found
;
; HL,DE,BC registers all used
;

fiblk:

;Put drive in top 2 bits of block number

	LD	A,(HL)			;Drive
	RRCA
	RRCA				;Put in top 2 bits
	INC	HL
	LD	E,(HL)			;Lo(block)
	INC	HL
	OR	(HL)			;Hi byte add to drive bits
	LD	D,A
	EX	DE,HL

;	fudge to get started - note that link pointer is at start of map entry

	LD	IY,page			;Start of chain - IY usually points to
					; the previous entry
	LD	D,0

;	HL=block/drive no, D=0
;	In loop, DE=page no, C=previ	LD	A,(page)	;Open paged RAM
	OR	pagon
	LD	(copy),A
	OUT	(paport),A

	LD	A,D		;Add user's offset to address of paged RAM
	ADD	A,HIGH secbuf
	LD	D,A
	LDIR

	RET



;	Clear block to zero to give correct value in areas not initialised
;	by the user

clrblk:	LD	A,B
	SUB	4		; 0400H <=> 1K <=> block size
	OR	C
	JR	Z,rdywr		;ready to write

do:	PUSH	BC
	PUSH	DE
	PUSH	HL		;save working registers

	LD	A,(page)	;Open page
	OR	pagon
	LD	(copy),A
	OUT	(paport),A

	LD	BC,03FFH	;Length-1
	…’S• d”וEdT8%9QQ	
INTEXB’S•‘ d”וE5$(Q	YEXTVEC”‘U‘Pאe5$5dT8%9Q=INTCT0’S•ױ`d”וD5C(%9QP־P  ָ«
ָ¨qֹ ’¨†¨a’ ֹ)ˆj†1ֹ@’¨†¨e– ֹ)ˆj†qָ ’¨°…€ֹ)‰טָָׁ@’¨₪ˆ…† ֹ)jHQָ ’¨¨„…€ ֹ)ָ¨qְָ₪ˆ‚¬‡ jHjָ¨qָ€¨„¬‡8        ct0	EQU	intvec+16
intct1	EQU	intvec+18
intct2	EQU	intvec+20
intct3	EQU	intvec+22

	END
0FD10H    Nascom
; 0FB00H    Francis ROM
; 0EAD0H    Ithaca
; 00080H    New HDFS, Francis FS code
; Other	    Other

;SideLD	HL,secbuf
	LD	DE,secbuf+1
	LD	(HL),0		;Value which will be copied all the way down
	LDIR	

	;NB. page left open - will be closed after writing data in

	POP	HL
	POP	DE
	POP	BC
	JR	rdywr


;fiblk
;
;Find block in cache.
; If block not found, return the tail of the chain, making it the head
; then writing out if necessary & inserting the new info in the map.
;
;On entry:
; HL	address of block descriptor (drive then block)
;
;On exit:
;(page)	updated
; IY	points to entry in cacmap
;f offline LED
	OUT	(leds),A
	CALL	Sdelay
	LD	A,onlin		;Online LED on again
	OUT	(leds),A
	CALL	Sdelay		;Returns Z if operator presses switch
	JR	NZ,pchar1	;Don't wait if so.

pchar2:	POP	DE
	POP	HL
	POP	IY
	POP	BC
	POP	AF
	RET



; PROCEDURE Print(addr:Word;VAR count:Byte;channel:Byte);
;
; Insert chars into print buffer.
; <count> indicates how many chars available, & is returned holding number
; actually transferred.

print:	POP	BC
	POP	AF
	POP	HL
	POP	DE
	PUSH	BC

;	DE=^data,s serial port
sbctrl	EQU	sio+3

rda	EQU	0		;SIO status bits
tbe	EQU	2
cts	EQU	5

rdabit	EQU	1

;***************************************************************

status	EQU	34H		;System status input port

fddreq	EQU	7		;2793 DREQ, active hi
nettxe	EQU	5		;Net TX enable monitor
chdisc	EQU	2		;switch - active lo
onesct	EQU	0		;Ones counter

;***************************************************************

pprint	EQU	036H		;Printer output

;*************************************************TITLE Various FS m/c-dependant routines 11/1/84: mdepfran.mac
.Z80
NAME	('MDepfran')

; modifications:
;  7/10/84 FSEXIT now waits forever to purge serial buffer if Debug on.
; 25/11/84 New print server system
; 27/11/84 syserr: added.
;  1/12/84 FlushP: added. Pchar now flashes online LED if waiting.
;  2/12/84 Dolist: now does not advance pointer until chars have been printed.
;  8/12/84 Francis version
; 24/12/84 Now sends PCHAR output to printer specified by COMMON/msgcha/
;  3/ 1/85 Banner **************

ctc	EQU	038H
ctc0	EQU	ctc+0		;Head load timing
ctc1	EQU	ctc+1		;1Hz interrupt
ctc2	EQU	ctc+2		;Baud rate (set up by ROM code)
ctc3	EQU	ctc+3		;Parallel printer ACK*


;***************************************************************

paport	EQU	034H		; Paged RAM/ROM control

;	RAM copy at copy: in COMMON /pacopy/
;	note that page is left open on exit : copy is for the use of IRQ rtns

pagon	EQU	3		;value for paged RAM open, ROM off
pagoff	EQU	1		;value for CLOSED
romoff	EQU	before PCHAR output added.


PUBLIC	fsexit, getmem, pchar, dolist, systsw, chksw, online
PUBLIC	offlin, print, syserr, flushP, chario, Sdelay, Srelea

EXT	emptyC,bldmap		;Pascal procedures - in BIGDATA.
EXT	intct3,intexb,inttbb	;Interrupt vector locations
EXT	no_int			;Disable net interrrupts

true	EQU	-1
false	EQU	0



	IF1
.PRINTX Francis version
	ENDIF



; port addresses


;***************************************************************

sio	EQU	30H
sbdata	EQU	sio+2		;Side B il status interrupt - ack & return
	PUSH	AF
	LD	A,020O
	OUT	(sbctrl),A
	POP	AF
	RETI

serint:	EI
	PUSH	AF
	LD	A,50O
	OUT	(sbctrl),A	;Reset Tx int pending
	XOR	A
	LD	(seract),A
	POP	AF
	RETI



; PROCEDURE FlushP;
; Discard contents of printer buffers

flushP:	RET


; PROCEDURE Char_IO;
;
; Initialise character I/O ports
; Also initialise message and debug flags from user values in (0F800H)


chario:	LD	A,(0f800H)
	LD	(mess),A
	LD	A,(0F801H)
	LD	(debu),A

	DI
	LD	HL,parint	s of given printer (1=para,0=serial)
; Francis printers have no hardware status, so return FALSE

offlin:	POP	HL
	EX	(SP),HL		;H:=channel no.
	XOR	A		;Return FALSE
;	RET
;	Drop through to RET


;
; PROCEDURE Dolist;

; Initiate transfers from buffers in RAM to printer devices
; when buffers not empty & devices ready.
; Francis I/O is interrupt driven, so do nothing.

dolist:	RET



;PCHAR
;
;Print character in E.  All registers preserved
;Output is to serial printer.

pchar:	PUSH	A;Insert IRQ vector for parallel
	LD	(intct3),HL

	LD	HL,serint	;SIO interrupt vectors
	LD	(inttbb),HL
	LD	HL,exbint
	LD	(intexb),HL

	LD	A,1
	OUT	(sbctrl),A
	LD	A,7		;ExtIE=on, TXint=on, SAV
	OUT	(sbctrl),A

	EI

	LD	A,L		;Low of int vector address
	AND	0F8H		;Calculate base for CTC
	OUT	(ctc0),A

	LD	A,0EFH		;Enable INT, counter mode, falling edge trigger
	OUT	(ctc3),A	; time constant follows.

	LD	A,1		;Time constant =1
	OUT	(ctc3),A

	LD	HL,parasp	;First of the buffer pointers
	F
	PUSH	BC
	PUSH	IY
	PUSH	HL
	PUSH	DE		;NB. E is parameter

pchar1:	LD	A,1
	PUSH	AF		;This will be pointed to as VAR count:Byte

	LD	HL,2
	ADD	HL,SP		;Get address of E on stack

;	Push 6 bytes of parameters to Print:

	PUSH	HL		;Data address
	DEC	HL		;Point to byte value 1 just pushed
	PUSH	HL

	LD	A,2		;Select serial
	PUSH	AF

	CALL	print

	POP	AF		;The byte count
	OR	A		;Set flags (A value in stack was poked)
	JR	NZ,pchar2	;If =0, the call to print did 0 bytes.

	XOR	A		;Turn ofֳ¯׃5!€ € ם°>׃4ֳ€ >  ! ׃4ם°<<<<‏ַ מֳ                                                                                                                                                                                                               ged RAM)
	OUT	(paport),A
	JP	nxtop		;Jump to main RAM

srcop:
	.DEPHASE

	.PHASE 0080H

nxtop:	LD	A,4+3		;Page no =1, rom off,page open
	LD	DE,0100H	;Dest for code

bootlp:	LD	BC,0400H
	LD	HL,0FC00H
	OUT	(paport),A
	LDIR
	INC	A
	INC	A
	IN
	XOR	A
	LD	B,E
	INC	B		;As drive numbers start at 0
	SCF
cdrnol:	RLA
	DJNZ	cdrnol
	LD	E,A		;has a single bit set in it.

;Convert sector number HL into track H & sector L

	LD	A,(inches)	;1 bit per drive - =1 for 8inch
	AND	E
	JR	Z,div5		;5" have 5 sec/trk

	SET	inch8,E		;Set 8" bit in value to put in dskctl port

;Divide by eight

	LD	A,L
	AND	7		;Remainder MOD 8

	ADD	HL,HL		;*2
	ADD	HL,HL		;*4
	ADD	HL,HL		;*8
	ADD	HL,HL		;*16
	ADD	HL,HL		;*32
				; div 8 <=> *32 DIV 256
	LD	L,return addr, (SP+2)=^byte count, (SP+4)=^data

doprnt:	POP	BC		;Return address
	POP	HL
	POP	DE
	PUSH	BC		;Now just return address on stack

;	DE=^data, A=1 for parallel =2 for serial, HL=^byte count

	DEC	A		;=0 if para, =1 if serial
	JR	NZ,prseri

;***********
;
; REMEMBER TO MODIFY FSEXIT: WHEN RE-WRITING THIS CODE
;
;***********



;
;	Temporary unbuffered parallel output
;
	LD	(HL),0		;No chars sent yet
	LD	A,(paract)
	OR	A
	RET	NZ		;Printer not ready
	INC	A		;A:=1
	LD	(paracA
	JR	dundiv	


;Divide by five - by subtracting 5*2^n, n=7..0  (max 160 tracks)

div5:	XOR	A		;to receive bits of result

	LD	BC,-280H	;280H = 5*128 decimal
tscon1:	ADD	HL,BC
	JR	C,tscon0	;carry => HL-BC positive
	SBC	HL,BC		;repair HL (carry cleared)
tscon0:	RLA			;Insert bit from carry into A
	SRA	B
	RR	C		;Reduce 'n'
	JP	NC,tscon1	;Carry => part of the '5' has fallen out

	LD	H,A		;Swap regs - so correct for output

dundiv:	POP	BC

; Now have H=trk, L=sector, D=read flag, E=drive bit),A	;Clear ready flag
	LD	A,(DE)
	OUT	(pprint),A
	INC	(HL)		;Record char	
	RET

;	Temporary non-interrupt serial I/O

prseri:	LD	(HL),0		;Done 0 chars so far
	LD	A,(seract)
	OR	A
	RET	NZ		;Printer not ready
	INC	A		;A:=1
	LD	(seract),A	;Clear ready flag
	LD	A,(DE)
	OUT	(sbdata),A
	INC	(HL)		;Record char	
	RET

;
;	Parallel printer IRQ routine
;

parint:	EI
	PUSH	AF
	XOR	A		;Record ACK pulse
	LD	(paract),A
	POP	AF
	RETI

;
;	RS423 interrupt routines
;

exbint:	EI			;Externats, BC=address

	SRL	H		;Modify track number (div 2)
	JR	NC,side0
	SET	sidsel,E	;Other side
side0:	INC	D		;D now 0 for read, 1 for write
	LD	D,rdsec
	JR	Z,rwdisc
	LD	D,wrsec

;drop through


;RWDISC - read, write, format disc.
;
; On entry :
;	BC	Ram address of data
;	D	FD command (expected to be read sec, write sec, or write trk)
;	E	drive sel, side sel, 5/8 inch to suit dskctl port
;	H	track
;	L	sector if reqd.
;
; <trkreg:> assumed to have been called
;
; On exit :
;	A	=0 if no error, =1 otherwise
; ALL OTHER REGS PRESERVED

rwdisc:	LD	A,maxtry
	LD	(retryc),A
retry:	PUSH	DE
	PUSH	HL
	PUSH	BC

	LD	A,(dkctlm)	;Copy of current disc select state
	XOR	E		;Compare with new drive
	AND	0FH		;Mask out side or density changes
	JR	Z,samedr

	LD	A,ctcset	;Wind up timer for head load
	OUT	(ctc0),A	;ctc0 controls head load timing (from 256Hz)
	LD	A,14		; time constant  13*1/256 =50.78ms
	OUT	(ctc0),A

	IN	A,(mstart)	;Motor start also clears 'head loaded' flipflop

samedr:	LD
	JR	NZ,trkok

	LD	A,L		;Sector no.
	OUT	(fdsec),A

	CALL	cflush		;Flush console buffer, in case it's FAST
	CALL	no_int		;temp disable net

;	Set up alt regs for NMI rtn

	EX	AF,AF'		;Save alt regs contents
	PUSH	AF
	EX	AF,AF'

	PUSH	BC		;Data addr
	EXX
	EX	(SP),HL		;HL':=^data, (SP):=old HL'
	PUSH	BC		;save HL',BC'
	LD	C,fddata	;port no
	EXX

;	Install appropriate NMI rtn

	LD	A,D		;Command
	BIT	5,D		;Test for read or write command
	LD	HL,nmird	;Code for read
	JR	Z,nmi1
	LD	HL,n	A,E
	OUT	(dskctl),A	;Select drive
	LD	(dkctlm),A	;Update copy

	DI			;In case clock ticks while testing <ticker>
	LD	A,(ticloc)
	OR	A		;Zero => motor already stopped.
	JR	NZ,going
	IN	A,(mstart)	;start the motor
going:	LD	A,080H		;Prevent it from stopping under clock ticks
	LD	(ticloc),A
	EI

;NB. After starting motor, the head load timer is not properly reset & will
;usually time out rather too soon. This does not matter, however, as
;it can be assumed that it takes longer for the drive to timing (from 256Hz)
	LD	A,14		; time constant  13*1/256 =50.78ms
	OUT	(ctc0),A
	LD	HL,trkno
	LD	B,4
zaptab:	LD	(HL),0FFH
	INC	HL
	DJNZ	zaptab
	RET



;RWSEC
;Read/Write sector to/from disk
;
;On entry:
;	BC	RAM address to read/write
;	 D	Read flag (FF-read,0-write)
;	 E	Disk number
;	HL	sector no.
;
;On exit:
; A	Error code (0 = OK, 1=error)
;	(errloc) also updated


rwsec:
	PUSH	BC

	CALL	trkreg		;Init track reg & pointer to trk table

;Convert drive number into drive bits
come to speed than
;the head load time, as the drive must do at least 1 rev to detect that it
;is up to speed, even if the motor was off only momentarily.

	IN	A,(fdtrk)
	CP	H		;Already at right trk?
	JR	Z,trkok

	INC	A
	CALL	Z,seekz		;trk=&FF <=> head pos not known
	LD	A,H
	OUT	(fddata),A	;Set up for seek

	LD	A,seek		;verify bit set only for settle time delay
	CALL	docmd		;NB. errors ignored as motor still running up

trkok:	IN	A,(fdstat)	;Wait for ready <=> motor full speed
	BIT	notrdy,Afers from buffers in RAM to printer devices
; when buffers not empty & devices ready.
; Francis I/O is interrupt driven, so do nothing.

dolist:	RET




;PCHAR
;
;Print character in E.  All registers preserved
;Output is to printer given by (msgch)

pchar:	PUSH	AF
	PUSH	BC
	PUSH	IY
	PUSH	HL

	LD	A,(msgch)	;Get channel number to use (=1 or =2)
	LD	B,A		;Save it
	LD	HL,useflg	;point to message/user flags
	AND	(HL)
	JR	NZ,ok4us	;Already in use as message printer

	LD	A,(HL)		;Update fl	;Online LED on again
	OUT	(leds),A
	CALL	Sdelay		;Returns Z if operator presses switch
	JR	NZ,pchar1	;Don't wait if so.

pchar2:	POP	DE
	RET



; PROCEDURE Print(addr:Word;VAR count:Byte;channel:Byte);
;
; Insert chars into print buffer.
; <count> indicates how many chars available, & is returned holding number
; actually transferred.

print:	POP	HL
	EX	(SP),HL		;H:=channel no.

	LD	B,H		;Save printer no.
	LD	A,B
	LD	HL,useflg	;Point to user/message printer flag
	AND	(HL)		;=0 if alreags
	OR	B
	LD	(HL),A

	PUSH	DE		;Save character

	LD	HL,systxt	;Print header for our output
	LD	D,syslen
prtxt:	LD	E,(HL)
	PUSH	HL
	CALL	dochar
	POP	HL
	INC	HL
	DEC	D
	JR	NZ,prtxt
	POP	DE		;Restore the message character

ok4us:	CALL	dochar

	POP	HL
	POP	IY
	POP	BC
	POP	AF
	RET

systxt:	DB	12,'******* SYSTEM MESSAGES *******',13,10
syslen	EQU	$-systxt



; Code to do Pchar action. Preserves DE (only)

dochar:	PUSH	DE		;NB. E is parameter

pchar1:	LD	A,1
	PUSH	AF		;This willady a user printer
	LD	A,B		;Restore number
	JR	Z,doprnt	;All is OK

	XOR	(HL)		;Not ok - was in use as message printer
	LD	(HL),A		;Clear flag

	LD	HL,msgch	;Point to current message channel
	LD	C,(HL)		;Save old value
	LD	(HL),B		;Insert our printer number
	
	LD	E,12		;Form feed
	PUSH	BC
	PUSH	HL
	CALL	dochar		;Print char from E
	POP	HL
	POP	BC
	LD	(HL),C		;Restore (msgch)
	LD	A,B		;A:=printer number

;	doprnt:
;	Entered here from Pchar also.
;	A=1 for parallel =2 for serial
;	(SP)= be pointed to as VAR count:Byte

	LD	HL,2
	ADD	HL,SP		;Get address of E on stack

;	Push 4 bytes of parameters to Print:

	PUSH	HL		;Data address
	DEC	HL		;Point to byte value 1 just pushed
	PUSH	HL

	LD	A,(msgch)	;Select which printer

	CALL	doprnt		;Takes A & 4 bytes on stack as parameters

	POP	AF		;The byte count
	OR	A		;Set flags (A value in stack was poked)
	JR	NZ,pchar2	;If =0, the call to print did 0 bytes.

	XOR	A		;Turn off offline LED
	OUT	(leds),A
	CALL	Sdelay
	LD	A,onlin		;Finished





;PROCEDURE disc_wr(addr,length,offset:Word;pre_read:Boolean;blk:block_descrip);
;
; Write up to 1 block from specified address. <offset> is offset in block.
; Errors are returned in common area <error>
;


discwr:	POP	HL		;Return address
	EX	(SP),HL		; addr of block descriptor


	CALL	fiblk		;Takes ^blk in HL, returns IY ^map entry,
				;Cf set if found, Else we have the former tail

	LD	HL,errloc 	;This user is not interested in any error
	LD	(HL),0  	; to do with previerator pressed switch to exit


; doexit:

; Turn on ROM, re-enter monitor.
;NB this code must NOT be underneath the ROM ie not in the area 0..3FFFH

doexit:	LD	A,06FH		;Value to disable CTC interrupt
	OUT	(ctc1),A	;Disable 1Hz int
	OUT	(ctc1),A	;Compulsory time constant - value irrelevant
	OUT	(ctc3),A	;Same for parallel printer
	OUT	(ctc3),A

	CALL	no_int		;No net irqs
	DI
	LD	A,01
	OUT	(sbctrl),A	;No side B irqs either
	XOR	A
	OUT	(sbctrl),A

	OUT	(paport),A	;0 is ROM on value

	JPous contents of page

	POP	HL		;Return address
	POP	BC		;Pre_read flag
	DEC	B		;Pre_read now in Z flag, carry unchanged
	POP	DE		;Offset
	POP	BC		;Length
	EX	(SP),HL		;Source addr to HL

;	Now have Z <=> pre-read, NZ=> no read, C=> already in cache
;
	IF	t.on
	mcond	wrm1
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	HL
	mess	wrmess
	LD	L,(IY+2)	;Blockno.
	LD	H,(IY+3)
	CALL	dhxout
	mess	adrmsg
	POP	HL
	CALL	dhxout
	mess	atmsg
	LD	A,(page)
	CALL	cahex
	CALL	pcrlf
	POP	HL
	POP	DE
	PO	3		;warm restart monitor






;GETMEM
;
;This routine returns the first unavailible memory location on the
; machine in DE & returns to HL

getmem:	LD	DE,0F800H
	JP	(HL)






; FUNCTION Offlin(channel:Byte):Boolean;
;
; Return hardware status of given printer (1=para,0=serial)
; Francis printers have no hardware status, so return FALSE

offlin:	POP	HL
	EX	(SP),HL		;H:=channel no.
	XOR	A		;Return FALSE
;	RET
;	Drop through to RET


;
; PROCEDURE Dolist;

; Initiate trans exit to monitor. Must flush printer buffers 1st.

fsexit:	XOR	A		;Turn both LEDs OFF
	OUT	(leds),A
	LD	D,A

	CALL	Srelea		;Wait for switch to be released

;
; TEMP - printers have no buffer, so exit
;
	JR	doexit

exit2:	LD	HL,paract	;Parallel print active if <>0
	LD	A,(HL)
	INC	HL
	OR	(HL)		;Sample serial state also
	JR	Z,doexit	;Neither printer active

	LD	A,D		;LED state
	XOR	onlin		;Flip online bit
	LD	D,A
	OUT	(leds),A
	CALL	Sdelay
	JR	NZ,exit2	;Timed out

	;Drop through if op in last byte to indicate
	LD	A,E		; if not all availible
	AND	7
	JR	Z,inidk0
	LD	B,A
	SUB	A
inidk1:	SCF
	RLA
	DJNZ	inidk1
inidk0:	LD	(HL),A

	RET




;Heap error (overflow)

heaped:	error	'Heap oflow'





;PROCEDURE cidle
;
; Use FS idle time to write out any of the cache that needs it.
; Starts from the head, which means that under heavy loading the items
; near the tail will never be written. However, these items will tend
; to get written anyway as the entries are either ush,offset:Word;VAR blk:block_descrip);
;
; Read in up to 1 block to specified address. <offset> is offset in block.
; Errors returned in common area <error>
;

discrd:	XOR	A
	LD	(errloc),A	;No error yet

	POP	HL
	EX	(SP),HL		;Get blockno. address

	CALL	fiblk		;Returns HL pointing to map entry
	JR	C,incach	;Carry => block already in cache

	LD	D,0FFH		;r/w flag =READ.
	CALL	rwblk

incach:	POP	HL		;Return addr.
	POP	DE
	POP	BC
	EX	(SP),HL
	EX	DE,HL

;	Now have: HL=source offset, BC=lened & brought back
; to the top of the cache, or get thrown out to make space for new entries.

cidle:	LD	A,(page)
	LD	E,A		;place to start
	LD	A,noblks	;Maximum no. of ents worth looking at
	LD	C,A
	LD	B,3		;Maximum no. of blocks we have time to write

idloop:	LD	IY,cacmap
	LD	D,0		;Turn E into 16-bit value
	ADD	IY,DE
	LD	A,(IY+1)	;Get needs writing flag
	OR	A
	JR	NZ,idl1		;Doesn't need it

	PUSH	BC
				;D already contains 0 (meaning write)
	CALL	rwblk

	POP	BC
	DEC	B
	RET	Z		;Written gth, DE=destination address

	IF	t.on
	mcond	rdm1
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	DE
	mess	rdmess
	LD	L,(IY+2)	;Blockno.
	LD	H,(IY+3)
	CALL	dhxout
	mess	adrmsg
	POP	HL
	CALL	dhxout
	mess	atmsg
	LD	A,(page)
	CALL	cahex
	CALL	pcrlf
	POP	HL
	POP	DE
	POP	BC
rdm1:	POP	AF
	ENDIF


	LD	A,(page)	;Open page
	OR	pagon		;Add page open bits
	LD	(copy),A
	OUT	(paport),A

	LD	A,H		;High of offset
	ADD	A,HIGH secbuf	;Add offset to where paged RAM appears
	LD	H,A
	LDIR

	RET		as many as we want to

idl1:	LD	E,(IY+0)	;pointer to next entry in chain
	DEC	C		;Counter to prevent checking more entries
	JR	NZ,idloop	;than there are cache entries

	RET




;PROCEDURE cempty
;
;Write out any part of the cache which still has things in.
; Not called very often, so implemented compactly rather than fast.

cempty:	LD	B,noblks	;Max number of blks that could possibly
mtloop:	PUSH	BC		;need writing
	CALL	cidle
	POP	BC
	DJNZ	mtloop
	RET



;PROCEDURE disc_rd(addr,lengt******

leds	EQU	035H		;LED port (active hi leds)
onlin	EQU	040H		;values to write
dkfree	EQU	080H

;***************************************************************



; PROCEDURE chksw;
;
; Routine to poll front pannel switches
;
; If switch pressed, change discs.
; <bldmap> calls <inidsk> in DKfran which flashes the change disc LED
; & waits for switch pressed - hence we must wait for switch released

chksw:	IN	A,(status)
	BIT	chdisc,A
	RET	NZ		;Not pressed
	CALL	emptyC

	CALL	Srelesed & debounce it.
; Corrupts A,B. Rest preserved
; Called from DKMAN, fsexit:, chksw:

Srelea:	LD	B,0
relea1:	IN	A,(status)
	EX	(SP),HL		;Slow instruction to increase debounce time
	EX	(SP),HL
	BIT	chdisc,A	;Test if released - if not, re-start timer
	JR	Z,srelea
	DJNZ	relea1		;Debounce switch
	RET



;
; FUNCTION Syst_sw:Boolean;
;
; Return condition of key switch.
; Francis has no key switch, so permanently in system pos.

systsw:	XOR	A
	INC	A		;Return TRUE
	RET



;
; FSexit -a		;Wait for switch to be released

	CALL	bldmap		;Re-build disc maps etc.

;	Drop through to show that we are now online again


; PROCEDURE On_line;
; Illuminate the on-line lamp!

online:	LD	A,onlin		;Disc Free OFF, online ON
	OUT	(leds),A
	RET



; syserr:
; Halt, flashing LEDs, until switch pressed to exit.

syserr:	XOR	A			;ROM (& hence LED) ON
	OUT	(paport),A
	CALL	Sdelay
	JR	Z,fsexit		;Operator forces exit.

	LD	A,romoff		;ROM & LED off
	OUT	(paport),A
	CALL	Sdelay
	JR	syser
	PUSH	DE		;and length info

	PUSH	HL		;1st parameter
	PUSH	DE		;2nd
	CALL	heap
	JR	Z,heaped	;FALSE => no room on heap

	POP	BC		;Length
	POP	HL		;Points to pointer table - address of the
				;bit of heap just got inserted here


	LD	E,(HL)		;Get address of map
	INC	HL
	LD	D,(HL)
	DEC	HL
	DEC	HL
	LD	(HL),B		;Also save length
	DEC	HL
	LD	(HL),C

	LD	H,D		;Get start
	LD	L,E
	INC	DE		;Clear map
	DEC	BC
	LD	(HL),-1

	tmess	<naloc0,BC,naloc1,HL,crlf>

	LDIR

	POP	DE		;Reset bitserr


; Sdelay:
; Delay for ~.5 sec.
; Exit immediately if switch pressed
; Called from Syserr: & Pchar: & in dkfran

; On exit,
;	NZ	for normal exit after time delay
;	Z	If exit caused by operator pressing change disc switch
;	HL=0	if normal exit

Sdelay:	LD	HL,0
del2:	IN	A,(status)
	BIT	chdisc,A	;Test for switch pressed
	RET	Z		;Return if so (switch active lo)

	DEC	HL
	LD	A,L
	OR	H
	JR	NZ,del2
	INC	A		;Return NZ for normal timeout
	RET

; Srelea:
;
; Wait for switch to be releat:	DS	3
cflush:	DS	3


stksav:	DS	2		;Save area for main program stack

wrk:	DS	1		;Used to set statid


	COMMON	/error/

errloc:	DS	1

	END
ut1
	POP	AF
	JP	rcout



;NON-routines:

notify:
remchr:
setrem:

retbyt:	RET

$memry:	DS	2		;DO NOT put this in DSEG!



	DSEG

nmivec:	DS	20		;Code inserted here

eventv:	DS	2

iojmps:

cinst:	DS	3
rcin:	DS	3
cotst:	DS	3
rcouQU	5

rdabit	EQU	1

;***************************************************************

status	EQU	34H		;System status input port

fddreq	EQU	7		;2793 DREQ, active hi
nettxe	EQU	5		;Net TX enable monitor
chdisc	EQU	2		;switch - active lo
onesct	EQU	0		;Ones counter

;***************************************************************

pprint	EQU	036H		;Printer output

;***************************************************************

ctc	EQU	038H
ctc0	EQU	ctc+0		;Head load timing
ctc1	EQU	ctc+TITLE Various FS m/c-dependant routines : mdepfran.mac
.Z80
NAME	('MDepfran')

; modifications:
; 25/11/84 New print server system
; 27/11/84 syserr: added.
;  1/12/84 FlushP: added. Pchar now flashes online LED if waiting.
;  2/12/84 Dolist: now does not advance pointer until chars have been printed.
;  8/12/84 Francis version
; 24/12/84 Now sends PCHAR output to printer specified by COMMON/msgcha/
;  3/ 1/85 Banner before PCHAR output added.


PUBLIC	fsexit, getmem, pchar, dolist, systsw, ch1		;1Hz interrupt
ctc2	EQU	ctc+2		;Baud rate (set up by ROM code)
ctc3	EQU	ctc+3		;Parallel printer ACK*


;***************************************************************

paport	EQU	034H		; Paged RAM/ROM control

;	RAM copy at copy: in COMMON /pacopy/
;	note that page is left open on exit : copy is for the use of IRQ rtns

pagon	EQU	3		;value for paged RAM open, ROM off
pagoff	EQU	1		;value for CLOSED
romoff	EQU	1		;Set if ROM off

;*********************************************************ksw, online
PUBLIC	offlin, print, syserr, flushP, chario, Sdelay, Srelea

EXT	emptyC,bldmap		;Pascal procedures - in BIGDATA.
EXT	intct3,intexb,inttbb	;Interrupt vector locations
EXT	no_int			;Disable net interrrupts

true	EQU	-1
false	EQU	0



	IF1
.PRINTX Francis version
	ENDIF



; port addresses


;***************************************************************

sio	EQU	30H
sbdata	EQU	sio+2		;Side B is serial port
sbctrl	EQU	sio+3

rda	EQU	0		;SIO status bits
tbe	EQU	2
cts	EA	;NB. hi byte already set to 0 from reading blk0
	LD	HL,bldes
	PUSH	HL
	CALL	alloc		;Allocate all 64 blocks of the FS area
	LD	A,(bldes+1)
	INC	A
	CP	66		;FS is in blocks 2..65
	JR	NZ,allfs

notfs1:	POP	AF		;Drive no.
	DEC	A		;Repeat until finished
	JP	P,inilp0

	RET

;	Error exit. iabort is entry if errloc already set.

inierr:	LD	A,1		;Duff data in blk 0
	LD	(errloc),A
iabort:	POP	HL		;old drive no(rubbish)
	RET			;(errloc) set by rwdisc


;INIONE
;Initialise one drive
;
;On entVAR ch:Char):Boolean;

inkey:	CALL	cinst
	LD	B,0		;B:=False
	JR	Z,inkXit	;No char avail
	CALL	rcin		;Return char in A
	CP	6		;Ctrl-F
	LD	B,1		;B:=True
	JR	NZ,inkXit
	CALL	srlmon
	LD	B,0		;Return no char if continued from srlmon
inkXit:	POP	HL
	POP	DE		;Address of <ch>
	LD	(DE),A
	LD	A,B		;result
	JP	(HL)		;Return


; PCHAR
;
; Print character in E
; Preserves all regs.

pchar:	PUSH	AF
	LD	A,E
	CALL	cout
	POP	AF
	RET



;IO jump table

iojtbl	EQU	$

;This jump table is copiry:
; A	Drive number
; HL	Number of blocks to allocate
;
; IY	preserved

inione:
	tmess	<almsg0,AF,almsg1,HL>

	PUSH	HL		;Save number of blocks
	EX	DE,HL		;DE:= no_of_blocks

	ADD	A,A		;Get address in mapptr
	LD	C,A		;BC:= A * 2
	LD	B,0

	SRּ	D		;Converפ Blockף tן Byteף tן allocate
	Rׂ	E
	SRL	D
	RR	E
	SRL	D
	RR	E
	INC	DE

	LD	HL,mapptr+2	;+2 => point to map address (low)
	ADD	HL,BC		;HL+:= A * 4
	ADD	HL,BC

	;Prepare to call Heap(VAR p:ptr,size:Word);

	PUSH	HL		;Save map pointed to RAM at iojmps:
; then poked if Remoted

	JP	ist423
	JP	cin423
	JP	ost423
	JP	cot423
	JP	retbyt		;Flush buffer - no buffer on 423

ioj1	EQU	$

cin:	CALL	cinst
	JR	Z,cin
	JP	rcin

coutc:	LD	A,C
cout:	PUSH	AF
cout1:	CALL	cotst
	JR	Z,cout1
	POP	AF
	JP	rcout



;NON-routines:

notify:
remchr:
setrem:

retbyt:	RET

$memry:	DS	2		;DO NOT put this in DSEG!



	DSEG

nmivec:	DS	20		;Code inserted here

eventv:	DS	2

iojmps:

cinst:	DS	3
rcin:	DS	3
cotst:	DS	3
rcou,0
	CALL	getlin
	CALL	gdeca
	JR	Z,stat2

	LD	D,stnreg
	CALL	writck		;write new statid in A to reg 8

	CALL	msage
	'New number will take effect',cr,lf
	'when file server is re-started',cr,lf,0

	RET


stat2:	CALL	msage
	'station number left unchanged',0
	RET


;transmit packet.
;
;Syntax is T<Txcb addr> <delay info>

txpkt:	CALL	hexin		;txcb addr in HL
	CALL	txlo
	PUSH	AF
	CALL	msage
	cr,lf,"&",0
	POP	AF
	JP	prhex





; I/O routines for Z80 FS





; FUNCTION Inkey(xt block
	LD	(HL),A		;Doesn't need writing
	INC	HL
	LD	(HL),A		;Blockno=&FFFF <=> not in use
	INC	HL
	LD	(HL),A
	INC	HL
	INC	C
	INC	C
	INC	C
	INC	C
	DJNZ	cilop

	XOR	A
	LD	(page),A	;Head of chain pointer

;
;	Flash change disc led until user presses switch
;
	XOR	A		;Leds initially OFF
LEDlop:	XOR	chdisc
	LD	D,A		;Save LED state
	OUT	(leds),A
	CALL	Sdelay		;Delay for 0.5s unless switch pressed
	LD	A,D
	JR	NZ,LEDlop	;Sdelay: returns Z if switch pressed.

	CALL	Srelea		;Wait for swi blk0
	PUSH	HL
	CALL	discrd

	LD	A,(errloc)	;Had error ?
	OR	A
	JR	NZ,iabort


iniok:	LD	HL,($hplm)	;Where we put the block
	LD	BC,sjoff	;Offset of SJ string
	ADD	HL,BC
	LD	DE,sjmess	;Check it's an SJ disk
	LD	BC,23*256+1	;B:= len SJstring , C:= error not SJ
csjlop:	LD	A,(DE)
	CP	(HL)
	JR	NZ,inierr
	INC	HL
	INC	DE
	DJNZ	csjlop

	LD	IY,($hplm)
	LD	L,(IY+blkoff)	;HL:= number of blocks on disk
	LD	H,(IY+blkoff+1)


	POP	AF		;drive no. 0..3
	PUSH	AF
	PUSH	HL
	CALL	inione		;Do map fotch to be released
;
; Investigate no. of drives & set up translation table
;

	LD	HL,drvtab
	LD	BC,noofdr*256	;C:=0 (count of actual drvs), B:=noofdr
	LD	D,C		;D:=0 (physical drive count)
drvcnt:	LD	E,D
	CALL	inidrv
	JR	Z,nodrv		;Z means drive not working/no disc
	LD	(HL),D		;Insert table entry
	INC	HL		;Pointer into translation table
	INC	C		;Logical drive number
nodrv:	INC	D		;Real drive number
	DJNZ	drvcnt

	LD	A,C		;No. of drives available
	DEC	A		;Convert to max drive no.
	JP	M,fsexr that drive

	POP	DE		;Disc size
	LD	A,(IY+dsflag)
	OR	A		;Test for copy of FS on this disc
	JR	NZ,notfs

	LD	HL,-64		;Subtract 64 from disc size
	ADD	HL,DE
	EX	DE,HL

notfs:	POP	AF		;Get disc no. DE=available disc size
	PUSH	AF

	ADD	A,A		;Drive *2
	LD	B,0
	LD	C,A
	LD	HL,dsksiz	;Put into disk size table (pascal's FREE_BL)
	ADD	HL,BC
	LD	(HL),E
	INC	HL
	LD	(HL),D

	LD	A,(IY+dsflag)	;Test for FS disc again
	OR	A
	JR	NZ,notfs1

	LD	A,2		;First block of FS area
allfs:	LD	(bldes+1),it	;Exit if no drives

	POP	HL		;Return address
	EX	(SP),HL		;Address of maxdrv parameter (Pascal)

	LD	(HL),A		;Return result of this procedure call

; this loop occurs once for each disk

inilp0:	PUSH	AF		;drive
	LD	(bldes),A	;Put drive in block descriptor

;	Set up parameters on stack for <discrd>

	LD	HL,($hplm)	;Read this block above the system heap
	PUSH	HL
	LD	HL,0400H	;Length
	PUSH	HL
	LD	H,0		;Offset
	PUSH	HL
	LD	(bldes+1),HL	;Block 0
	LD	HL,bldes	;Block descriptor set up to be#}¾  ‎יֻFָ>E?8#ב>EֽB1>ֹJ8
ֻ^ְZ8
>FבֳB1End-of-fileNo reset/rewriteNo rewrite—ֻ|(ֽ±9>€‎בׁד‎דֵBKֻ|(ְֶֽ±9ׁוץֵ‎דֱx±² ³´8‏ ‎וֱסֻ,ֻֻֻ
ֽ,9סוב‎וֱ±9בֹׁׁ>JֽB1!   ֹ—ֻ|(ֽ±9>€‎בׁד‎דֵBKֻ|(ְֶֽ±9ׁץֵױֵ‎ו|µ(ֱx±ֲ9ֱDMֽ:	ֱׁx±(ֽ:xז€´µֲ9`iֱׁוֽ:ׁס·±9ֹׁׁׁׁ>OֽB1!   ֹו|µ(> !  >‎דבו‎))דםjדםj0#ד·םRדםBע`9דדםJ‎#= סֹ‎בד	DMׁבםZך־9‎י‎בד·םBDMׁבםRך־9‎יOGogֹDMֻםbֹ‎בכבוֻםbדוכ‎י‎ב  כדוכ‎יֻ|ָכ!  ·םBDM!  םRאדֵו>OֽB1בֱדֹ‎ומְְ,ְ$אהyײOx G  םRךְ9±µ´ֹ‎בד·םBׁבץםRׁך: H ֵֽ¿>ב^#Vbkt#u#F6 #ױ‎ב*ֱB‎u‎tםSֱBֱ‎q‎p‎6‎6€ֱx±(‎q‎p‎ֻֶ! ‎u‎t6 ! כ!f> ם°‎וב>ֹn>×>³>¾>!זB~·(5*חB~w#"חBֹוB
ֽ0!חB"חB!וBF#~¸(ױ4 _#66
ֽ×>ִ^ֽ0ֹֻVָ!זB6 ֹֹבֱדם[½Bs#rֽ1ֹ                                                                                                                                                                                                                                                                                                                   ֻ»ױס‎י>@ת:·‎י‎בכ`iֱ·םBֱץכםBׁך:(‎יוֵׁכ·םRו·םBDMלS:|בֹכ`i·םRT]·םBDMכֹ|צנכ!  ·םRֹ‎בׁZ ֻ{(ױ‎יכ!  yKֻ?0ֻ#ֻ· פx·ָQ ֻ?0ֻ"· צֹ!  x·(·ֻA(ֻֻֻסGֹ·ֻA(ֻֻֻעEl& ֹבד@oבד ·ע־:ֻשםDoֻ|(yמ€O—”g}·(*|·ָ}ײ ֻ<—ֻ$½8•$צ|ֻqְֻy ·נ>OםDֹ>JֽB1>ֹבד oבדO·ע";םDoy¬Oֻ|(—”g}·(|·(—·ֻE(„ֻץgֻyָ/g}/o#ֹ!  ֹ‎בסֱׁב‎וױדױ6  ֻ|(4 #6 -=P<כ!  ·םBDM!  םRת?<ץ·ֻx |µ(@ֵ ;ֽש;ֵ בץֽש;ֵ€–˜ ֽש;ֵ@B ֽש;ֵ † ֽש;ֵ'  ֽש;`i`i'ֽ<טֽ<d ֽ<
 ֽ<ׁ>0…#w ב4 בֹ‎ב>0ד·ves

inidsk:	CALL	inilow		;To turn off motors etc.

	LD	HL,mapptr	;Init bit map pointers
	LD	B,noofdr*4
inids1:	LD	(HL),-1
	INC	HL
	DJNZ	inids1



; Initialise cache map/chain & set all blocks free.
;
; Francis version : cache size is fixed at 64K
;

	LD	B,noblks	;Loop counter
	LD	C,4		;Pageno. of NEXT block
	LD	HL,cacmap	;Points to the block being initialised
	LD	A,0FFH		;Value for NOT(needs writing) & not in use

cilop:	LD	(HL),C		;Link it to the next block

	INC	HL		;Proceed to neםBדםRת<7<נד	דםZֱ‎ב>0·םRת'<7<פ·0ׁ#w ד4 ד(ױ‎י6 *6*ב4 >Oׁ>TבֽB1ֹ>@תa<·ֹ>ָ=ֹ>ְ=ֹ>ר=ֹ>נ=ֹ·נםDֹ‎ווׁב~#וכ_Wֳץ<‎ווׁד~#דוogׁq#p#s#r#כֹ‎בֱׁבם°‎יבֱ^#{· Wכ9ש‎ווֵ!„ 9כ^# כ9וױ*¿B9״>Sױ ֽB1כב‎בבשכ‎יב^#V#וכN#F#^#V#כֹד^#V#דככבדq#p#s#r#כֹ‎בׁדֵBK‎י0	ך6=ת.=¹/=yo& D)!0צנ·םB0·םBךe=תP=·םRS=!  )BKׁ‎בױ^#Vב		כי0יבֹב‎ב¾#(##ר^#V#כיכב‎ב{¾# z¾# ך##ם¡ך=בױ‎ו>CֽB1ֹׁ!  ’BױוBױוֶֽ=ו‎ב‎6ֶֽ=ו‎ב‎6¯2ױBֹבֱד^#V+וz·((*ֱBו‎ב|µ(םR(‎n‎fםבו}‎¾ 
|‎¾ כׁ¯ֹבֵווו£(ֻכ}ז)))))o¯€‎	8םBֻ(ֻׂ.gֱֻ<0ֻד€( >2Bױוֵ:§B«ז(
>׃8>׃85{׃72§Bף:.@· 5>€2.@¼(<ּ/|׃>ֽ#/ֻ ת}׃ֽ#@ֽץֵדֵzֻj!נ.(!ר.@ ם°ֽ#/ץֻj(! +|µ ֽֽ*›Bwס! @6 ז(6ַ!B5ץֻ- ·-ֽ€1סץֽ$1ס>ֱב>
2.@סֱבָׁ>׃ֳ5.ם¢םEם£םEוz !BW"›B~׃בֹ>׀ֽ#/ֻW(>Xֽ#/>׃ֽ//ֻG תֵֹ‏ֱֹוֵ¯C7‎_׃72§B!.@ף~6€ֻ'o& 5>׀ֽ#/+}´(5דד ֻ עףֻO(תֻO ת!  #ֻO(ש|‏g 0Kֻכ!—B{/¦±w¯<!.@6
ֱבֹבדו\ֽ /ֽ6/(^ֽ/!¡B! €"¡B6ֻk(6 666d6	6ֽ¨1ו&  €פ|בוֽֽ2ֻ£ֽ0.ֻדֽ0.$|‏P(>Xֽ#B1‎בֽ4‎F‎ד‎י! 9 N#T]	ֹ‎בֽ4ױF#כ& hד‎יז<G¯7‎ֹ‎ב ‎N ‎#
ב N#ו‎ב‎	כ&y/o9שq#כם°‎וֳ׳<‎בבײ‎ב~# O· ץ3‎י|]ֻ־ }ָ}ז€´}ָ|·}ָ
x  םZ`iָדץֵו>BֽB1בֱסדֹ|µ`iָי¸ך¸4ת4Wy÷zך½4נ״ת®4׃ר׀¸8ֽGy¸x׀ֶו·םBבךא4ת4כ·םRכך½4נ°תױ4«ו·םBב8₪כ·םRכ׀‎בוֵוֵ‎^‎Vױ‎^ ‎Vױ‎^‎Vױ‎^‎Vױֽנ9ת'5ֱבֽנ9ֱבנֳ4ֱׁׁׁׁבֳ4כ*½B·םR8
*ל+םR0כֹכדו>PֽB1בדֹׁץוֵױ>OֽB1ֱׁבסױֹ ·םZא ·םRאדו>OֽB1בדֹ*B¯*’B¯*B>*’B>ׁםSֳBױוץ:ױB·(‏(F !״B	כ!‎ם¸<2ױBסב"ײB2״Bֹֽן7"ײBבֹ:״B‏ּ¯7:״B‏ּֽ7!ױB5ָ!BײB ם°ֹ>Fת5ֽB1Read/w/ב¯<בבֹבׁסֱדכ_¯’Wֳס-בד\ֽ6/(\ !  ֽס-·ְ!@-¾ 	#רֹ>>2 @ֹבסוֻ'ֻ'צ׃4ֹ1 וֽ9! "ֳB!€ 9"²B!0"ַB"ֵB"÷B*ל"½B  ֽ1!  "×B!€ "¨B"¬B!¨B"®B!¬B"°B!  "B"’B"ֱB"´B"¸Bֽ =‎ו‎*’B!0‎u‎t	‎*B!מ0‎u‎t‎ב¯2¼B! "¶Bֹ‎וױ‎*’B‎^ֲֽׁ‎בֹי‎ו‎*B‎6 ‎בֹyֽ$1ֳ  *½B	8"½B 	8|/g}/o"¿B9״ׁ>HֽB1ץֽ-1סזֶ'־@'_ֲֳבסוֽB1ֹֻ0כ^#ֲֽש’1ֽ€1_ֲֽ›1ֽ€1ׁבוױyז(*ֳB|ֽ$1}ֽ$1ֲֽ
ֲֽֳ  יץױוכ>$^»ֲִ# רבׁסֹ
Error $ at address $n fֵ(ֻF(Pֽ¾2ֱֵֻF(ץ¯ָֽ2ס(>צָֽ26#ֱֵֻF(2ֽ¾2ֱֵֻF(ץ¯ָֽ2ס(>rite nesting too deepבס·(ֱֵ>ץו>WֽB1טבֱֵ>בסֱֵ· yGֽ{6ו! 9~·(	#~ֽl6ר	#ׁשכיבסדNG~·ָֽ{6#~ֽl6שֹוֵ‎*ײB‎wֽ7ֱבֹy¸׀> ֽl6ץ וב^#Vכי*ײBודֽן7ֽ¸6ֽ8ֻזבֹ~ז%8ֻfָ~ֻW!8ֻgָֻv Mnfֽ6ֻ¦ֻFָ~‏(*‏
(ֻ‏ְwֻN(~‏(ִ6
6 ֻ־ֹֻצֻN(םֻ¶ֻֶֹ*ײBודֽן7ֽ,8nf	ֽ6ֻבֹ*Bודֽן7ֽ©6~זבֹ*Bודֽן7ֽ©6ֻFֲ8~זבֹ*’Bודֽן7ֽ,86ֽ†66ֽ†6ֻ־בֹ*ײBודֽן7ֽ©6nfבֹ*ײBודֽ¸6ֽ8ֻN ֳֽ6עֻזבֹ*ײBודֽ,86ֽ†66
ֽ†6ֻ־בֹ‎בב"ֳBדוד|·((¾ %ץָֽ26‏#ֱx‏0ו¯w#w#xֻ^(=w#~w#6ק#ֵֻF(ֽ¾2ֱֵֻF(ץ¯ָֽ2ס(>ץָֽ26#ֱֵ>€F‎ Gֻ8ֻוr#x± ש6ק#Fֽ¾2ֱx¾ֲל1ו~ֻW !5ֻO(!XֻG(	)nfֱֵ·םBN F	 	MDׁbk+ם°בׁ·םRכֹֻF>(>Nw#ֹFwֹבס·(ֱדץוֵֹBױ>ץֽR;ס!ֹBF¸0xוץֽY6ֹ>ץו>WֽB1׀ױֵ! 9NA  #~· רֹׁׁכ)))8#תׁ·םR8!! 9 	~· +ר`i#)))+0כב·םR8ֹׁ>BZ3ֽB1ֹSet bounds errorֽ4#~#_—W ֽ4#^# ֽ4^#V#ֽ4^#V#~#¶#  ו{ֽ*4ֻ:ֻת& i+·םR8	! 9¦בב¯‎בש‎יֽ3‎בױ^#V#דx‘0H¯ ם°·(כG6 #בש‎י‎בֽ4דF#דx¹0 yG¯+¶‎ד·(‎ו>VֽP5+u…t†!  uƒt„6~·ֽc<ץ~¾‹ֽc<Gס 0Dֽ‘5ֽS$Insert source disc & press spaceֽ[4 > ץֽ66ֽֽ5!”Bוֽ¨0צ:”B‏  ן~ץֽG0>ץ*•Bו~ץ~O nƒf„·םJP5וֽ	0~<ּP5wn…f†|µּP5+u…t†~‏@ֽc<ץn…f†|µֽc<Gס°0¢6‰ ~¾‹ Iֽ‘5ֽ%Insert destination disc & press spaceֽ[4%> ץֽ66ֽֽ5!”Bוֽ¨0צ:”B‏  ן~‚ֳׂ%ֽ‘5ֽ?%Formatting ...ֽ[4> ץֽ66ֽֽ5~‹ץֽ›/מ0Eֽ‘5!®ֽ44> ץֽ66ֽֽ5ֽ‘5ֽ‡%Press space when readyֽ[4> ץֽ66ֽֽ5ִֽ‏  ש¯ֽ‘5ֽ²%Format completeֽ[4> ץֽ66ֽֽ56‚ ~‰ץֽG0> ץ*•Bו~‹ץ~‰O nƒf„·םJP5וֽ	0~‰<ּP5w‰¾ ֹ6 @@כבs#rn„f… ו*)@כבs#r!  p‚uˆt‰n„f…וnˆf‰ֻ|ִ4ֽn-)ׁוnf‹כבs#rnˆf‰#5‚ֲ!*ֽ‘5ֽֽ5> ץ*•Bו~ץ!  וֽ	0>ץֽG0> ץ*•Bו~ץ! וֽ	0> ץֽG0~ץ*•Bb ^#Vכוּֽֳ·*ֽ‘5!®ֽ44> ץֽ66ֽֽ5ֽ‘5ֽֽ5ֽ„5ֽ*Format another disc ? ֽ[4> ץֽ66ֽֽ5ֽדמׂ4(ֳה<!ר*ֳT0ֽמֽ׃-! "•B!˜B6 ֽ‘5ֽֽ5ֽ‘5ֽֽ5ֽ‰-ֽ‘5ֽ6+Disc Preparation Programֽ[4> ץֽ66ֽֽ5ֽ‘5ֽֽ5ֽ‘5ֽr+A - Alter individual space accountsֽ[4#> ץֽ66ֽֽ5ֽ‘5ֽ¡+B - Boot file server programֽ[4> ץֽ66ֽֽ5ֽ‘5ַֽ+C - Copy whole discֽ[4> ץֽ66ֽֽ5ֽ‘5ֽם+F - Format new discֽ[4> ץֽ66ֽֽ5ֽ‘5ֽ, nƒf„·םJP5uƒt„n…f†|µֲ$ֽ‘5ֽA&Copy complete - verifying ...ֽ[4> ץֽ66ֽֽ5~‹ץn‡fˆוּֽֳה<ֽµ<פֽ‘5ֽ„&           FORMAT NEW DISCֽ[4> ץֽ66ֽֽ5ֽ‘5ֽֽ5ֽ‘5ֽֽ5ֽ„5ַֽ&Format disc in which drive (0..3) ? ֽ[4$> ץֽ66ֽֽ5!  ו! וֽ^ֽ€4wֽ‘5ֽ'How much disc space for each account ?ֽ[4&> ץֽ66ֽֽ5ֽ‘5ֽJ'(Try 20K - any account may be adjustedֽ[4&> ץֽ66ֽֽ5ֽ„5ֽv' later). In units of 1K :ֽ[4> ץֽ66ֽֽ5! ו!וֽ^ut‹>p…wץֽG0!   qƒp„uˆt‰*•Bוnˆf‰ֻ|ִ4ֽe-ׁ6 nˆf‰#NƒF„x±ֲ¨'~=5…ֲ›'>ץֽG0*•Bוֵֽ\-ֽ¼3 >P - clear Password fileֽ[4> ץֽ66ֽֽ5ֽ‘5ֽ9,R - Rename discֽ[4> ץֽ66ֽֽ5ֽ‘5ֽn,S - Set file server station numberֽ[4"> ץֽ66ֽֽ5ֽ‘5ֽֽ5ֽ„5ֽ,Command :ֽ[4	> ץֽ66ֽֽ5ִֽֽƒ-2”Bֽ‘5:”Bץ>ץֽ6ֽֽ5:”Bֽ-ֽֳI-!˜B6ֳI-ֽ}!ֳI-ֽ_&ֳI-ֽ'ֳI-ֽנֳI-ֽLֳI-ֽ׀ֳI-ֽ‘5ֽ-Illegal optionֽ[4> ץֽ66ֽֽ5ֳI-ֽj=A¼,Bֲ,C,F׀,Mײ,P,Rג,Sט,a¼,bֲ,c,f׀,mײ,p,rג,sט,מ,:˜Bׂ	+ֽ¶ֳ|1 ֳ§4   ֳ3  ֳ4  ֳ4
ֳ§4 ְֳ4 ְֳ4-ֳ€1SJ Research File Server ver 0.13/FDFS
$
Fatal disc error $ Error $¯׃72§B2.@6>׃8>׃8!B6#ֵֹֽ /¯C7‎_:—Bp…w*•Bו~·4ֽV-og@ ֽi:ׁ ו~בw~<5…ֲ(> ץֽG0ֽֽ‘5ֽP(Formatting...ֽ[4> ץֽ66ֽֽ5~ץֽ›/ׂ₪*ֽ‘5ֽ(Format complete - verifying...ֽ[4> ץֽ66ֽֽ5*•Bu„t…a 6ֽ„5ֽ¸(Density = ֽ[4
> ץֽ66ֽֽ5~ץ!—Bֽ44ֽv3)n„f…b 6 #6ֽ„5ֽע(Quad - ֽ[4> ץֽ66ֽֽ5ֳ-)n„f…b 6 #6ֽ„5ֽ )Double - ֽ[4	> ץֽ66ֽֽ5ֽ‘5n„f…b ^#Vכ  ױו>ץֽױ2ֽR)K discֽ[4> ץֽ66ֽֽ5n„f…#6$n„f…##6n„f… 6 n„f… 6n„f…  6#6 n„f…@ וֽ¾)SJ Research File Serverבׁ ם°n„f… וֽ)%Passwordsבׁ
 ם°n„f…— 6ֽn„f…˜ ו*)of transmitted text
	RET

verblk:	DEFW	0			;Std. Tx Header

sjmess:	DEFM	'SJ Research File Server ver '
	DEFW	verhi,verlo

	DEFM	'/FDFS'


; NB this label must be defined before any references to the MESS
; macro is made.
; NB2 also forms part of the above string.

crlf:	DEFM	cr,lf,'$'


	IF	t.on

;dhxout
;Print hex of HL

dhxout:	LD	A,H
	CALL	cahex
	LD	A,L
				;DROP THROUGH
;cahex
;Print hex of A
;
;On entry:
; A	number to be printed

	JP	cahex		;Now lives in h2lib or some tion can also be used to addֽ[4#> ץֽ66ֽֽ5ֽ‘5ֽR a password file to a disc used withֽ[4#> ץֽ66ֽֽ5ֽ‘5ֽ‰ earlier versions of the file server.ֽ[4$> ץֽ66ֽֽ5ֽ‘5ֽֽ5ֽ„5ֽ´ Clear the disc in ֽ[4> ץֽ66ֽֽ5!†וׁוֽ©*•Buƒt„>€€p‚w…nƒf„וn…& ׁ6 ~…<5‚ֲ nƒf„ וֽ!%Passwordsבׁ
 ם°ֽnƒf„˜ ו*)@כבs#rnƒf„— 6ֽ‘5ֽֽ5ֽ‘5ֽ[!Password file clearedֽ[4> ץֽ66ֽֽ5> ץ*•Bו~†ץ!  וֽ	0ֳה<ֽµ<ץֽ‘5ֽ¢!           WHOLE DISC COPYֽ[4> ץֽ66ֽֽ5ֽ‘5ֽֽ5ֽ‘5ֽב!This option makes an identical copy ofֽ[4&> ץֽ66ֽֽ5ֽ‘5ֽ"a whole discsuch place
;
; Print a crlf!
pcrlf:	LD	DE,crlf
	JP	pmess


wrmess:	DEFM	'Wrt blk $'
rdmess:	DEFM	'Rd blk $'
adrmsg:	DEFM	' addr $'
atmsg:	DEFM	' @ $'
almsg0:	DEFM	'Init map $'
almsg1:	DEFM	' - length $'
naloc0:	DEFM	cr,lf,'Clear $'
naloc1:	DEFM	' bytes from $'
;alblk0:	DEFM	'Allocate block $'
alblk1:	DEFM	' from map $'
frblk0:	DEFM	'Free block $'

fatmsg:	DEFM	0DH,0AH,'Fatal disc error $'
errmsg:	DEFM	' Error $'

	ENDIF






;PROCEDURE inilow
;
; Set up hardware ready for use. Any previous contents ofֽ[4&> ץֽ66ֽֽ5ֽ‘5ֽR"the new disc are destroyed, includingֽ[4%> ץֽ66ֽֽ5ֽ‘5ֽˆ"disc name, account information etc.ֽ[4#> ץֽ66ֽֽ5ֽ‘5ֽ½"The new disc need not have alreadyֽ[4"> ץֽ66ֽֽ5ֽ‘5ֽא" been formatted.ֽ[4> ץֽ66ֽֽ5ֽ‘5ֽֽ5ֽ„5ֽ#Format new disc ? ֽ[4> ץֽ66ֽֽ5ֽדֽ}-w‚0Jֽ„5ֽN#Format disc in which drive (0..3) ? ֽ[4$> ץֽ66ֽֽ5!  ו! וֽ^ֽ€4w‹Nֽ„5ֽ†#Overwrite disc in ֽ[4> ץֽ66ֽֽ5!‹וׁוֽ©ֽ„5ֽ©#Ok ? ֽ[4> ץֽ66ֽֽ5ֽד0²ֽ„5ֽװ#Read from disc in ֽ[4> ץֽ66ֽֽ5!וׁוֽ©*•Bb ^#Vכu‡tˆ|µּ.

inilow:	XOR	A
	OUT	(dskctl),A	;Deselect all drives
	LD	(dkctlm),A	;Set up RAM copy
	LD	(ticloc),A	;Indicate drives stopped so time is allowed
				;to restart them later
	IN	A,(mstop)	;Stop drive motors

	LD	HL,trkno
	LD	B,4
zaptab:	LD	(HL),0FFH
	INC	HL
	DJNZ	zaptab
	RET



;PROCEDURE inidsk (VAR max_drive: BYTE);
;
;This procedure allocates heap for the map for all drives
;& finds out how many drives there are.
;External drive numbers always run 0..n and are translated into real dri