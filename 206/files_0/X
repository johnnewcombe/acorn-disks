10022\10023.termloop10024 JSR conin10025 JSR oswrch10026 JMP termloop10027\10028\10029\10030.init10031 LDA #010032 STA param_blk10033 STA rx_seq10034 STA max_ptr \ No chars in buffer at all.10035 STA rx_waiting10036 JSR transmit_proc \ Send log-on request.10037 LDA#110038 STA param_blk10039 JSR open_rx10040RTS10041\10042\10043\10044.open_rx10045 LDA#0 \ Reason code for open10046 STA raw_rxcb10047 LDX# (raw_rxcb AND &FF)10048 LDY# (raw_rxcb DIV &100)10049 LDA #&1110050 JMP osword \ JSR then RTS10051\10052\10053\10054\10055.rx_poll10056 LDX raw_rxcb \ Get the rxcb number allocated by th OS10057 LDA #&3310058 JSR osbyte10059 TXA10060 BPL to_rts \ Top bit unset <=> no reception.10061 LDA raw_rxcb10062 STA result_rxcb \ Transfer rxcb no. prior to reading it.10063 LDX #(result_rxcb AND &FF)10064 LDY #(result_rxcb DIV &100)10065 LDA #&1110066 JSR osword10067\10068 LDA result_rxcb+1 \ Control code = ie sequence no.10069 AND #110070 EOR rx_seq10071 BNE open_rx \ no good - open another & exit.10072\10073 LDA rx_seq10074 EOR #110075 STA rx_seq \ Update sequence no.10076\10077 SEC10078 LDA rx_actual_end10079 SBC #(rx_buff AND &FF)10080 STA max_ptr10081 LDA #010082 STA rx_ptr10083 STA rx_waiting \ Can't expect any more to arrive without some action10084 JMP open_rx \ Open another in preparation (JSR/RTS)10085\10086\10087\10088.const10089\ Status call - returns Z set if no chars available10090 LDA rx_ptr10091 CMP max_ptr10092 BNE to_rts \ Chars definitely available10093 LDA rx_waiting10094 BNE maybe_some \ Some should be arriving soon10095 JSR transmit_proc \ None requested, so request some.10096 LDY #110097 STY rx_waiting10098 DEY \ Set Z flag10099 RTS10100\10101.maybe_some10102 JSR rx_poll10103 LDA rx_ptr10104 CMP max_ptr10105 RTS \ Result in Z flag.10106\10107\10108\10109.conin10110 LDA #010111 STA rx_retry \ Retry polling counter10112.conin210113 JSR const \ Test for chars available10114 BEQ none_yet10115 LDY rx_ptr10116 LDA rx_buff,Y10117 INY10118 STY rx_ptr10119.to_rts10120 RTS10121\10122.none_yet10123 INC rx_retry10124 BNE rx_wait10125 JSR transmit_proc \ Try again in case 1st poll got lost somehow.10126.rx_wait10127 LDX# 0 \ Delay loop10128.l INX10129 BNE l10130 BEQ conin210131\10132\10133\10134\10135\10136.transmit_proc10137 LDY #10 \ Retry counter10138 STY rx_retry10139.retry_proc10140 LDX# (txproc AND &FF)10141 LDY# (txproc DIV &100)10142 LDA# &10 \ Transmit10143 JSR osword10144\10145.poll_tx10146 LDA #&32 \ Poll txcb10147 JSR osbyte10148 TXA \ Result10149 BMI poll_tx \ Not finished transmitting yet10150 AND# &40 \ Test for success10151 BEQ to_rts10152 DEC rx_retry \ Retry reqd - have we had too many ?10153 BNE retry_proc10154RTS10155\10156\10157\10158\10159.txproc10160 EQUB &84    \ ctrl code for remote proc call10161 EQUB 010162.source_stn10163 EQUW 010164 EQUD param_blk \ Buffer start10165 EQUD param_blk_end10166 EQUW &FFFF \ Procedure number10167\10168.param_blk10169 EQUB 010170.param_blk_end10171\10172.raw_rxcb10173 EQUB 0  \ Reason code or rxcb number10174 EQUB &7F \ Flag10175 EQUB &A0 \ Port10176.rx_stn10177 EQUW 010178 EQUD rx_buff10179 EQUD rx_buff_end10180\10181.result_rxcb10182 EQUB 010183 EQUW 010184 EQUW 010185 EQUD 010186.rx_actual_end10187 EQUD 010188\10189\10190.rx_buff10191 EQUS STRING$(64,"w")10192.rx_buff_end10193\10194.rx_seq10195 EQUB 010196\10197.rx_waiting10198 EQUB 0   \ =0 => poll req'd, <>0 => waiting for data10199\10200.rx_ptr10201 EQUB 0 \ Index into rx_buff10202\10203.max_ptr10204 EQUB 0 \ Value of rx_ptr pointing one beyond last valid byte.10205\10206.rx_retry10207 EQUB 0 \ Count down while waiting for chars - transmit another poll at 010208\10209\