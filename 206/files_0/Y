AUTOREM 'Fast Remote'REM A.R.Gordon 27/6/84  osword=&FFF1 osbyte=&FFF4 osrdch=&FFE0 osascii=&FFE3 oswrch=&FFEE oscli=&FFF7  wrchvec=&20E rdchvec=&210 eventvec=&220  buff_size=64  DIM Q% 1000 FOR Z=4 TO 7 STEP 3 IF Z=7 THEN TRACE ON P%=Q% O%=Q% [OPT Z.init LDA eventvec STA oldvec LDA eventvec+1 STA oldvec+1 LDA# (event_handler AND &FF)  \ Insert new vector SEI STA eventvec LDA# (event_handler DIV &100) STA eventvec+1 CLI\ LDX#1 STX waiting_flag \ Receiving stn is NOT waiting for data DEX STX buff_ptr     \ No chars in buffer (points to free slot)\ LDA #14   \ *FX 14,8 - enable event LDX # 8 JMP osbyte \ JSR/RTS.\\.init LDA #0 STA param_blk STA rx_seq STA max_ptr \ No chars in buffer at all. STA rx_waiting JSR transmit_proc \ Send log-on request. LDA#1 STA param_blk JSR open_rxRTS\\\\\ Enter here to send a character across the link. Char in A ..conout PHP PHA \ Preserve all regs so that this can replace oswrch TXA PHA TYA PHA TSX LDA &103,X \ Restore A.buff_full LDY buff_ptr CPY #buff_size BEQ buff_full \ Event routine should empty it. SEI \ Start critical region LDY buff_ptr \ Might have changed under event rtn STA buffer,Y INY LDA waiting_flag BEQ transmit_somthing \ NB current ptr only in Y, so event rtn does not STY buff_ptr \ transmit at the same time if a spurious poll arrives. JMP exit\\\\.event_handler PHP CMP #8 \ Econet event number BNE to_oldvec CPX #&FF BNE to_oldvec  \ We use procedure number &FFFF CPY #&FF BEQ our_event.to_oldvec PLP JMP (oldvec)\\ REMOTE PROCEDURE CALL EVENT - PROCEDURE &FFFF\\ This call takes one argument :\\ ARG=&00 - Log-on request. Possible further arguments for log-on text.\\ ARG=&01 - Request for data.\ Reply is sent on port &A0. Sequence no. is in LSB of control code.\ If no data is available, <waiting_flag> is zeroed, and the first byte\ of data to become available is sent in foreground.\\\.our_event PHA TXA PHA TYA PHA LDA#&12 \ Read the procedure arguments LDX# (block_buffer AND &FF) LDY# (block_buffer DIV &100) JSR osword\ LDA block_buffer+2 \ Reason code BEQ log_on LDA block_buffer CMP client_stn BNE exit LDA block_buffer+1 CMP client_stn+1 BNE exit\ LDY buff_ptr STY waiting_flag \ Set zero if client is waiting, nonzero otherwise. BEQ exit \ Can't send anything if no chars LDA#0 \ Zero buff_ptr to prevent this code being re-entered. STA buff_ptr \ Needs zeroing anyway as we are about to empty it.\\ Enter here from foreground code also - on entry, Y contains <buff_ptr>\.transmit_somthing TYA CLC ADC #(buffer AND &FF) STA buff_end_loc LDA #(buffer DIV &100) ADC #0 STA buff_end_loc+1\ LDY #10 \ Retry counter STY tx_retry.retry LDX# (txcb AND &FF) LDY# (txcb DIV &100) LDA# &10 \ Transmit JSR osword\.tx_poll LDA #&32 \ Poll txcb JSR osbyte TXA \ Result BMI tx_poll \ Not finished transmitting yet AND# &40 \ Test for success BEQ finish_event DEC tx_retry \ Retry reqd - have we had too many ? BNE retry.finish_event LDY#0 \ Buffer is empty as a result of this call STY buff_ptr INY STY waiting_flag LDA txcb \ Ctrl code - contain sequence bit EOR #1   \ increment it. STA txcb.exit PLA TAY PLA TAX PLA PLPRTS\\.log_on LDA block_buffer \ Just copy across station ID for now  STA client_stn   \ could check for passwd etc. LDA block_buffer+1 STA client_stn+1 LDA #&80 \ Clear sequence no. STA txcb LDA#0 STA buff_ptr JMP exit\\\\.open_rx LDA#0 \ Reason code for open STA raw_rxcb LDX# (raw_rxcb AND &FF) LDY# (raw_rxcb DIV &100) LDA #&11 JMP osword \ JSR then RTS\\\\.rx_poll LDX raw_rxcb \ Get the rxcb number allocated by th OS LDA #&33 JSR osbyte TXA BPL to_rts \ Top bit unset <=> no reception. LDA raw_rxcb STA result_rxcb \ Transfer rxcb no. prior to reading it. LDX #(result_rxcb AND &FF) LDY #(result_rxcb DIV &100) LDA #&11 JSR osword\ LDA result_rxcb+1 \ Control code = ie sequence no. AND #1 EOR rx_seq BNE open_rx \ no good - open another & exit.\ LDA rx_seq EOR #1 STA rx_seq \ Update sequence no.\ SEC LDA rx_actual_end SBC #(rx_buff AND &FF) STA max_ptr LDA #0 STA rx_ptr STA rx_waiting \ Can't expect any more to arrive without some action JMP open_rx \ Open another in preparation (JSR/RTS)\\\.const\ Status call - returns Z set if no chars available LDA rx_ptr CMP max_ptr BNE to_rts \ Chars definitely available LDA rx_waiting BNE maybe_some \ Some should be arriving soon JSR transmit_proc \ None requested, so request some. LDY #1 STY rx_waiting DEY \ Set Z flag RTS\.maybe_some JSR rx_poll LDA rx_ptr CMP max_ptr RTS \ Result in Z flag.\\\.conin LDA #0 STA rx_retry \ Retry polling counter.conin2 JSR const \ Test for chars available BEQ none_yet LDY rx_ptr LDA rx_buff,Y INY STY rx_ptr.to_rts RTS\.none_yet INC rx_retry BNE rx_wait JSR transmit_proc \ Try again in case 1st poll got lost somehow..rx_wait LDX# 0 \ Delay loop.l INX BNE l BEQ conin2\\\\\.transmit_proc LDY #10 \ Retry counter STY rx_retry.retry_proc LDX# (txproc AND &FF) LDY# (txproc DIV &100) LDA# &10 \ Transmit JSR osword\.poll_tx LDA #&32 \ Poll txcb JSR osbyte TXA \ Result BMI poll_tx \ Not finished transmitting yet AND# &40 \ Test for success BEQ to_rts DEC rx_retry \ Retry reqd - have we had too many ? BNE retry_procRTS\\\\\\ Variable data areas start here.\ Not ROMable!\\ Data for transmit first.\\.txcb EQUB &80    \ ctrl code - sequence no. in here also. EQUB &A0    \ Port no..client_stn EQUW 0 EQUD buffer \ Buffer start.buff_end_loc EQUD 0\.block_buffer EQUS STRING$(4,"x")  \ Buffer for reading routine args\.buffer EQUS STRING$(buff_size,"y")  \ Tx data buffer + overflow rtn args\ rtn args can only overflow on log-on call, where txdata is scrapped.\.tx_retry EQUB 0\.waiting_flag EQUB 0 \ =0 if the client stn expects us to send some data\.buff_ptr EQUB 0\.oldvec EQUW 0 \ Old event vector saved here\\\\ Receive data areas here (inc Txcb for polling)\\\.txproc EQUB &84    \ ctrl code for remote proc call EQUB 0.source_stn EQUW 0 EQUD param_blk \ Buffer start EQUD param_blk_end EQUW &FFFF \ Procedure number\.param_blk EQUB 0.param_blk_end\.raw_rxcb EQUB 0  \ Reason code or rxcb number EQUB &7F \ Flag EQUB &A0 \ Port.rx_stn EQUW 0 EQUD rx_buff EQUD rx_buff_end\.result_rxcb EQUB 0 EQUW 0 EQUW 0 EQUD 0.rx_actual_end EQUD 0\\.rx_buff EQUS STRING$(64,"w").rx_buff_end\.rx_seq EQUB 0\.rx_waiting EQUB 0   \ =0 => poll req'd, <>0 => waiting for data\.rx_ptr EQUB 0 \ Index into rx_buff\.max_ptr EQUB 0 \ Value of rx_ptr pointing one beyond last valid byte.\.rx_retry EQUW 0 \ Count down while waiting for chars - transmit another poll at 0\\]NEXT