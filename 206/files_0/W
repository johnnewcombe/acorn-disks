AUTO   10REM TXFAST - transmit half of 'Fast Remote'   20REM A.R.Gordon 27/6/84   30    40 osword=&FFF1   50 osbyte=&FFF4   60 osrdch=&FFE0   70 osascii=&FFE3   80 oswrch=&FFEE   90 oscli=&FFF7  100   110 wrchvec=&20E  120 rdchvec=&210  130 eventvec=&220  140   150 buff_size=64  160   170 DIM Q% 1000  180 FOR Z=4 TO 7 STEP 3  190 IF Z=7 THEN TRACE ON  200 P%=Q%  210 O%=Q%  220 [OPT Z  230.init  240 LDA eventvec  250 STA oldvec  260 LDA eventvec+1  270 STA oldvec+1  280 LDA# (event_handler AND &FF)  \ Insert new vector  290 SEI  300 STA eventvec  310 LDA# (event_handler DIV &100)  320 STA eventvec+1  330 CLI  340\  350 LDX#1  360 STX waiting_flag \ Receiving stn is NOT waiting for data  370 DEX  380 STX buff_ptr     \ No chars in buffer (points to free slot)  390\  400 LDA #14   \ *FX 14,8 - enable event  410 LDX # 8  420 JMP osbyte \ JSR/RTS.  430\  440\  450\  460\ Enter here to send a character across the link. Char in A .  470.ch_send  480 PHP  490 PHA \ Preserve all regs so that this can replace oswrch  500 TXA  510 PHA  520 TYA  530 PHA  540 TSX  550 LDA &103,X \ Restore A  560.buff_full  570 LDY buff_ptr  580 CPY #buff_size  590 BEQ buff_full \ Event routine should empty it.  600 SEI \ Start critical region  610 LDY buff_ptr \ Might have changed under event rtn  620 STA buffer,Y  630 INY  640 LDA waiting_flag  650 BEQ transmit_somthing \ NB current ptr only in Y, so event rtn does not  660 STY buff_ptr \ transmit at the same time if a spurious poll arrives.  670 JMP exit  680\  690\  700\  710\  720.event_handler  730 PHP  740 CMP #8 \ Econet event number  750 BNE to_oldvec  760 CPX #&FF  770 BNE to_oldvec  \ We use procedure number &FFFF  780 CPY #&FF  790 BEQ our_event  800.to_oldvec  810 PLP  820 JMP (oldvec)  830\  840\ REMOTE PROCEDURE CALL EVENT - PROCEDURE &FFFF  850\  860\ This call takes one argument :  870\  880\ ARG=&00 - Log-on request. Possible further arguments for log-on text.  890\  900\ ARG=&01 - Request for data.  910\ Reply is sent on port &A0. Sequence no. is in LSB of control code.  920\ If no data is available, <waiting_flag> is zeroed, and the first byte  930\ of data to become available is sent in foreground.  940\  950\  960\  970.our_event  980 PHA  990 TXA 1000 PHA 1010 TYA 1020 PHA 1030 LDA#&12 \ Read the procedure arguments 1040 LDX# (block_buffer AND &FF) 1050 LDY# (block_buffer DIV &100) 1060 JSR osword 1070\ 1080 LDA block_buffer+2 \ Reason code 1090 BEQ log_on 1100 LDA block_buffer 1110 CMP client_stn 1120 BNE exit 1130 LDA block_buffer+1 1140 CMP client_stn+1 1150 BNE exit 1160\ 1170 LDY buff_ptr 1180 STY waiting_flag \ Set zero if client is waiting, nonzero otherwise. 1190 BEQ exit \ Can't send anything if no chars 1200 LDA#0 \ Zero buff_ptr to prevent this code being re-entered. 1210 STA buff_ptr \ Needs zeroing anyway as we are about to empty it. 1220\ 1230\ Enter here from foreground code also - on entry, Y contains <buff_ptr> 1240\ 1250.transmit_somthing 1260 TYA 1270 CLC 1280 ADC #(buffer AND &FF) 1290 STA buff_end_loc 1300 LDA #(buffer DIV &100) 1310 ADC #0 1320 STA buff_end_loc+1 1330\ 1340 LDY #10 \ Retry counter 1350 STY tx_retry 1360.retry 1370 LDX# (txcb AND &FF) 1380 LDY# (txcb DIV &100) 1390 LDA# &10 \ Transmit 1400 JSR osword 1410\ 1420.tx_poll 1430 LDA #&32 \ Poll txcb 1440 JSR osbyte 1450 TXA \ Result 1460 BMI tx_poll \ Not finished transmitting yet 1470 AND# &40 \ Test for success 1480 BEQ finish_event 1490 DEC tx_retry \ Retry reqd - have we had too many ? 1500 BNE retry 1510.finish_event 1520 LDY#0 \ Buffer is empty as a result of this call 1530 STY buff_ptr 1540 INY 1550 STY waiting_flag 1560 LDA txcb \ Ctrl code - contain sequence bit 1570 EOR #1   \ increment it. 1580 STA txcb 1590.exit 1600 PLA 1610 TAY 1620 PLA 1630 TAX 1640 PLA 1650 PLP 1660RTS 1670\ 1680\ 1690.log_on 1700 LDA block_buffer \ Just copy across station ID for now  1710 STA client_stn   \ could check for passwd etc. 1720 LDA block_buffer+1 1730 STA client_stn+1 1740 LDA #&80 \ Clear sequence no. 1750 STA txcb 1760 LDA#0 1770 STA buff_ptr 1780 JMP exit 1790\ 1800\ 1810\ 1820\ 1830\ 1840\ 1850\ 1860\ 1870\ 1880\ 1890\ 1900\ 1910.txcb 1920 EQUB &80    \ ctrl code - sequence no. in here also. 1930 EQUB &A0    \ Port no. 1940.client_stn 1950 EQUW 0 1960 EQUD buffer \ Buffer start 1970.buff_end_loc 1980 EQUD 0 1990\ 2000.block_buffer 2010 EQUS STRING$(4,"x")  \ Buffer for reading routine args 2020\ 2030.buffer 2040 EQUS STRING$(buff_size,"y")  \ Tx data buffer + overflow rtn args 2050\ rtn args can only overflow on log-on call, where txdata is scrapped. 2060\ 2070.tx_retry 2080 EQUB 0 2090\ 2100.waiting_flag 2110 EQUB 0 \ =0 if the client stn expects us to send some data 2120\ 2130.buff_ptr 2140 EQUB 0 2150\ 2160.oldvec 2170 EQUW 0 \ Old event vector saved here 2180\ 2190] 2200 TRACE OFF 2210NEXT