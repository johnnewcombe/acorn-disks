{ FSP1  File Server Procedures & Functions }External FS::fsp1(1);{$E+ Extended error messages}{$C- No ctrl-C check}{$L- No listing}{ A set of procedures to replace Writeln etc. allowing the operator to turnthem off. }Procedure Msgline;BEGINIF messages THEN WritelnEND;Procedure Msg(a:$string80);BEGINIF messages THEN Write(a)END;Procedure Msgln(a:$string80);BEGINIF messages THEN Writeln(a)END;Function stn$(stn:integer):$string10;{ Returns a string giving a station number in decimal, with the two bytesseparated if it is a distant station (high byte <>0) }VAR dum$:$string10;BEGINdum$:=' ';IF Hi(stn)<>0 THEN BEGIN  append(dum$,chr((Hi(stn) DIV 100)+48));  append(dum$,chr((Hi(stn) DIV 10)MOD 10 +48));  append(dum$,chr((Hi(stn) MOD 10)+48));  append(dum$,'.')END;append(dum$,chr((Lo(stn) DIV 100)+48));append(dum$,chr((Lo(stn) DIV 10)MOD 10 +48));append(dum$,chr((Lo(stn) MOD 10)+48));stn$:=dum$END;FUNCTION Hex2$(x:BYTE):$2STRING;VARlo,hi:BYTE;dummy:$2STRING;BEGINlo:=x MOD 16;hi:=x DIV 16;IF lo>9 THEN lo:=lo+7;IF hi>9 THEN hi:=hi+7;dummy:=chr(hi+48);APPEND(dummy,chr(lo+48));hex2$:=dummyEND;PROCEDURE Hex1(digit:NIBBLE);BEGINIF messages THEN  IF digit<10 THEN WRITE(digit:1) ELSE WRITE(CHR(digit+55))END;PROCEDURE Hex2(val:Byte);BEGINHEX1(val DIV 16);HEX1(val MOD 16)END;PROCEDURE Dbl_print(A:dbl_word);{ Print out double Word }VAR X:1..4;BEGINFOR X:=4 DOWNTO 1 DO HEX2(A[X])END;FUNCTION Dbl_zero(val:dbl_word):BOOLEAN;BEGINdbl_zero:=(val[1]=0) AND (val[2]=0) AND (val[3]=0) AND (val[4]=0)END;FUNCTION Dbl_subt(val1,val2:dbl_word):dbl_word;{returns val1-val2}VARA:1..4;carry:0..1;result:INTEGER;BEGINcarry:=0;FOR A:=1 TO 4 DO BEGIN  result:=val1[A]-val2[A]-carry;  IF result<0 THEN BEGIN dbl_subt[A]:=result+256;carry:=1 END    ELSE BEGIN dbl_subt[A]:=result;carry:=0 ENDENDEND;FUNCTION Makedbl(val:INTEGER):dbl_word;{Build double word from integer}BEGINmakedbl[1]:=val MOD 256;makedbl[2]:=val DIV 256;makedbl[3]:=0;makedbl[4]:=0;END;Procedure Extract$(VAR out$:$STRING0;data:$STRING255);{ Performs the function of GSREAD in a BBC Computer : processes a string sorting out quotes and | sequences.}VARtop_bit,ctrl,quoted,no_char,close_quote:Boolean;a:Byte;ch:char;BEGINa:=1; {Index into given string}top_bit:=FALSE;ctrl:=FALSE;close_quote:=FALSE;setlength(out$,0);WHILE data[a]=' ' DO a:=Succ(a);quoted:=data[a]='"'; {If 1st char is " then whole string considered quoted}IF quoted THEN a:=succ(a);IF a<=Length(data) THEN REPEAT  no_char:=FALSE; {Indicates that this char generates no output if TRUE}  IF ctrl THEN BEGIN {Last was a control (|) symbol}    CASE data[a] OF      '?':ch:=chr(127);      '!':BEGIN top_bit:=TRUE;no_char:=TRUE END;      '"':ch:='"';      ELSE:ch:=chr(Land(ord(data[a]),31))    END; {Case}    ctrl:=FALSE  END ELSE BEGIN    CASE data[a] OF      '"':IF close_quote THEN BEGIN ch:='"';close_quote:=FALSE END          ELSE BEGIN close_quote:=TRUE; no_char:=TRUE END;      '|':BEGIN no_char:=TRUE;ctrl:=TRUE END;      ELSE:ch:=data[a]    END {case}  END;  IF NOT no_char THEN BEGIN{   IF top_bit THEN BEGIN   ***** THIS SECTION CAUSES RUN TIME ERRORS ****      ch:=chr(Land(ord(ch),127)+128);      top_bit:=FALSE    END;         }    append(out$,ch)  END;  a:=succ(a)UNTIL (a > Length(data)) OR (quoted AND close_quote AND (data[a]<>'"') OR (Length(out$)=msg_size))END;PROCEDURE Notlistening;BEGINWRITELN('Stn',client_stn,'Not Listening')END;PROCEDURE Txerr(msg:$STRING255;no:BYTE);{Transmit error message to current station}VAR result:BYTE;BEGINmainTX.rtncode:=no;mainTX.cmd:=0; {No more work to do for client}APPEND(msg,CHR(cr));PUTSTR(ADDR4(mainTX.data)+1-min_size,msg);TRANSMIT(0,mainRX.reply,client_stn,ADDRINT(mainTX.rtncode)+LENGTH(msg),LENGTH(msg)+2,result);IF result<128 THEN notlisteningEND;PROCEDURE Err_message(errno:BYTE);VARmsg:STRING 30;BEGINCASE errno OF  179:msg:='Directory full';  184:msg:='Too many users';  191:msg:='Who are you?';  198:msg:='Disc Full';  204:msg:='Bad file name';  214:msg:='File not found';  222:msg:='Channel';  223:msg:='EOF';  ELSE:BEGIN msg:='FS unusual error ';APPEND(msg,Hex2$(errno)) END;END {Case};IF messages THEN WRITELN(msg);Txerr(msg,errno)END;  PROCEDURE ReplyOK;VAR result:BYTE;BEGINmainTX.rtncode:=0;mainTX.cmd:=0; {No more work to do for client}TRANSMIT(0,mainRX.reply,client_stn,ADDRINT(mainTX.rtncode),2,result);IF result<128 THEN notlisteningEND;Function Fcb_no(handle:Byte):nibble;{ Takes a handle of the form 2^(n-1) and returns 'n', or 0 if the handle does not refer to a currently open FCB }VARcount,bit:Byte;BEGINbit:=1;count:=1;While (handle<>bit) AND (count<8) DO BEGIN bit:=bit*2;count:=Succ(count) END;IF (handle=bit) AND user_info[user_no].fcbs[count].in_use THEN Fcb_no:=countELSE Fcb_no:=0END;Function Handle(n:nibble):Byte;{ Returns the handle equivalent to the given fcb number (ie. 2^(n-1) )}VARbit,count:byte;BEGINbit:=1;For count:=2 To n DO bit:=bit*2;Handle:=bitEND;.