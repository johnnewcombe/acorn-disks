{ FSMAKE  Include file for FSdir } { IF NOT make THEN BEGIN ~was a find type operation~    IF (Not found1) AND (error=0) THEN BEGIN error:=214; aux_error:=fname END    ~Find call stops here~  END ELSE BEGIN ~Make call}    {DDA currently points to the file which has been found, or the one     after which the new one must be inserted if none is found. <ent_no> holds     the entry no. of the next file in the chain - ie. the one we will point     to in our new entry}    Dec_B(chain_no); {Has been inc'd!}    IF init_blks > 16    THEN blocks_reqd:=init_blks+(init_blks DIV words_per_block)+1    ELSE blocks_reqd:=init_blks;     {allow for explosion blocks}    IF found THEN BEGIN {Existing file}      IF dir IN l_flags THEN BEGIN        Check_dir(DDA.offset);        IF error=0 THEN error:=0C4H          {Already exists - the easiest way to exit without doing anything!}      END ELSE BEGIN{****FUDGE to prevent *RENAME from crunching things*}        IF no_del IN l_flags THEN error:=0C4H  {already exists}        ELSE Check_not_dir(DDA.offset);        IF error=0 THEN WITH cache.dir_ent[DDA.offset] DO BEGIN          IF NOT Owner(account,aux_acc) THEN error:=0BDH          ELSE IF Land(access,L_bit)<>0 THEN error:=0C3H {locked}          ELSE IF Check_open(DDA,[in_use]) THEN error:=0C2H {already open}                            {<Check_open> sets <aux_error>, but not <error>}          ELSE BEGIN            new_acc:=account;            blocks_reqd:=blocks_reqd-Size(blk_list,exploded IN flags)          END        END      END    END ELSE     {New file, so think about a new entry}    IF NOT dir_owner THEN error:=0BDH    ELSE BEGIN      bl_des.blk:=b_list[0]; {look at bit map in entry 0}      Cache_entry(bl_des,True);      IF error=0 THEN WITH cache.dir_ent[0] DO BEGIN        new_ent:=1; {Find a new entry}        WHILE (new_ent IN bit_map) AND (new_ent<255) DO Inc_B(new_ent);        IF new_ent IN bit_map  THEN error:=0B3H {dir full}        ELSE BEGIN          found1:=b_list[new_ent DIV ents_per_block] <> 0; {*Used later*}          IF NOT found1 THEN blocks_reqd:=Succ(blocks_reqd)           {allow 1 more for the dir, noting that the dir account is the same             as the new account}        END      END    END;  {Gets here whether entry was initially found or not}    IF error=0 THEN BEGIN  {Check for disc full}      bl_des.blk:=0;      IF free_bl[DDA.block.drive] < blocks_reqd THEN error:=0C6H      ELSE Cache_entry(bl_des,True)  {Get blk0 to check for a/c bankrupt}    END;    IF error=0 THEN BEGIN      IF blocks_reqd > cache.account_space[new_acc] THEN BEGIN        error:=0ABH; {A/C bankrupt}        Hex2S(new_acc,aux_error)      END      ELSE BEGIN  {All possible errors now checked, so do the job}        WITH cache DO BEGIN          IF account_space[new_acc]-blocks_reqd > 65535          THEN account_space[new_acc]:=65535   {blksrqd was -ve}          ELSE account_space[new_acc]:=account_space[new_acc]-blocks_reqd;          needs_writing:=TRUE        END;        free_bl[bl_des.drive]:=free_bl[bl_des.drive]-blocks_reqd;        IF found THEN BEGIN {File already exists}          Cache_entry(DDA.block,True);          IF error=0 THEN WITH cache.dir_ent[DDA.offset] DO BEGIN            w:=Scrap(blk_list,exploded IN flags); {Result <w> not used}            Cache_entry(DDA.block,True)   {Cache may be used by <Scrap>}          END        END        ELSE BEGIN {insert new entry}          bl_des.blk:=b_list[0];  {Fix entry 0 info}          Cache_entry(bl_des,TRUE);          IF error=0 THEN WITH cache.dir_ent[0] DO BEGIN            bit_map:=bit_map+[new_ent];            Inc_B(chain[chain_no].ents_in_chain);            cache.needs_writing:=True;            IF DDA.block.blk=0 THEN chain[chain_no].ent_no:=new_ent            ELSE BEGIN {Not 1st entry in chain, so update previous}              Cache_entry(DDA.block,True);  {the previous entry}              IF error=0 THEN BEGIN                cache.dir_ent[DDA.offset].next_ent:=new_ent;                cache.needs_writing:=True              END            END;            DDA.block.blk:=b_list[new_ent DIV ents_per_block];            DDA.offset:=new_ent MOD ents_per_block;            IF (NOT found1) AND (error=0) THEN BEGIN {new dir block}              w:=1; {number of blocks reqd}              F_blk(DDA.block,w);            {block has already been subtracted from <free_bl> & account space}              Cache_entry(DDA.block,False); {Should be no error}              WITH cache DO BEGIN                FOR b:=0 TO M1ents_per_block DO dir_ent[b].next_ent:=new_ent+b;                needs_writing:=True              END            END          END;          IF error=0 THEN Cache_entry(dir_DDA.block,True);          IF error=0 THEN WITH cache.dir_ent[dir_DDA.offset] DO BEGIN{Update the dir's dir ent}            IF NOT found1 THEN {put new block no. into block list}              blk_list[new_ent DIV ents_per_block]:=DDA.block.blk;            b:=def_access;            chain_no:=aux_acc; {note temp use of chain_no!}            Inc_B(cycle_no);            Inc_B(no_of_ents);            Move(now,update,Sizeof(short_td)); {Insert update date}            cache.needs_writing:=True;            Cache_entry(DDA.block,True)          END;          IF error=0 THEN WITH cache.dir_ent[DDA.offset] DO BEGIN{Initialise the new dir ent}            account:=new_acc;            next_ent:=ent_no;            PutScr(Addr(name),fname,10);            creation:=now.date;            aux_acc:=chain_no;            access:=b          END        END;    {Gets here with DDA->new entry, c_ent->DDA.block}        IF error=0 THEN WITH cache.dir_ent[DDA.offset] DO BEGIN          Move(now,update,Sizeof(short_td)); {Insert update date}    {Entry ready-initialise blk list(s)}          IF init_blks>16 THEN BEGIN {IF exploded ...}            w:=(init_blks DIV words_per_block)+1;            flags:=[exploded]          END          ELSE BEGIN            w:=init_blks;            flags:=[]          END;          FOR ent_no:=0 TO 15 DO b_list[ent_no]:=0;          ent_no:=0;          WHILE w>0 DO BEGIN            blks_left:=w; {Store blocks asked for}            F_blk(bl_des,w); {On return, w holds number of blocks NOT found}            Dec_W(blks_left);            FOR blks_left:=blks_left DOWNTO w DO BEGIN               {ie. once per block}              b_list[ent_no]:=bl_des.blk;              Inc_W(bl_des.blk);              Inc_B(ent_no)            END          END;          blk_list:=b_list; {Transfer a copy to cache}          cache.needs_writing:=True;          ent_no:=0; {exp. block counter}          blks_left:=init_blks;          IF init_blks>16 THEN REPEAT {Exploded file}            bl_des.blk:=b_list[ent_no];            Cache_entry(bl_des,False); {no error possible}            w:=0; {block counter for this exp block}            WHILE (init_blks>0) AND (w<words_per_block) DO BEGIN              IF blks_left=init_blks THEN F_blk(bl_des,blks_left);                {on exit, blks_left is the no. still to find}              WHILE (init_blks > blks_left) AND (w<words_per_block) DO BEGIN                cache.EB_list[w]:=bl_des.blk;                Inc_W(bl_des.blk);                Dec_W(init_blks);                Inc_W(w)              END            END;            cache.needs_writing:=True          UNTIL init_blks=0        END      END    END  ENDEND{NB. cache contents not valid on exit if the call was a make operation with         init_blks > 16 }END;{This is an include file of FSdir}