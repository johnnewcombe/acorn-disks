{ FSP1  File Server Procedures & Functions }SEGMENT fsp1;CONSTdisc_error='Disc error';{$Ifsdecs}{$Ifsext}{$Ifsdatae}PROCEDURE stnS(new_stn:Word;VAR dumS:Min_string);{ Returns a string giving a station number in decimal, with the two bytesseparated if it is a distant station (high byte <>0) }VARhiS:Min_string;user:user_ptr;BEGINuser:=user_info; {Head of chain}WHILE (user^.stn<>new_stn) AND (user <> Nil) DO user:=user^.next_user;{ NOTE Pointer checking must be disabled}IF user <> NilTHEN GetS_cr(Addr(user^.fcbs[1].curr_blk),10,dumS) {Get user ID}ELSE dumS:='No Name';Dec_S(Lo(new_stn),hiS);dumS:=Concat(hiS,' (',dumS,') ');IF Hi(new_stn)<>0 THEN BEGIN  Dec_S(Hi(new_stn),hiS);  dumS:=Concat(hiS,'.',dumS)ENDEND;{Error (and no error) handling routine}PROCEDURE Err_message;{Uses global <error> & sends appropriate msg to client stn. Sends 'reply OK'if error=0. Note that some errors actually generate the same errornumber as others - eg. a/c bankrupt is the same as disc full}VARmainTx:RECORD  cmd_code:Byte;  CASE boolean OF    True:(msg:Min_string);    False:(rtn_code:Byte)        {Overlays length of string!}END;result:Byte;len:Word;BEGINIF error<>0 THEN WITH mainTx DO BEGIN  IF messag THEN BEGIN    StnS(client_stn,msg);    Pad(msg,15);    Wrt(msg);    Wrt('ERROR :')  END;  CASE error OF      1:msg:='Nothing happened';      2:BEGIN msg:='Bad wildcard'; error:=0CCH END;      4:msg:='Bad number';      6:msg:='Too short';    85H:msg:='Not supported';   0ABH:BEGIN msg:=Concat('Account ',aux_error,' bankrupt');error:=0C6H END;   0AEH:msg:='Not logged on';   0B4H:msg:='Directory not empty';   0B5H:msg:=Concat(aux_error,' is a directory');   0B8H:msg:='Too many users';   0B9H:msg:='Bad password';   0BAH:msg:='Insufficient privilege';   0BBH:msg:='Wrong password';   0BDH:msg:='Insufficient access';   0BEH:msg:=Concat(aux_error,' is not a directory');   0BFH:msg:='Who are you?';   0C0H:msg:='Too many files open';   0C1H:msg:='Not open for update';   0C2H:msg:=Concat('Already opened by ',aux_error);   0C3H:msg:='Locked';   0C4H:msg:='Already exists';   0C6H:msg:='Disc full';   0C7H:msg:=disc_error;   0CCH:msg:='Bad name';   0CFH:msg:='Bad attribute';   0D6H:msg:=Concat(aux_error,' not found');   0DEH:msg:='Channel';   0DFH:msg:='EOF';    OTHERWISE BEGIN Hex2S(error,msg);      msg:=Concat('FS unusual error ',msg) END;  END {Case};    IF messag THEN Wrtln(msg);  msg:=Concat(msg,chr(CR));  len:=Length(msg)+2;END ELSE len:=2;{reply OK}mainTx.rtn_code:=error;mainTx.cmd_code:=0;{use rx_seq due to bug in Acorn ROM whereby BGET will only report errors if the sequence no. is right!}Ecotx(rx_seq,mainRX.reply,client_stn,Addr(mainTX),len,result)END;Function Fcb_no(handle:Byte):nibble;{Sets <error>}{ Takes a handle of the form 2^(n-1) and returns 'n', and an error if it does not refer to a currently open FCB }VARcount,bit:Byte;BEGINbit:=1;count:=1;error:=0;While (handle<>bit) AND (count<8) DO BEGIN bit:=bit*2;Inc_B(count) END;Fcb_no:=count;IF (handle<>bit) OR NOT (in_use IN user_info^.fcbs[count].flags)  THEN error:=222END;FUNCTION Owner(main,aux:Byte):Boolean;{Checks whether the aux account or main account numbers supplied are owned by the current user}BEGINOwner:=(main IN user_info^.owner)  OR (aux IN user_info^.owner);END;PROCEDURE Check_dir(offset:Byte);{Checks that the specified object is a directory. Sets <error>,<aux_error> if not. Cache must already hold the block.}BEGINIF Land(cache.dir_ent[offset].access,D_bit)=0 THEN BEGIN  GetScr(Addr(cache.dir_ent[offset].name),10,aux_error);  error:=0BEHENDEND;PROCEDURE Check_not_dir(offset:Byte);BEGINIF Land(cache.dir_ent[offset].access,D_bit)<>0 THEN BEGIN  GetScr(Addr(cache.dir_ent[offset].name),10,aux_error);  error:=0B5HENDEND;FUNCTION Same_DDA(x,y:Disc_address):Boolean;BEGINSame_DDA:=(x.offset=y.offset) AND (x.block.blk=y.block.blk)  AND (x.block.drive=y.block.drive)END;FUNCTION Check_open(new_DDA:Disc_address;look_for:fcb_flags):Boolean;{ Checks all the FCBS of logged on users for one specifying the same DDA, with any of the required flags - hence it can check for any open file, or just one open for update. If found, <aux_error> contains the station no. responsible but <error> is not set}VARuser:user_ptr;b:Byte;found:Boolean;BEGINuser:=user_info; {head of chain}found:=False;WHILE (user <> Nil) AND NOT found DO BEGIN  b:=0; {will be inc'd}  WHILE (b < 8) AND NOT found DO BEGIN    Inc_B(b);    WITH user^.fcbs[b] DO      IF Same_DDA(new_DDA,DDA) THEN      found:=(in_use IN flags) AND ((look_for*flags) <> [])  END;  IF NOT found THEN user:=user^.next_userEND;IF found THEN BEGIN  IF user=user_info THEN aux_error:='you'  ELSE BEGIN    Stn_S(user^.stn,aux_error);    aux_error:=Concat('Stn ',aux_error)  ENDEND;Check_open:=foundEND;FUNCTION Check_flags(VAR test:fcb;r_w:fcb_flags):Boolean;{Checks the given FCB for flags to allow the specified type of operation. <r_w> is [R] for read operations, [W] for write & [] for neither (eg PTR#=). Result is TRUE if all OK, otherwise <error> is set.}VARp,e:Dbl_word;BEGINWITH test DO BEGIN  IF flags*[R,W] = [] THEN BEGIN {Is a directory}    Cache_entry(DDA.block,True);    Check_not_dir(DDA.offset)  END  ELSE IF (flags * r_w) <> r_w THEN error:=0C1H {not open for update}  ELSE IF flags*[R,W] = [W] THEN IF r_w=[W] THEN BEGIN            {Writing with extend-only access, so check ptr=ext}    Make4(p,ptr);    Make4(e,ext);    IF p<>e THEN error:=0BDH  END;  Check_flags:= error=0ENDEND;PROCEDURE M_date(date:Date_type;address:Word);{ Put text-format date into memory at <address>. One trailing space provided.  9 bytes are used including the space.}BEGINM_dec_B(date.day,address);Poke(address+2,Ord('/'));M_dec_B(date.mth_yr MOD 16,address+3);Poke(address+5,Ord('/'));M_dec_B((date.mth_yr DIV 16)+81,address+6);Poke(address+8,32)END;PROCEDURE Info_string(VAR ent:Ent_type;address:Word;VAR len:Byte);VARaS:Min_string;BEGINGetScr(addr(ent.name),10,aS);      { Name }Pad(aS,11);PutS(address,aS);IF Land(ent.access,32)=0 THEN BEGIN { Object type is FILE }  M_hex_D(ent.load_addr,address+11); { Load address }  Poke(address+19,32); {Space}  M_hex_D(ent.exec_addr,address+20); { Exec address }  aS:='   ';  PutS(address+28,aS);  M_hex_T(ent.extent,address+31);    { Length }  PutS(address+37,aS)END ELSE BEGIN         {Object type is DIR }  aS:=' Entries=';  PutS(address+11,aS);  Dec_S(ent.no_of_ents,aS);  Pad(aS,4);  PutS(address+20,aS);  aS:='Default=';  PutS(address+24,aS);  Exp_att(ent.def_access,aS);  Pad(aS,8);  PutS(address+32,aS)END;Exp_att(ent.access,aS);            { Access }Pad(aS,8);PutS(address+40,aS);M_date(ent.creation,address+48);     { Dates }M_date(ent.update.date,address+57);M_dec_B(ent.update.time.hrs,address+66);Poke(address+68,Ord(':'));M_dec_B(ent.update.time.mins,address+69);Poke(address+71,32);M_hex_B(ent.account,address+72);   { Ownership info }Poke(address+74,32);Poke(address+75,Ord('('));  {format : XX (YY)   where XX=account, YY=aux acc.}M_hex_B(ent.aux_acc,address+76);Poke(address+78,Ord(')'));len:=79END;PROCEDURE Add_no_wrap(change:Word;VAR counter:Word);{Add <change> to counter, setting <counter> to 0FFFFH if wrap round would have occured }BEGINIF counter > (65535-change) THEN counter:=65535ELSE counter:=counter+changeEND;BEGINEND.