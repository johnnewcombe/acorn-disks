{  BIGFS  File Server main code }PROGRAM Fs;CONST{$Ifsdecs}pri_spa,pri_ptr:Dbl_word;  {<pri_spa> points to free space in the print buffer, <pri_ptr> points   to the next Byte to be printed *** NB these are in COMMON area ***}VARx:Word;a,block_no,print_block,next_seq,b:Byte;ch:Char;print_buff:ARRAY[1..print_size] OF Byte;aS:Min_string;{$Ifsext}{$Ifsp1e}{$Ifsp2e}{$Ifsp3e}{$Ifsp4e}{$Ifsusere}{$Ifsdatae}{$Ifsrnde}FUNCTION System:Boolean;{ check if user is sys-priv. Also check for keyswitch position}BEGINSystem:=(sys_priv IN user_info^.flags) AND Syst_swEND;Procedure Print(var txt:Min_string);{Procedure to place contents of string into print buffer.}VARa:Byte;BEGINFor a:=1 TO length(txt) DO BEGIN  ListOT(ord(txt[a]));ENDEND;Procedure Finish_print;VARdummy:Byte;BEGINPrint(end_text);print_active:=false;IF messag THEN BEGIN  StnS(client_stn,aS);  Pad(aS,20);  Wrt(aS);  Wrtln('End print')END; {Now acknowledge final packet}Ecotx(rx_seq,print_port,print_stn,addr(printRx),1,dummy);print_stn:=0 {Only non-0 if we are talking to someone}END;BEGIN {Main block}char_io; {Initialise wrch etc. Also messag,debug}cache.which_blk.drive:=255; {Out of range drive no. <=> not in use}cache.needs_writing:=False;pri_ptr:=65536*2;pri_spa:=65536*2;print_stn:=0; {Only non-0 if we are talking to someone}time_out:=0;print_active:=false;print_waiting:=false; {If TRUE, we have an RxCB open}pre_text:='';post_text:=Concat(chr(13),chr(10)); {CR,LF}banner:='***  SJ Research HDFS ';no_banner:=false;end_text:=chr(12);spare_users:=Nil;FOR a:=1 TO no_users DO BEGIN  Heap(user_info,Sizeof(user_descrip));  WITH user_info^ DO BEGIN    FOR b:=1 TO 8 DO fcbs[b].flags:=[];  {Not in_use,write access etc.}    next_user:=spare_users;    spare_users:=user_info  ENDEND;user_info:=Nil;Ecoini;Inilow;Ini_clk;Init_disc;On_line; {Illuminate the LED !}REPEAT {Main loop}  Rxset(blockno,cmdport,0,Addr(mainRX),min_size+5);  WHILE NOT Rxread(blockno,rx_seq,b,client_stn,x) DO BEGIN    Chk_sw; {Check power switch}{Empty caches}    IF (cache_time=10) AND (cache.needs_writing) THEN BEGIN      Disc_wr(Addr(cache.data),block_size,0,False,cache.which_blk);      cache.needs_writing:=False    END;    IF cache_time=0 THEN  C_idle {Purge EXTERNAL cache}    ELSE Dec_W(cache_time);{Update time}    Get_clk;{Try to empty print buffer}    do_list;{Try to fill print buffer}    IF print_waiting THEN IF      RXread(print_block,rx_seq,b,client_stn,blk_len) THEN BEGIN      print_waiting:=FALSE;      IF print_active OR (client_stn=print_stn) THEN BEGIN         {Either still printing or timed out & re-started}        print_active:=TRUE;        IF Land(rx_seq,1)=next_seq THEN BEGIN          next_seq:=Land(succ(next_seq),1); {Increment sequence no}          IF (NOT old_type) AND (Land(rx_seq,4)=4) THEN blk_len:=pred(blk_len);            {Control byte indicates last block, but there is a             spurious ctrl-C at the end as well }          a:=1;          WHILE a<=blk_len DO BEGIN             {Transfer data to output buffer}            IF old_type AND (printRx[a]=3) THEN Finish_print             {Old type block terminator}            ELSE List_OT(printRx[a]);            a:=Succ(a)          END; {while}          IF (NOT old_type) AND (Land(rx_seq,4)=4) THEN Finish_print           {Usual terminator}        END      END ELSE BEGIN {Not active, so should be log-on}        IF print_stn<>0 THEN Print(end_text);         {Terminate timed-out user}        StnS(client_stn,aS);        Pad(aS,20);        old_type:=printRx[1]<>0; {Character sent indicates protocol}        IF messag THEN BEGIN          Wrt(aS);          Wrtln('Printing - ');          IF old_type THEN Wrt('Old') ELSE Wrt('New');          Wrtln(' protocol')        END;        print_stn:=client_stn;        IF NOT no_banner THEN Print(pre_text);        Print(banner);        IF NOT no_banner THEN BEGIN          aS:=Concat(' ***  Station ',aS);  {aS still has stn. no in decimal}          Print(aS);          aS:=' ***';          Print(aS);          Print(post_text)        END;        next_seq:=Land(succ(Rx_seq),1); {Initialise sequence no (=0 or =1) }        print_active:=TRUE      END    END;    IF (NOT print_waiting) AND      ((pri_spa-pri_ptr < 00FF00H ) OR (pri_ptr-pri_spa >256)) THEN BEGIN      { There is room in the buffer for another recieve block }      print_waiting:=TRUE;      IF print_active THEN       Rxset(print_block,print_port,print_stn,addr(printRx),prx_size)      ELSE Rxset(print_block,print_port,0,addr(printRx),prx_size);       { Acknowledge if appropriate }      IF print_active THEN Ecotx(rx_seq,print_port,print_stn,        addr(printRx),1,b);      time_out:=tim_delay    END;    IF print_active AND print_waiting THEN Dec_W(time_out);    IF print_active AND (time_out=0) THEN BEGIN      Delrx(print_block);      print_waiting:=False;  {Allows another rxblk to set itself up}      IF messag THEN Wrtln('Print timeout');      print_active:=false    END  END;{ Drops through here when a packet arrives on the FS command port }  IF debug THEN BEGIN    Wrt('FN=');    Dec_S(mainRX.FN,aS);    Wrt(aS);    Wrt(' Stn');    StnS(client_stn,aS);    Wrtln(aS)  END;   {Check if logged on or *cmd which could be *I AM }  IF (mainRx.fn=0) OR User_ok THEN  CASE mainRX.fn OF    0:Starcmd;    1:Save;    2:Load;    3:Cat;    5:Load;    6:X_open;    7:X_close;    8:B_get;    9:B_put;   10:MB_get;   11:MB_put;   12:Rd_rnd_info;   13:Wr_rnd_info;   14:Disc_info;   15:Read_users;   16:Read_time;   17:Eof;   18:Read_info;   19:Write_info;   20:Del_object;   21:User_envir;   22:Set_opt;   23:Log_off;   24:Find_user;   4,25:EcoTx(0,mainRx.reply,client_stn,Ver_adr,Ver_len,error);{version string}   26:Free_space;   27:Cdir;   28:Set_time;   64:Acct_space;  255:BEGIN {Set message level}      IF System THEN BEGIN        error:=0;        messag:=mainRx.data[1]<>0;        debug:=mainRx.data[2]<>0      END      ELSE error:=0BAH; {Insuff. priv.}      Err_message    END;   OTHERWISE BEGIN error:=133; Err_message END;  END {of case}  ELSE BEGIN error:=191; Err_message END; {'Who are U?' }  cache_time:=cache_del { Delay before writing cache }UNTIL False;END.