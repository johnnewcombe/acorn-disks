{ FSCAT  Code for catalogue, INCLUDEd in FSP4 }PROCEDURE Cat;VARfname:min_string;ent_no,chain_no,a,arg,ent_offset,entry,no_of_ents:Byte;index:Word;big_buff:ARRAY[1..buff_size] OF Byte;b_list:blk_vec;private:Boolean;DDA:disc_address;BEGINWITH mainRx DO BEGIN  arg:=data[1];  ent_offset:=data[2];  no_of_ents:=data[3]END;GetScr(Addr(mainRX.data[4]),min_size-4,fname);A:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[a].DDA;  Strip_dirs(fname,DDA,True);  IF error=0 THEN BEGIN    WITH cache.dir_ent[DDA.offset] DO BEGIN      b_list:=blk_list;      big_buff[4]:=cycle_no    END;  { after here, DDA contains the current block, but <offset> is undefined }    DDA.block.blk:=b_list[0];    Cache_entry(DDA.block,True);    IF error=0 THEN BEGIN      a:=0; {entry number offset to 1st chain}      chain_no:=0;      REPEAT        ent_offset:=ent_offset-a;        a:=cache.dir_ent[0].chain[chain_no].ents_in_chain;        chain_no:=Succ(chain_no);      UNTIL (ent_offset<a) OR (chain_no=15);      chain_no:=Pred(chain_no);      entry:=0; {Counter of the number we've done}      index:=5; {Index into the output buffer}      IF ent_offset<a THEN BEGIN        ent_no:=cache.dir_ent[0].chain[chain_no].ent_no;        WHILE (ent_offset>0) AND (error=0) DO BEGIN        {scan down to right entry}          ent_offset:=Pred(ent_offset);          DDA.block.blk:=b_list[ent_no DIV ents_per_block];          Cache_entry(DDA.block,True);          ent_no:=cache.dir_ent[ent_no MOD ents_per_block].next_ent        END;      {Main entry-by entry writing loop starts here}        WHILE (ent_no<>0) AND (entry<no_of_ents) AND (error=0)        AND (index < buff_size-100) DO BEGIN          DDA.block.blk:=b_list[ent_no DIV ents_per_block];          DDA.offset:=ent_no MOD ents_per_block;          Cache_entry(DDA.block,True);          WITH cache.dir_ent[DDA.offset] DO BEGIN            GetScr(Addr(Name),10,fname);               { Name as a string will come in useful}            entry:=Succ(entry);            private:=NOT((Land(access,P_bit)=0) OR Owner(account,aux_acc));            Pad(fname,10);            IF private THEN fname:='...Private';            CASE arg OF              0:BEGIN                PutS(Addr(big_buff[index]),fname);                Move(load_addr,big_buff[index+10],8); {Exec also}                Move(access,big_buff[index+18],3); {date also}                big_buff[index+21]:=account;                big_buff[index+22]:=0;                big_buff[index+23]:=account;                Move(extent,big_buff[index+24],3);                index:=index+27              END;              1:BEGIN {info string}                IF private THEN BEGIN                  PutS(Addr(big_buff[index]),fname);a:=10                END ELSE Info_string(cache.dir_ent[DDA.offset],                  Addr(big_buff[index]),a); {Length returned in <a>}                index:=index+a+1;                big_buff[index-1]:=0  {Terminator}              END;              2:BEGIN  {plain name}                big_buff[index]:=10;                PutS(addr(big_buff[index+1]),fname);                index:=index+11              END;              3:BEGIN  {name + att string}                Pad(fname,11);                PutS(addr(big_buff[index]),fname);                index:=index+11;                IF private THEN fname:=''                ELSE Exp_att(access,fname); {temp use fname}                Pad(fname,7);                PutS(addr(big_buff[index]),fname);                index:=index+8;                big_buff[index-1]:=0 {terminator}              END;              OTHERWISE error:=79 {Illegal ARG}            END; {Case}            ent_no:=next_ent          END; {with}          WHILE (ent_no=0) AND (chain_no<14) AND (error=0) DO BEGIN            chain_no:=Succ(chain_no);            DDA.block.blk:=b_list[0];            Cache_entry(DDA.block,True);            ent_no:=cache.dir_ent[0].chain[chain_no].ent_no          END        END {main WHILE loop}      END    END  ENDEND;IF error=0 THEN BEGIN  big_buff[index]:=128; {final terminator}  big_buff[1]:=0;  big_buff[2]:=0; {TX header}  big_buff[3]:=entry;  {Count of entries actually got}  Ecotx(0,mainRX.reply,client_stn,Addr(big_buff),index,a)END ELSE Err_messageEND;