{>  FSDECS}min_size=80; {Size of minibuffers}CR=13;cmdport=099H;data_port=09AH; {This is re-declared locally when it is a variable}blk_size=1024; {Size of unit in which disc is allocated. Not easily changed. }block_size=blk_size;ents_per_block=16;words_per_block=512;M1ents_per_block=15;  {Minus 1!!}M1words_per_block=511;M1block_size=1023;buff_size=2048; {MUST be an integer no. of blocks (for save/load) }max_drive=1;  {min drive is 0}print_size=1024; {print buffer size}print_port=0D1H;prx_size=128;cache_del=200; {Wait before writing cache}tim_delay=20000; {print timeout delay}{Access Byte bits}X_bit=128;P_bit=64;D_bit=32;L_bit=16;R_bit=1;W_bit=2;TYPEDbl_word=Integer;Byte=0..255;Three_Byte=ARRAY [1..3] OF Byte;Word=0..65535;Nibble=0..15; Buffer=ARRAY [1..buff_size] of Byte;Minibuffer=ARRAY [1..min_size] of Byte;min_string=string[min_size];Handles=RECORD  URD,CSD,lib:ByteEND;StdRX=RECORD CASE Boolean OF  True:(print:Minibuffer);  False:(reply:Byte;    FN:Byte;    envir:Handles;    data:Minibuffer)END;StdTX=RECORD  cmd:Byte;  rtncode:Byte;  data:minibufferEND;Block_descrip=RECORD  drive:Byte;  blk:Word    {Block number. Each block is <blk_size> Bytes}END;Date_type=RECORD  day:Byte;  mth_yr:ByteEND;Short_time=RECORD  hrs:Byte;  mins:ByteEND;Time_type=RECORD  hrs:Byte;  mins:Byte;  secs:ByteEND;Timedate=RECORD  date:Date_type;  time:Time_typeEND;Short_td=RECORD  date:Date_type;  time:Short_timeEND;Disc_address=RECORD  block:block_descrip;  offset:Byte          {64 Byte Offset in block : Origin is ZERO}END;dir_flags=(exploded,xx1,xx2,xx3,xx4,xx5,xx6,xx7);blk_vec=ARRAY [0..15] OF Word;ent_type=RECORD CASE Byte OF   0:(bit_map:SET OF Byte;      chain:ARRAY [0..14] OF RECORD        ents_in_chain:Byte;        ent_no:Byte      END;      spare:Word      );   1:(Dum2:ARRAY [0..11] OF Byte;      def_access:Byte;      cycle_no:Byte;      parent_block:Word;      parent_offset:Byte;      no_of_ents:Byte;      dum1:ARRAY [18..63] OF Byte; {Items common to both}      );   2:(account:Byte;      name:ARRAY[0..9] OF Byte;      next_ent:Byte;      load_addr:Dbl_word;      exec_addr:Dbl_word;      extent:Three_Byte;      access:Byte;      creation:Date_type;      update:Short_td; {Time & date - no secs }      Aux_acc:Byte;      flags:SET OF dir_flags;      blk_list:blk_vec      )END;user_flags=(pass_set,sys_priv,prot_save,aa3,aa4,aa5,aa6,aa7);Cache_descrip=RECORD  which_blk:block_descrip;  next:Byte;  needs_writing:Boolean;  CASE Byte OF    1:(data:ARRAY [0..M1block_size] OF Byte);    2:(EB_list:ARRAY [0..M1words_per_block] OF Word);    3:(dir_ent:ARRAY [0..M1ents_per_block] OF ent_type);    5:(junk:ARRAY [Byte] OF Word;      account_space:ARRAY [Byte] OF Word)END;fcb_flag=(seq,in_use,W,R,err,yy5,yy6,yy7);fcb_flags=SET OF fcb_flag;fcb=RECORD  flags:fcb_flags;  DDA:Disc_address; {The directory disc address : the disc address of the                     directory entry for the file. This implicitly contains                     the drive of the file as files can't refer from                     drive to drive. Drive set to 255 if disc changed }  curr_blk:Word;    {The block pointed to by the random pointer}  ptr:Three_Byte;   {The random pointer (PTR# in Basic)}  old_ptr:Three_Byte; {The value used for the last operation}  ext:Three_Byte    {File extent}            {NB. curr_blk to ext are over-written by the user ID in the             1st FCB for each user, which is always a dir (the URD) }END;user_ptr=^user_descrip;user_descrip=RECORD {168 bytes}  next_user:user_ptr;  flags:SET OF user_flags;  stn:Word;  fcbs:ARRAY[1..8] OF fcb;  {1,2 defined: 1=URD, 2=LIB}  pass_drive:Byte;  {Which password file used for log-on?}  pass_ptr:Word; {index into password file}  owner:SET of Byte;END;lookup_flag=(make,dir,no_del);lookup_flags=SET OF lookup_flag;COMMONuser_info,spare_users:user_ptr; {Pointers to main & free user chains}cache:Cache_descrip;free_bl:ARRAY[0..max_drive] OF Word;pass_blk:fcb;mainRX:stdRX;print_rx:ARRAY[1..prx_size] OF Byte;aux_error:min_string; {contains auxilliary error message}pre_text,post_text,banner,end_text:Min_string;bl_des:Block_descrip; {General use - eg before calling cache_entry}client_stn,cache_time,time_out,blk_len,print_stn:Word;error,no_discs,user_no,rx_seq:Byte;no_banner,debug,messag,old_type,print_waiting,print_active:Boolean;now:Timedate; {Common area initialised by Get_clk}