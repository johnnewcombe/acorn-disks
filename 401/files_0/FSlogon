{ FSlogon  File Server *I AM command }{Include file for FSuser}Procedure I_am(VAR cmd_text:min_string);VARfound,go_on:Boolean;aS,real_name:Min_string;b:BYTE;pass_ent:RECORD  user_id:ARRAY[0..9] OF Byte;  password:ARRAY[0..9] OF Byte;  boot:Byte;  flags:SET of user_flags;  spare:ARRAY[22..31] OF Byte;  owner:SET OF ByteEND;tx:RECORD cmd_code,rtn_code,URD,CSD,LIB,boot:Byte END;new_DDA:Disc_address;this:user_ptr;BEGINerror:=0;IF user_info^.stn=client_stn THEN Do_logoff;this:=spare_users;IF spare_users=Nil THEN error:=184 {Too many users}ELSE WITH this^ DO BEGIN  spare_users:=next_user;  next_user:=user_info; {Add to head of chain}  user_info:=this;  {skip stn & get hold of userID}  b:=1;  WHILE (cmd_text[b]<'A') AND (b<=Length(cmd_text)) DO b:=succ(b);  MidS(cmd_text,b-1,min_size);  GSread(cmd_text,real_name,True);   {for delimiters}  IF messag THEN BEGIN    Wrt('I AM ');    Wrtln(real_name)  END;  WITH pass_blk.DDA DO BEGIN    WITH block DO BEGIN      blk:=0;      drive:=255;  {Inc_B is circular}    END;    offset:=2  END;  IF NOT Legal(real_name,b,go_on) THEN error:=0CCH {Bad name}  ELSE WITH pass_blk DO REPEAT    Inc_B(DDA.block.drive);    bl_des.drive:=DDA.block.drive;    Update_blk(pass_blk,0);  {Find 1st blk of passwd file}    bl_des.blk:=curr_blk;    IF pass_blk.curr_blk=0 THEN found:=False {no password file}    ELSE BEGIN      Disc_rd(Addr(pass_ptr),2,b*2,bl_des);  {b contains hashing index}      Dec_W(pass_ptr);      REPEAT        Inc_W(pass_ptr);        Update_blk(pass_blk,pass_ptr*64);        bl_des.blk:=curr_blk;        Disc_rd(Addr(pass_ent),64,(pass_ptr MOD ents_per_block)*64,bl_des);        found:=Match(real_name,Addr(pass_ent.userID),go_on);      UNTIL found OR (NOT go_on) OR (bl_des.blk=0)    END  UNTIL found OR (DDA.block.drive=no_discs);  IF error=0 THEN BEGIN    IF found THEN BEGIN      GS_read(cmd_text,aS,True); {password to aS}      IF Pass_OK(aS)      THEN IF NOT Match(aS,Addr(pass_ent.password),go_on) THEN error:=0BBH        ELSE BEGIN        pass_drive:=pass_blk.DDA.block.drive;        flags:=pass_ent.flags;        owner:=pass_ent.owner;        tx.boot:=pass_ent.boot;        Move(pass_ent.userID,fcbs[1].curr_blk,10); {Save for *USERS etc}      END    END    ELSE BEGIN {Not in password file}      IF bl_des.blk=0 THEN BEGIN {Missing or malformed password file}        owner:=[0..255];        flags:=[sys_priv];        Wrtln('No password file')      END      ELSE BEGIN        owner:=[];        flags:=[]      END;      pass_drive:=0;      pass_ptr:=0;  {0 is index - used to indicate not in file}      tx.boot:=0;    {opt 0 - do nothing}      PutScr(Addr(fcbs[1].curr_blk),real_name,10)  {store user ID}    END  END;  stn:=client_stn;  IF error=0 THEN BEGIN {open URD, LIB}    new_DDA.block.drive:=pass_drive;    new_DDA.block.blk:=0; {This is the root}    new_DDA.offset:=0;    For b:=1 to 2 DO With fcbs[b] DO BEGIN      flags:=[in_use]; {Not write_access Otherwise no-one else can open it}      DDA:=new_DDA  {in case lookup fails ahead}    END;    Find(real_name,new_DDA);    IF error=0 THEN fcbs[1].DDA:=new_DDA; {Set URD}    new_DDA.block.drive:=0;        {block doesn't matter, as $ is specified}    real_name:='$.LIBRARY';    Strip_dirs(real_name,new_DDA,True);    IF error=0 THEN fcbs[2].DDA:=new_DDA {Set Lib}    ELSE error:=0     {Failure to find LIB does not prevent log on}  ENDEND;IF error<>0 THEN Err_messageELSE WITH tx DO BEGIN  cmd_code:=5;  rtn_code:=0;  URD:=1; {URD handle(fixed)}  CSD:=1; {CSD handle (may change later)}  LIB:=2; {LIB handle (fixed)}  Ecotx(0,mainRX.reply,client_stn,addr(TX),6,b)ENDEND;