{ FSUTIL1 include file for FSUTIL}PROCEDURE Rename_disc;BEGINWriteln('               RENAME DISC');Writeln;Writeln('Place disc to be renamed in drive A.');Get_blk0;Write('new ');Get_disc_name;Writeln;Write('Write back new name ? ');IF Yes_no THEN Rw_blk(False,cache[1],0,0)END;PROCEDURE Alter_accounts;VARacct:Byte;BEGINWriteln('        DISC SPACE ACCOUNTS');Writeln;Writeln('Place disc to be adjusted in drive A.');Get_blk0;REPEAT  Writeln;  Write('Account number :');  acct:=Get_hex;  Writeln('Current balance =',cache[1].words[acct+256]:5);  Write('New balance :');  cache[1].words[acct+256]:=Get_num(cache[1].words[acct+256],65535);  Write('Adjust another account ? ');UNTIL Not Yes_no;Writeln;Write('Write back new values ? ');IF Yes_no THEN Rw_blk(False,cache[1],0,0)END;PROCEDURE Zap_passwords;VARb:Byte;BEGINWriteln('        CLEAR PASSWORD FILE');Writeln;Writeln('This option will clear a corrupt or');Writeln('unwanted password file from a disc.');Writeln('All other files on the disc will be');Writeln('left unaltered.');Writeln;Writeln('This option can also be used to add');Writeln('a password file to a disc used with');Writeln('earlier versions of the file server.');Writeln;Writeln('Place disc to be cleared in drive A.');Get_blk0;WITH cache[1] DO BEGIN  FOR b:=128 TO 255 DO data[b]:=0;   {clear entry & blk list}  pass_ent.name:='%Passwords';  pass_ent.access:=12 { access WR/ only}END;Writeln;Writeln('Password file cleared');Rw_blk(False,cache[1],0,0)END;PROCEDURE Copy;VARno_tracks,read_ptr,write_ptr:Byte;blocks_left,base_blk:Word;needs_format:Boolean;BEGINWriteln('           WHOLE DISC COPY');Writeln;Writeln('This option makes an identical copy of');Writeln('a whole disc. Any previous contents of');Writeln('the new disc are destroyed, including');Writeln('disc name, account information etc.');Writeln('The new disc need not have already');Writeln(' been formatted.');Writeln;Writeln('Place disc to be copied in drive A');Writeln('& new disc to receive copy in drive B');Writeln;Write('Format new disc ? ');needs_format:=Yes_no;Writeln;Get_blk0;  {Gets DSflag, displays size, leaves blk 0 in cache}base_blk:=cache[1].disc_size;IF two_sid THEN base_blk:=base_blk DIV 2;IF five_in THEN BEGIN  base_blk:=base_blk*2; { in order to divide by 2.5 }  IF (base_blk MOD 5) = 0 THEN no_tracks:=base_blk DIV 5  ELSE no_tracks:=(base_blk DIV 5) + 1ENDELSE BEGIN { 8 inch = 4K/track/side }  IF (base_blk MOD 4) = 0 THEN no_tracks:=base_blk DIV 4  ELSE no_tracks:=(base_blk DIV 4) + 1END;Writeln('Tracks    =',no_tracks:5);IF needs_format THEN BEGIN  Format(1,no_tracks);  IF two_sid THEN Format(3,no_tracks);  WritelnEND;blocks_left:=cache[1].disc_size-1; {Got blk 0 already}base_blk:=0; {block no. of 1st block in cache}read_ptr:=2; {Start at 2nd block}REPEAT  REPEAT    Rw_blk(True,cache[read_ptr],0,base_blk+read_ptr-1);    read_ptr:=Succ(read_ptr);    blocks_left:=Pred(blocks_left)  UNTIL (read_ptr > cache_size) OR (blocks_left=0);  write_ptr:=1;  REPEAT    Rw_blk(False,cache[write_ptr],1,base_blk+write_ptr-1);    write_ptr:=Succ(write_ptr);  UNTIL write_ptr=read_ptr;  read_ptr:=1;  base_blk:=base_blk+cache_sizeUNTIL blocks_left=0;Writeln('Copy complete');Verify(1,no_tracks);IF two_sid THEN Verify(3,no_tracks);Writeln(verified)END;PROCEDURE New_disc;VARb,no_tracks:Byte;acct_size,w,blocks_left:Word;BEGINWriteln('           FORMAT NEW DISC');Writeln;Writeln('Place disc to be formatted in drive A');Writeln;Write('Is the disc double sided ?');two_sid:=Yes_no;IF Five_in THEN b:=40 ELSE b:=77; {default no. of tracks}Writeln('How many tracks on each side of the disc');Write('(Usually ',b:1,') :');no_tracks:=Get_num(b,100);Writeln('How much disc space for each account ?');Writeln('(Try ',(no_tracks DIV 10)*10:1,'K - any account may be adjusted');Write(' later). In units of 1K :');acct_size:=Get_num((no_tracks DIV 10)*10,65535);FOR b:=1 TO 2 DO FOR w:=0 TO M1block_size DO Cache[b].data[w]:=0;IF Five_in THEN w:=no_tracks*5 {<w> is capacity of two sides}ELSE w:=no_tracks*8;IF two_sid THEN BEGIN  cache[1].ds_flag:=255;  cache[1].disc_size:=wEND ELSE BEGIN  cache[1].ds_flag:=0;  cache[1].disc_size:=w DIV 2END;WITH cache[1] DO BEGIN  Writeln(disc_size:3,'K disc');  root.name[1]:='$';     {Root name}  root.name[2]:=Chr(cr);  root.access:=D_bit;  root.def_access:=15; {WR/WR}  root.blk_list[0]:=1;  SJ_msg:='SJ Research File Server';  pass_ent.name:='%Passwords';  pass_ent.access:=12; { access WR/ only}  FOR w:=256 TO 511 DO words[w]:=acct_sizeEND;cache[2].dir_ent[0].bit_map:=[0];FOR b:=1 TO 15 DO cache[2].dir_ent[b].next_ent:=b;REPEAT  Get_disc_name;  Format(0,no_tracks);  IF two_sid THEN Format(2,no_tracks);  Writeln;  Rw_blk(False,cache[1],0,0); {disc routines print their own}  Rw_blk(False,cache[2],0,1); {error messages}  Verify(0,no_tracks);  IF two_sid THEN Verify(2,no_tracks);  Writeln;  Writeln(verified);  Writeln;  Write('Format another disc ? ');UNTIL NOT Yes_noEND;BEGIN  {Main Program}Dk_init;two_sid:=False; {arbitrary initial value}stop:=False;debug:=False; {Message print on/off}Write(chr(17)); {ctrl-Q disables page wait on RML}REPEAT  Writeln;  Writeln;  Ver_msg;  Writeln('Utility Program');  Writeln;  Writeln('A - Alter individual space accounts');  Writeln('C - Copy whole disc');  Writeln('F - Format new disc');  Writeln('P - clear Password file');  Writeln('R - Rename disc');  Writeln('S - Stop');  Writeln;  Write('Command :');  ch:=Get;  Writeln(ch);  CASE ch OF    'A','a':Alter_accounts;    'C','c':Copy;    'D','d':BEGIN        debug:=NOT debug;        Write('Debug ');        IF debug THEN Writeln('On') ELSE Writeln('Off')      END;    'F','f':New_disc;    'p','P':Zap_passwords;    'Q','q','S','s':stop:=True;    'R','r':Rename_disc;    OTHERWISE Writeln('Illegal option')  ENDUNTIL stop;FS_exitEND.