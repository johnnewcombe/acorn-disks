{ FSDIR  File Server Directory management }SEGMENT fsdir;CONST{$Ifsdecs}{$Ifsext}{$Ifsp1e}{$Ifsdatae}{$Ifswilde} {for FN Scrap}FUNCTION System:Boolean; EXTERNAL;FUNCTION Size(b_list:Blk_vec;exploded:Boolean):Word;{Sets <error>. Corrupts <c_ent> }{** MUST NOT USE GLOBAL BLDES, as used by *ACCOUNT}{Counts blocks occupied by a file. <b_list> is 2nd half of dir ent. <exploded> indicates whether this is in fact an exploded file, in which case, all the blocks are loaded & scanned. ***Takes it's drive no from the current cache block !!!!*****}VARbl_des:Block_descrip;a,b:Byte;result:Word;BEGINresult:=0;a:=0;bl_des.drive:=cache.which_blk.drive;  {**FUDGE  ***** }WHILE (a<16) AND (error=0) DO BEGIN  IF b_list[a]<>0 THEN BEGIN {=0 => not allocated}    bl_des.blk:=b_list[a];    Inc_W(result);    IF exploded THEN BEGIN      Cache_entry(bl_des,True);      WITH cache DO FOR b:=0 TO M1words_per_block DO BEGIN        bl_des.blk:=EB_list[b];        IF bl_des.blk<>0 THEN Inc_W(result)      END    END  END;  Inc_B(a)END;Size:=resultEND;Function Drive_no(VAR drv_name:min_string):Byte;{Sets <c_ent>,<error>}{Returns the drive number of the named drive, if found. Range 0..no_discs}VARblk0:block_descrip;a:Byte;bool,found:Boolean;BEGINWITH blk0 DO BEGIN  drive:=255;  {Inc_B is circular!}  blk:=0 { Hmm!! }END;IF Not Legal(drv_name,a,bool) THEN error:=204 {NB dummy parameters}ELSE REPEAT  Inc_B(blk0.drive);  Cache_entry(blk0,True);  IF error=0 THEN found:=Match(drv_name,Addr(cache.data[87]),bool)UNTIL found OR (blk0.drive >= no_discs) OR (error<>0);IF (error=0) AND (NOT found) THEN BEGIN aux_error:=drv_name;error:=214 END;    { 'Not found' !! }Drive_no:=blk0.driveEND;PROCEDURE Look_up(l_flags:Lookup_flags;init_blks:Word;VAR fname:Min_string;  VAR DDA:Disc_address);{Sets <error>,<c_ent>. <c_ent> gives the DDA's block, unless a file >16K long has just been made}{Find or make a file (as determined by 1st param.). Second parameter gives an initial size for the file - if there is not room, the file is not created, and any existing file of that name is left unchanged. Rest of params same as <Find> - DDA and c_ent point to the file which has been found or made on exit, or are undefined if error<>0. Special names (eg. $) are not handled, hence the need for <find>. <l_flags> is a set containing <make> and <dir>. <dir> is only relavent if <make> is present & indicates the type of object to be made, in order to allow checking of 'already exists'. }VARb_list:Blk_vec;dir_DDA:Disc_address;b,new_ent,new_acc,chain_no,ent_no:Byte;bl_des:Block_descrip;dir_owner,wild,go_on,found,found1:Boolean;blocks_reqd:Dbl_word; {MUST be signed}blks_left,w:Word;BEGIN{Check for '%PASSWORDS'}IF (fname='%PASSWORDS') THEN BEGIN  IF System THEN WITH DDA DO BEGIN    block.blk:=0;    offset:=2;    Cache_entry(DDA.block,True)  END  ELSE error:=0BAH  {Insuff. priv}ENDELSE IF Not Legal(fname,chain_no,wild) OR (fname='') THEN error:=204 {Bad filename}ELSE IF wild AND (make IN l_flags) THEN error:=2     {Bad wildcard}ELSE BEGIN     {***note lack of indent here ***}Cache_entry(DDA.block,True);IF error=0 THEN Check_dir(DDA.offset);  {look at access byte to see if it's a directory}IF error=0 THEN BEGIN  WITH cache.dir_ent[DDA.offset] DO BEGIN    b_list:=blk_list;    new_acc:=account;    dir_owner:=Owner(account,aux_acc)  END;  dir_DDA:=DDA;  bl_des.drive:=DDA.block.drive;  REPEAT {for all the chains if wild, else just 1}    DDA.block.blk:=0; {Dummy value to indicate start of chain}    bl_des.blk:=b_list[0];    Cache_entry(bl_des,True);    IF error=0 THEN BEGIN      ent_no:=cache.dir_ent[0].chain[chain_no].ent_no;      go_on:=True;      found:=False;      found1:=False;      WHILE (error=0) AND go_on AND (ent_no<>0) DO BEGIN   {ent_no=0 <=> end chain}        w:=b_list[ent_no DIV ents_per_block];        bl_des.blk:=w;        Cache_entry(bl_des,True);        new_ent:=ent_no MOD ents_per_block;        WITH cache.dir_ent[new_ent] DO BEGIN          found:=Match(fname,Addr(name),go_on);          found1:=found AND ((Land(access,P_bit)=0) OR Owner(account,aux_acc));  {<Found1> is what we tell the user - <found> is whether it really was found}          go_on:=go_on AND (NOT found1) AND (wild OR NOT found);  {Don't go on if found, unless wildcarded & this one is private}          IF go_on OR found THEN WITH DDA DO BEGIN            offset:=new_ent;            block:=bl_des;            ent_no:=next_ent    {point to next ent}          END        END      END    {note <go_on> false if found true, so only test one}    END;    Inc_B(chain_no)  UNTIL NOT(go_on) OR (error<>0) OR (chain_no=15) OR NOT(wild);  IF NOT (make IN l_flags) THEN BEGIN {was a find type operation}    IF (Not found1) AND (error=0) THEN BEGIN error:=214; aux_error:=fname END    {Find call stops here}  END ELSE BEGIN {Make call}{$IFSMAKE}END;  {Allows for un-indented block above}PROCEDURE Find(VAR fname:min_string;VAR DDA:disc_address);{Sets <c_ent>,<error>}{Looks in the given directory for any files matching the given string, whichmust be a simple name (all directories should have already been stripped).<cache_no> is the cache entry where the relavent directory block has beenput. <DDA> specifies the directory to be searched and returns the DDA ofthe found file. All exit params undefined if error<>0. In the event of a'not found' error, the global <aux_error> contains the filename  }BEGINIF Length(fname)=0 THEN Cache_entry(DDA.block,True)ELSE IF (fname[1]='$') OR (fname[1]=':') THEN WITH DDA DO BEGIN  MidS(fname,1,255);  block.blk:=0;  IF fname='' THEN Cache_entry(block,True)  ELSE block.drive:=Drive_no(fname); {c_ent set for us}  offset:=0ENDELSE IF fname='%' THEN BEGIN  DDA:=user_info^.fcbs[1].DDA;  Cache_entry(DDA.block,True)ENDELSE IF fname='^' THEN BEGIN  Cache_entry(DDA.block,True);  IF error=0 THEN BEGIN    WITH cache.dir_ent[DDA.offset] DO BEGIN      DDA.block.blk:=parent_block;      DDA.offset:=parent_offset    END;    Cache_entry(DDA.block,True)  ENDENDELSE Look_up([],0,fname,DDA)END;Procedure Strip_dirs(VAR fname:min_string;VAR DDA:disc_address;  dir_name:Boolean);{Sets <error>. Corrupts <c_ent>}{Removes directory prefixes from the given filename, updating the DDAto be the DDA of the effective directory. The last component of the filenameis left in <fname> on return, but if <dir_name> is true, it will have beenused to advance the DDA. All directory names removed are checked for beingdirectories.}VARdirS:min_string;ind:Byte;BEGINerror:=0; {No errors yet}ind:=Pos('.',fname);{To implement dot abbreviation <Legal> will convert residual dots into stars hence the check for ind=Length(fname) }While (ind<>0) AND (ind<>Length(fname)) AND (error=0) DO BEGIN  {There is still a directory to strip}  dirS:=fname;  MidS(dirS,0,ind-1);  MidS(fname,ind,255); {Remove the dir name from the front of fname}  Find(dirS,DDA);  ind:=Pos('.',fname)END;IF (error=0) AND dir_name AND (Length(fname)<>0) THEN Find(fname,DDA);{ Now check that it's a directory }IF error=0 THEN Cache_entry(DDA.block,True);IF (error=0) THEN Check_dir(DDA.offset)END;BEGINEND.