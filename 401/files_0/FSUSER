{ FSUSER  File Server User Management }SEGMENT fsuser;CONST{$Ifsdecs}{$Ifsext}{$Ifsp1e}{$Ifsdire}{$Ifsdatae}{$Ifsrnde}{$IFSP3e}FUNCTION Pass_OK(VAR passS:Min_string):Boolean;{Check for valid password & set error as appropriate if invalid. Zero error otherwise}VARb:Byte;wild:Boolean;BEGINPass_OK:=False;IF NOT Legal(passS,b,wild) THEN error:=0B9HELSE IF wild THEN error:=2 {Bad wildcard}ELSE BEGIN  error:=0;  Pass_OK:=TrueENDEND;Procedure Do_logoff;VARa,b:Byte;this:user_ptr;BEGIN{If here, the user is definitely already logged on}this:=user_info;user_info:=this^.next_user; {Remove from head of chain}this^.next_user:=spare_users;spare_users:=this; {Add to free chain}{Close any open files}WITH this^ DO FOR a:=1 TO 8 DO Close(fcbs[a])END;PROCEDURE Log_off;BEGINDo_logoff;Err_message {error set in <Close>, called by <Do_logoff>}END;PROCEDURE Star_pass(VAR cmd_text:Min_string);CONSTpass_offset=10;  {Offset in password file entry to password text}VARpassS:Min_string;store:ARRAY[0..9] OF Byte;bool:Boolean;BEGINIF messag THEN Wrtln('PASS');GS_read(cmd_text,passS,True); {Get old password}IF Pass_OK(passS) THEN WITH user_info^ DO IF pass_ptr=0 THEN error:=3  ELSE IF NOT (pass_set IN flags) THEN error:=0BAH {Insuff.priv}  ELSE BEGIN  pass_blk.DDA.block.drive:=pass_drive;  bl_des.drive:=pass_drive;  Update_blk(pass_blk,pass_ptr*64);  bl_des.blk:=pass_blk.curr_blk;  Disc_rd(addr(store),10,(pass_ptr MOD ents_per_block)*64 +pass_offset,bl_des);  IF Not Match(passS,Addr(store),bool) THEN error:=0BBH  ELSE BEGIN    GS_read(cmd_text,passS,True); {get new password}    IF Pass_OK(passS) THEN BEGIN      PutS_cr(Addr(store),passS,10);      Disc_wr(addr(store),10,(pass_ptr MOD ents_per_block)*64 +pass_offset,True      ,bl_des)    END  ENDEND;Err_messageEND;PROCEDURE Read_users;CONSTmax_ents=16;VARtx:RECORD  cmd_ret_codes:Word;  qty_found:Byte;  data:ARRAY [1..max_ents] OF RECORD    station:Word;    id:ARRAY [1..10] OF Byte;    priv:Boolean  ENDEND;b:Byte;aS:Min_string;this_user:user_ptr;BEGINthis_user:=user_info;{ mainRx.data[1] is which is the 1st user to get info on}WHILE (mainRx.data[1] > 0) AND (this_user <> Nil) DO BEGIN  Dec_B(mainRx.data[1]);  this_user:=this_user^.next_userEND;IF mainRx.data[2] > max_ents THEN mainRx.data[2]:=max_ents; {mainRx.data[2] is no of ents to get}tx.qty_found:=0;WHILE (tx.qty_found < mainRx.data[2]) AND (this_user <> Nil) DO BEGIN  Inc_B(tx.qty_found);  WITH this_user^,tx.data[tx.qty_found] DO BEGIN    GetS_cr(Addr(fcbs[1].curr_blk),10,aS);    Pad(aS,10);    PutS(Addr(id),aS);  {Store in tx block}    station:=stn;    priv:=sys_priv IN flags;    this_user:=next_user  ENDEND;tx.cmd_ret_codes:=0;Ecotx(0,mainRX.reply,client_stn,addr(tx),tx.qty_found*13+3,b)END;PROCEDURE Find_user;VARtx:RECORD  cmd_ret_codes:Word;  priv:Boolean;  station:Word;END;aS:Min_string;bool:Boolean;this_user:user_ptr;BEGINGetS_cr(Addr(mainRx.data),min_size,aS); {Get name}error:=0;this_user:=user_info;WHILE error=0 DO WITH this_user^, tx DO BEGIN  IF Match(aS,Addr(fcbs[1].curr_blk),bool) THEN BEGIN    station:=stn;    priv:=sys_priv IN flags;    cmd_ret_codes:=0;    error:=1    {special flag value}  END  ELSE BEGIN    this_user:=next_user;    IF this_user=Nil THEN error:=0AEH  {User not logged on}  ENDEND;IF error=1 THEN Ecotx(0,mainRX.reply,client_stn,addr(tx),5,error)ELSE Err_messageEND;FUNCTION User_ok:BOOLEAN;VARthis,prev:user_ptr;BEGINprev:=Nil;this:=user_info;WHILE (this^.stn<>client_stn) AND (this <> Nil) DO BEGIN  prev:=this;  this:=this^.next_userEND;IF this=Nil THEN User_ok:=FalseELSE BEGIN  User_ok:=True;  IF prev<>Nil THEN BEGIN {Not already @ head}    prev^.next_user:=this^.next_user;    this^.next_user:=user_info;    user_info:=this  ENDENDEND;PROCEDURE Set_opt;CONSTboot_offset=20;  {Offset to boot option in pw file entry}BEGINWITH user_info^ DO IF pass_ptr=0 THEN error:=3  {Not in pw file}ELSE IF NOT (pass_set IN flags) THEN error:=0BAH   {Insuff.priv}ELSE WITH pass_blk DO BEGIN  DDA.block.drive:=pass_drive;  bl_des.drive:=pass_drive;  Update_blk(pass_blk,pass_ptr*64);  bl_des.blk:=curr_blk;  Disc_wr(addr(mainRx.data),1,(pass_ptr MOD ents_per_block)*64 +boot_offset  ,True,bl_des)END;Err_messageEND;{$IFSlogon}BEGINEND.