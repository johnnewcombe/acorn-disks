{ FSWILD  File Server wildcard-able operations }SEGMENT fswild;CONST{$Ifsdecs}{$Ifsext}{$Ifsp1e}{$Ifsp3e}  {For Get_num() only!}{$Ifsdatae}{$Ifsdire}PROCEDURE Delete(dir_DDA:Disc_address;VAR fname:Min_string;no_dealloc:Boolean); EXTERNAL;PROCEDURE Wild(DDA:Disc_address;VAR fname:Min_string;  PROCEDURE do_it(DDA:disc_address;VAR soft_err:Boolean) );{Sets <error>, corrupts <c_ent>}{<Do_it> sets <error>, uses <c_ent> as input param, & may corrupt it}{ Repeatedly calls <do_it> for all the files in the dir at DDA which match the fname and to which the user has owner access. c_ent assumed bashed on exit from do_it.}{** MUST NOT USE GLOBAL BLDES, as used by *ACCOUNT}VARb_list:Blk_vec;b,chain_no,ent_no:Byte;soft_err,wild,go_on,done:Boolean;w:Word;BEGINdone:=False;  {Nothing happened indicator}IF Not Legal(fname,chain_no,wild) THEN error:=204 {Bad filename}ELSE Cache_entry(DDA.block,True);IF error=0 THEN  {look at access byte to see if it's a directory}IF Land(cache.dir_ent[DDA.offset].access,D_bit)=0 THEN error:=190ELSE BEGIN  b_list:=cache.dir_ent[DDA.offset].blk_list;  REPEAT {for all the chains if wild, else just 1}    DDA.block.blk:=b_list[0];    Cache_entry(DDA.block,True);    IF error=0 THEN BEGIN      ent_no:=cache.dir_ent[0].chain[chain_no].ent_no;      go_on:=True;      WHILE (error=0) AND go_on AND (ent_no<>0) DO BEGIN   {ent_no=0 <=> end chain}        DDA.block.blk:=b_list[ent_no DIV ents_per_block];        Cache_entry(DDA.block,True);        DDA.offset:=ent_no MOD ents_per_block;        IF error=0 THEN WITH cache.dir_ent[DDA.offset] DO BEGIN          ent_no:=next_ent; {Advance to next- use DDA from now on}          IF Match(fname,Addr(name),go_on) THEN BEGIN            IF NOT Owner(account,aux_acc) THEN BEGIN              error:=0BDH;              soft_err:=True            END ELSE Do_it(DDA,soft_err);            IF error=0 THEN done:=True              {If wildcard, soft errors are ignored & matching continues}            ELSE IF soft_err AND wild THEN error:=0;          END        END      END    END;    Inc_B(chain_no)  UNTIL NOT(go_on) OR (error<>0) OR (chain_no=15) OR NOT(wild);  IF (error=0) AND (NOT done) THEN    IF wild THEN error:=1 {Nothing happened}    ELSE BEGIN      error:=214;      aux_error:=fname    ENDENDEND;PROCEDURE Star_access(VAR cmd_text:Min_string);{** THIS ROUTINE SETS <error> **}VARDDA:Disc_address;a:Byte;at_string,fname:Min_string;PROCEDURE do_acc(DDA:disc_address;VAR soft_err:Boolean);{sets <error>, corrupts <c_ent>}{On entry, c_ent gives the entry pointed to by DDA. Access is performed using outer level local variables in Star_access}BEGINImp_att(at_string,cache.dir_ent[DDA.offset].access);soft_err:=error<>0CFH;IF error=0 THEN cache.needs_writing:=TrueEND;BEGINGSread(cmd_text,fname,True);IF error=0 THEN GSread(cmd_text,at_string,False);IF error=0 THEN a:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[a].DDA;  Strip_dirs(fname,DDA,False)END;IF error=0 THEN Wild(DDA,fname,Do_acc);Err_messageEND;PROCEDURE Star_acnt(VAR cmd_text:Min_string);{** USES GLOBAL BLDES & expects it to remain through calls to Wild **}{ *ACCOUNT <filespec> [<main account>] ['('<aux account>')']Booleans set_acc,set_aux indicate whether the respective fields are present.Filespace accounts are adjusted to account for the transfer.}VARDDA:Disc_address;new_acc,new_aux,a:Byte;balance:Word;   {Current balance of new account}set_acc,set_aux:Boolean;fname:Min_string;PROCEDURE do_acnt(DDA:disc_address;VAR soft_err:Boolean);{sets <error>, corrupts <c_ent>}{On entry, c_ent gives the entry pointed to by DDA. }VARold_bal,fsize:Word;BEGINsoft_err:=False;WITH cache.dir_ent[DDA.offset] DO BEGIN  IF set_acc AND (account <> new_acc) THEN BEGIN    f_size:=Size(blk_list,exploded IN flags);    IF fsize > balance THEN BEGIN      error:=0ABH;      Hex2S(new_acc,aux_error)    END    ELSE BEGIN  {OK, so change it}      Cache_entry(DDA.block,True);      IF error=0 THEN BEGIN        balance:=balance-fsize;        Disc_rd(Addr(old_bal),2,account*2+512,bl_des);        Add_no_wrap(fsize,old_bal);        Disc_wr(Addr(old_bal),2,account*2+512,True,bl_des);        account:=new_acc;        cache.needs_writing:=True      END    END  END;  IF (error=0) AND set_aux THEN BEGIN    aux_acc:=new_aux;    cache.needs_writing:=True  ENDENDEND;BEGINGSread(cmd_text,fname,True);IF error=0 THEN BEGIN  new_acc:=Get_num(cmd_text,set_acc,16,0FFH);  IF set_acc THEN IF NOT (new_acc IN user_info^.owner) THEN error:=0BDHEND;IF error=0 THEN BEGIN  a:=Pos('(',cmd_text);  IF a=0 THEN set_aux:=False {No bracket present}  ELSE BEGIN    MidS(cmd_text,a,255);  {Remove text up to & including the bracket}    new_aux:=Get_num(cmd_text,set_aux,16,0FFH)  ENDEND;IF error=0 THEN a:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[a].DDA;  Strip_dirs(fname,DDA,False)END;IF set_acc AND (error=0) THEN BEGIN  bl_des.drive:=DDA.block.drive;  bl_des.blk:=0;  Disc_rd(Addr(balance),2,new_acc*2+512,bl_des);END;IF error=0 THEN BEGIN  Wild(DDA,fname,Do_acnt);    {NB. Write back a/c info even if an error occurs}  a:=error;  IF set_acc THEN Disc_wr(Addr(balance),2,new_acc*2+512,True,bl_des);  error:=a    {Restore original error - cleared by <Disc_wr> }END;Err_messageEND;PROCEDURE Star_rename(VAR cmd_text:Min_string);VARfname,dest:Min_string;from_DDA,to_DDA:Disc_address;done_already:SET of Byte;   {Prevents files being renamed twice}same_dir:Boolean;  {True if source & destination dirs the same}a:Byte;PROCEDURE do_ren(DDA:disc_address;VAR soft_err:Boolean);VARold_ent:Ent_type;new_DDA:Disc_address;bool:Boolean;BEGINold_ent:=cache.dir_ent[DDA.offset];IF Land(L_bit,old_ent.access) <> 0 THEN error:=0C3HELSE IF Check_open(DDA,[in_use]) THEN error:=0C2HELSE Tst_ren(dest,cmd_text,fname,Addr(old_ent.name),bool);{cmd_text contains new name}IF error=0 THEN BEGIN  IF same_dir AND Match(cmd_text,Addr(old_ent.name),bool) {*REN. fred FrEd etc}  THEN BEGIN    PutScr(Addr(cache.dir_ent[DDA.offset].name),cmd_text,10);    cache.needs_writing:=True  END  ELSE IF NOT (DDA.offset IN done_already) THEN BEGIN    IF NOT ((Land(D_bit,old_ent.access)=0) OR same_dir) THEN BEGIN {It's a dir, being renamed from dir to dir, so check for loops}      new_DDA:=to_DDA;      REPEAT        bool:=Same_DDA(DDA,new_DDA);        Cache_entry(new_DDA.block,True);        WITH cache.dir_ent[new_DDA.offset],new_DDA DO BEGIN          block.blk:=parent_block;          offset:=parent_offset        END      UNTIL bool OR (new_DDA.block.blk=0);  {Stop at root if no loop}      IF bool THEN error:=7      ELSE WITH old_ent,to_DDA DO BEGIN        parent_block:=block.blk;        parent_offset:=offset      END    END;    new_DDA:=to_DDA;    IF error=0 THEN Look_up([make,no_del],0,cmd_text,new_DDA); {Make new entry}    IF error=0 THEN WITH cache.dir_ent[new_DDA.offset] DO BEGIN      Move(old_ent.load_addr,load_addr,52);      account:=old_ent.account;      GetScr(Addr(old_ent.name),10,cmd_text);  {Get un-wildcarded name}      Delete(from_DDA,cmd_text,True);      IF same_dir THEN done_already:=done_already+[new_DDA.offset]    END  ENDEND;soft_err:=error IN [7,0C3H,0C2H,0C4H]END;BEGINdone_already:=[];a:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  GSread(cmd_text,fname,True);  IF error=0 THEN GSread(cmd_text,dest,True);  IF error=0 THEN BEGIN    from_DDA:=user_info^.fcbs[a].DDA;    to_DDA:=from_DDA;    Strip_dirs(dest,to_DDA,False);    IF error=0 THEN Strip_dirs(fname,from_DDA,False);    IF from_DDA.block.drive<>to_DDA.block.drive THEN error:=0B0H;    same_dir:=Same_DDA(from_DDA,to_DDA);    IF error=0 THEN Wild(from_DDA,fname,Do_ren)  ENDEND;Err_messageEND;BEGINEND.