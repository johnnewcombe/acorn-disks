{ FSP2  File Server Procedures & Functions }SEGMENT fsp2;CONSTaborted='Aborted';{$Ifsdecs}{$Ifsext}{$Ifsp1e}{$Ifsdire}{$Ifsdatae}{$Ifsrnde}{$Ifswilde}PROCEDURE Load_protocol(VAR fcb1:FCB; bytes_left:Dbl_word);{ Send file data to client from current pointer position in file given by FCB. <bytes left> is, on entry, the number of bytes to send. Pointer is updated on exit. Bytes left must not be =0 (ie check it before calling)}VARbig_buff:Buffer;bl_des:Block_descrip;p:dbl_word;w,lump_size,index,pkt_size:Word;a:Byte;abort:Boolean;BEGINMake4(p,fcb1.ptr);bl_des.drive:=fcb1.DDA.block.drive;abort:=False;IF error=0 THEN WHILE NOT (abort OR (bytes_left=0)) DO BEGIN  pkt_size:=Min_D(bytes_left,buff_size);  index:=1;  WHILE (error=0) AND (index<=pkt_size) DO BEGIN    bl_des.blk:=fcb1.curr_blk;    lump_size:=Min_W(pkt_size-index+1,blk_size-(p MOD blk_size));                {index starts at 1 ^       ^ amount left of this blk}    IF bl_des.blk=0  {If Sparse file, send zeros}    THEN FOR w:=index TO index+lump_size-1 DO big_buff[w]:=0    ELSE Disc_rd(Addr(big_buff[index]),lump_size,p MOD blk_size,bl_des);    p:=p+lump_size;    index:=index+lump_size;    IF error=0 THEN Update_blk(fcb1,p) {sets <error>}  END;  bytes_left:=bytes_left-pkt_size;  Ecotx(rx_seq,mainRX.envir.URD,client_stn,addr(big_buff),pkt_size,a);      {data port in URD slot for no particular reason!}  IF a<128 THEN abort:=TRUEEND;IF abort AND messag THEN Wrtln(aborted)END;PROCEDURE Save_protocol(VAR fcb1:FCB; bytes_left:Dbl_word;pre_read:Boolean);{ Send file data to client from current pointer position in file given by FCB. <bytes left> is, on entry, the number of bytes to send. Pointer is updated on exit. Bytes left must not be =0 (ie check it before calling) pre_read indicates whether blocks which already exist should be pre-read (ie False for SAVE, True otherwise)}CONSTwait_count=65535;VARbig_buff:Buffer;bl_des:Block_descrip;p:dbl_word;a,RxCB:Byte;w,pkt_size,index,lump_size:Word;new,abort:Boolean;BEGINMake4(p,fcb1.ptr);bl_des.drive:=fcb1.DDA.block.drive;big_buff[1]:=0; {std Tx header in big_buff}big_buff[2]:=0;big_buff[3]:=data_port; {constant defined in file FSDECS}big_buff[4]:=0; {lo}big_buff[5]:=buff_size DIV 256; { buff_size MUST be an integer no. of blocks}RXset(rxcb,data_port,client_stn,Addr(big_buff),buff_size); {must be ready to Rx immediately after transmission}EcoTx(rx_seq,mainRX.reply,client_stn,Addr(big_buff),5,a);abort:= (a<128);WHILE NOT abort AND (bytes_left>0) DO BEGIN  w:=wait_count;  REPEAT    w:=w-1;    abort:=w=0;  UNTIL (RXread(RXcb,a,a,index,pkt_size) OR abort);  {index is scratch value}  IF NOT abort THEN BEGIN    bytes_left:=bytes_left-pkt_size;    index:=1;    WHILE (index <= pkt_size) AND (error=0) DO BEGIN      new:=fcb1.curr_blk=0;  {new blk req'd}      IF new THEN New_blk(fcb1);      bl_des.blk:=fcb1.curr_blk;      lump_size:=Min_W(pkt_size-index+1,blk_size-(p MOD blk_size));                  {index starts at 1 ^       ^ amount left of this blk}      IF error=0 THEN Disc_wr(Addr(big_buff[index]),lump_size,p MOD blk_size        ,pre_read AND(NOT new),bl_des);      index:=index+lump_size;      p:=p+lump_size;      IF error=0 THEN Update_blk(fcb1,p) {sets <error>}    END;    IF bytes_left>0 THEN BEGIN      RXset(rxcb,data_port,client_stn,Addr(big_buff),buff_size);      EcoTx(0,mainRx.envir.URD,client_stn,0,1,a);      IF a<128 THEN abort:=True  {ack port in URD slot}    END  ENDEND;IF abort THEN BEGIN  IF messag THEN Wrtln(aborted);  Del_rx(RXcb)ENDEND;PROCEDURE Star_info(VAR cmd_text:min_string);VARfname:Min_string;big_buff:ARRAY[1..90] OF Byte;a:Byte;DDA:disc_address;BEGINGSread(cmd_text,fname,True); {deal with quotes etc.}a:=Fcb_no(mainRx.envir.CSD); {sets error}IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[a].DDA;  Strip_dirs(fname,DDA,False);  IF error=0 THEN Find(fname,DDA)END;IF error=0 THEN BEGIN  Info_string(cache.dir_ent[DDA.offset],addr(big_buff[3]),a);  big_buff[a+3]:=CR; {Note large fudge to suit client screen format!}  big_buff[a+4]:=128;  {Terminator - length comes back in a}  big_buff[1]:=4;  {Std. Tx header}  big_buff[2]:=0;  Eco_tx(0,mainRX.reply,client_stn,addr(big_buff),a+4,a);END ELSE Err_messageEND; PROCEDURE Star_delete(VAR cmd_text:min_string);VARfname:Min_string;DDA:Disc_address;b:Byte;BEGINGSread(cmd_text,fname,True); {deal with quotes etc.}b:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[b].DDA;  Strip_dirs(fname,DDA,False)END;IF error=0 THEN Delete(DDA,fname,[]);Err_messageEND;PROCEDURE Del_object;VARtx:RECORD  cmd_rtn_codes:Word;  load:Dbl_word;  exec:Dbl_word;  ext:Three_byteEND;fname:Min_string;dir_DDA,DDA:Disc_address;wild:Boolean;a:Byte;BEGINGetScr(addr(main_Rx.data),min_size,fname);a:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[a].DDA;  Strip_dirs(fname,DDA,False);  dir_DDA:=DDAEND;IF error=0 THEN BEGIN  Look_up([],0,fname,DDA);  IF error=0 THEN BEGIN    Move(cache.dir_ent[DDA.offset].load_addr,tx.load,11);    Delete(dir_DDA,fname,[no_wildcard])  ENDEND;IF error<>0 THEN Err_messageELSE BEGIN  tx.cmd_rtn_codes:=0;  EcoTx(0,mainRx.reply,client_stn,Addr(tx),13,a)ENDEND;PROCEDURE Load;VARfname:min_string;fcb1:Fcb;bytes_left:dbl_word;tx:RECORD  cmd_ret_codes:Word;  data:ARRAY[1..14] OF Byte;  {catalogue info MOVE'd in here}  name:ARRAY[1..13] OF ByteEND;a:Byte;BEGINIF messag THEN BEGIN  StnS(client_stn,fname);  Pad(fname,15);  Wrt(fname)END;GetScr(Addr(mainRX.data),min_size,fname);IF messag THEN BEGIN  Wrt('Load :');  Wrtln(fname)END;Open_in(fname,fcb1,False);IF error=0 THEN IF Check_flags(fcb1,[R])THEN WITH cache.dir_ent[fcb1.DDA.offset] DO BEGIN    {Move load,execute,length,access,date,real fname  to tx buffer}  Move(load_addr,tx.data,14);  GetScr(addr(name),10,fname);  Pad(fname,12);   {FUDGE for client screen format}  PutS(addr(tx.name),fname);  {Dubious Jezz format??}  tx.name[13]:=128; {Delimit it}  Make4(bytes_left,extent);  tx.cmd_ret_codes:=14;   {cmd_code=14 in (not very) std. TX header}  Ecotx(0,mainRX.reply,client_stn,Addr(tx),29,a)END;IF (error=0) AND (bytes_left<>0) THEN Load_protocol(fcb1,bytes_left);Err_messageEND;PROCEDURE Save;CONSTwait_count=65535;VARtx:RECORD  cmd_ret_codes:Word;  access:Byte;  date:Date_typeEND;bytes_left:dbl_word;fname:Min_string;a:Byte;fcb1:fcb;BEGINIF messag THEN BEGIN  StnS(client_stn,fname);  Pad(fname,15);  Wrt(fname)END;getScr(Addr(mainRX.data[12]),min_size,fname);bytes_left:=0;       { Zero HI BYTE of bytes left before move!}Move(mainRx.data[9],bytes_left,3);  {NB. in save, client says how big file is.}IF messag THEN BEGIN  Wrt('SAVE :');  Wrtln(fname)END;Open_out(fname,fcb1,bytes_left);IF error=0 THEN BEGIN  WITH cache.dir_ent[fcb1.DDA.offset] DO BEGIN    Move(mainRx.data[1],load_addr,8); {NB exec addr also copied}    tx.access:=access;   {save access,date for final reply}    tx.date:=creation;    tx.cmd_ret_codes:=0  END;  IF bytes_left>0 THEN Save_protocol(fcb1,bytes_left,False)  ELSE EcoTx(0,mainRx.reply,client_stn,Addr(tx),5,a); {dummy port, block size}END;IF error<>0 THEN Err_messageELSE EcoTx(0,mainRx.reply,client_stn,Addr(tx),5,a)END;BEGIN {Dummy block}END.