{  FS  File Server main code }PROGRAM Fs;CONST{$Ifsdecs}VARprint_space,print_ptr,x:Word;  {<print_space> points to free space in the print buffer, <print ptr> points   to the next Byte to be printed}a,block_no,print_block,next_seq,b:Byte;ch:Char;print_buff:ARRAY[1..print_size] OF Byte;aS:Min_string;{$Ifsext}{$Ifsp1e}{$Ifsp2e}{$Ifsp3e}{$Ifsp4e}{$Ifsusere}{$Ifsdatae}{$Ifsrnde}FUNCTION System:Boolean;{ check if user is sys-priv. }BEGINSystem:=(sys_priv IN user_info^.flags)END;Procedure Print(var txt:Min_string);{Procedure to place contents of string into print buffer. If buffer doesnot have enough free space, it is purged first}VARa:Byte;BEGINWHILE ((print_space-print_ptr+print_size)MOD print_size) {no of chrs in buffer}  > (print_size-length(txt)) DO BEGIN  List_OT(print_buff[print_ptr]);  IF print_ptr=print_size THEN print_ptr:=1 ELSE Inc_W(print_ptr)END;For a:=1 TO length(txt) DO BEGIN  print_buff[print_space]:=ord(txt[a]);  IF print_space=print_size THEN print_space:=1  ELSE Inc_W(print_space)ENDEND;Procedure Instructions;BEGINVer_msg;P_crlf;Wrtln('Operator commands :');P_crlf;Wrtln('Esc - allow discs to be changed');Wrtln('D   - debug off/on');Wrtln('F   - flush printer buffer');Wrtln('M   - messages off/on');Wrtln('Q   - quit');P_crlfEND;Procedure Finish_print;VARdummy:Byte;BEGINPrint(end_text);print_active:=false;IF messag THEN BEGIN  StnS(client_stn,aS);  Pad(aS,15);  Wrt(aS);  Wrtln('End print')END; {Now acknowledge final packet}Ecotx(rx_seq,print_port,print_stn,addr(printRx),1,dummy);print_stn:=0 {Only non-0 if we are talking to someone}END;BEGIN {Main block}cache.which_blk.drive:=255; {Out of range drive no. <=> not in use}cache.needs_writing:=False;print_ptr:=1;print_space:=1;print_stn:=0; {Only non-0 if we are talking to someone}time_out:=0;print_active:=false;print_waiting:=false; {If TRUE, we have an RxCB open}pre_text:='';post_text:=Concat(chr(13),chr(10)); {CR,LF}banner:='***  SJ Research Econet ';no_banner:=false;end_text:=chr(12);spare_users:=Nil;FOR a:=1 TO no_users DO BEGIN  Heap(user_info,Sizeof(user_descrip));  WITH user_info^ DO BEGIN    FOR b:=1 TO 8 DO fcbs[b].flags:=[];  {Not in_use,write access etc.}    next_user:=spare_users;    spare_users:=user_info  ENDEND;user_info:=Nil;debug:=False;messag:=True;Ecoini;Inilow;Ini_clk;Wrtln(chr(17)); {ctrl-Q disables page wait on RML}Instructions;Init_disc;Wrtln('Ready');REPEAT {Main loop}    Rxset(blockno,cmdport,0,Addr(mainRX),min_size+5);  WHILE NOT Rxread(blockno,rx_seq,b,client_stn,x) DO BEGIN{operator commands}    IF Inkey(ch) THEN CASE Land(Ord(ch),5FH) OF       27:BEGIN Wrtln('Esc-');            Empty_cache;            Init_disc;            Wrtln('Ready')          END;       68:BEGIN            debug:=NOT debug;            Wrt('debug ');            IF debug THEN Wrtln('On') ELSE Wrtln('Off')          END;       70:BEGIN {Flush print buff}            Wrtln('F');            print_ptr:=1;            print_space:=1          END;       77:BEGIN            messag:=NOT messag;            Wrt('messages ');            IF messag THEN Wrtln('On') ELSE Wrtln('Off')          END;       81:BEGIN Empty_cache; Fs_exit END; {exit to outside world}     OTHERWISE Instructions    END; {of Case}{Update RTC copy in RAM}    Get_clk;{Empty caches}    IF (cache_time=10) AND (cache.needs_writing) THEN BEGIN      Disc_wr(Addr(cache.data),block_size,0,False,cache.which_blk);      cache.needs_writing:=False    END;    IF cache_time=0 THEN  C_idle {Purge EXTERNAL cache}    ELSE Dec_W(cache_time);{Try to empty print buffer}    WHILE (print_ptr<>print_space) AND List_ST DO BEGIN      List_OT(print_buff[print_ptr]);      IF print_ptr=print_size THEN print_ptr:=1  {wrap round buffer}      ELSE Inc_W(print_ptr)    END;{Try to fill print buffer}    IF print_waiting THEN IF      RXread(print_block,rx_seq,b,client_stn,blk_len) THEN BEGIN      print_waiting:=FALSE;      IF print_active OR (client_stn=print_stn) THEN BEGIN         {Either still printing or timed out & re-started}        print_active:=TRUE;        IF Land(rx_seq,1)=next_seq THEN BEGIN          next_seq:=Land(succ(next_seq),1); {Increment sequence no}          IF (NOT old_type) AND (Land(rx_seq,4)=4) THEN blk_len:=pred(blk_len);            {Control byte indicates last block, but there is a             spurious ctrl-C at the end as well }          a:=1;          WHILE a<=blk_len DO BEGIN             {Transfer data to output buffer}            IF old_type AND (printRx[a]=3) THEN Finish_print             {Old type block terminator}            ELSE BEGIN {normal byte}              print_buff[print_space]:=printRx[a];              IF print_space=print_size THEN print_space:=1               ELSE print_space:=succ(print_space)            END;            a:=Succ(a)          END; {while}          IF (NOT old_type) AND (Land(rx_seq,4)=4) THEN Finish_print           {Usual terminator}        END      END ELSE BEGIN {Not active, so should be log-on}        IF print_stn<>0 THEN Print(end_text);   {Terminate timed-out user}        print_stn:=client_stn;        old_type:=printRx[1]<>0; {Character sent indicates protocol}        next_seq:=Land(succ(Rx_seq),1); {Initialise sequence no (=0 or =1) }        IF NOT no_banner THEN Print(pre_text);        Print(banner);        StnS(client_stn,aS);        IF messag THEN BEGIN          Pad(aS,15);  {statID text}          Wrt(aS);          Wrt('Printing - ');          IF old_type THEN Wrt('Old') ELSE Wrt('New');          Wrtln(' protocol')        END;        IF NOT no_banner THEN BEGIN          aS:=Concat(' ***  Station ',aS);  {aS still has stn. no in decimal}          Print(aS);          aS:=' ***';          Print(aS);          Print(post_text)        END;        print_active:=TRUE      END    END;    IF (NOT print_waiting) AND      (((print_space-print_ptr+print_size)MOD print_size)      < (print_size-prx_size)) THEN BEGIN      { There is room in the buffer for another recieve block }      print_waiting:=TRUE;      IF print_active THEN       Rxset(print_block,print_port,print_stn,addr(printRx),prx_size)      ELSE Rxset(print_block,print_port,0,addr(printRx),prx_size);       { Acknowledge if appropriate }      IF print_active THEN Ecotx(rx_seq,print_port,print_stn,        addr(printRx),1,b);      time_out:=tim_delay    END;    IF print_active THEN BEGIN      IF print_waiting THEN Dec_W(time_out);      IF time_out=0 THEN BEGIN        Delrx(print_block);        print_waiting:=False;  {Allows another rxblk to set itself up}        IF messag THEN Wrtln('Print timeout');        print_active:=false      END    END  END;{ Drops through here when a packet arrives on the FS command port }  IF debug THEN BEGIN    Wrt('FN=');    Dec_S(mainRX.FN,aS);    Wrt(aS);    Wrt(' Stn');    StnS(client_stn,aS);    Wrtln(aS)  END;   {Check if logged on or *cmd which could be *I AM }  IF (mainRx.fn=0) OR User_ok THEN  CASE mainRX.fn OF    0:Starcmd;    1:Save;    2:Load;    3:Cat;    5:Load;    6:X_open;    7:X_close;    8:B_get;    9:B_put;   10:MB_get;   11:MB_put;   12:Rd_rnd_info;   13:Wr_rnd_info;   14:Disc_info;   15:Read_users;   16:Read_time;   17:Eof;   18:Read_info;   19:Write_info;   20:Del_object;   21:User_envir;   22:Set_opt;   23:Log_off;   24:Find_user;   4,25:EcoTx(0,mainRx.reply,client_stn,Ver_adr,Ver_len,error);{version string}   26:Free_space;   28:Set_time;   64:Acct_space;   OTHERWISE BEGIN error:=133; Err_message END;  END {of case}  ELSE BEGIN error:=191; Err_message END; {'Who are U?' }  cache_time:=cache_del { Delay before writing cache }UNTIL False;END.