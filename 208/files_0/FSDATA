{ FSDATA  File Server data management }SEGMENT fsdata;CONST{$Ifsdecs}{$Ifsext}{$IFSP1E}{$Ifsrnde}{$IFSDIRE}FUNCTION Same_blk(a,b:Block_descrip):Boolean;BEGINSame_blk:=(a.blk=b.blk) AND (a.drive=b.drive)END;PROCEDURE Cache_entry(desired:block_descrip;read_in:Boolean);{Sets <c_ent>,<error>}{ Either finds the required block in the cache or allocates a new entry. If a new entry is required, the block will only be brought in off disc if the <read_in> parameter is TRUE (it would be false for a block which is going to be re-written eg. if the block has only just been allocated) If <read_in> is false, then the block data is zeroed before returning.}VARw:Word;BEGINerror:=0;IF Same_blk(desired,cache.which_blk) THEN BEGIN ENDELSE IF desired.drive=255 THEN error:=0C8HELSE WITH cache DO BEGIN  IF needs_writing THEN BEGIN    Disc_wr(Addr(data),block_size,0,False,which_blk);    needs_writing:=FALSE  END;  IF read_in THEN BEGIN    Disc_rd(Addr(data),block_size,0,desired);    IF error<>0 THEN desired.blk:=255   {drive=255 <=> cache entry empty}  END  ELSE FOR w:=0 TO M1block_size DO data[w]:=0;  which_blk:=desiredENDEND;PROCEDURE Empty_cache;{Empties both internal & external caches in preparation for exit or changing discs}VARa,b:Byte;this_user:user_ptr;BEGINthis_user:=user_info;WHILE this_user <> Nil DO WITH this_user^ DO BEGIN  FOR b:=1 TO 8 DO BEGIN    IF W IN fcbs[b].flags THEN Close(fcbs[b]);  {close output files}    fcbs[b].DDA.block.drive:=255  END;  this_user:=next_userEND;WITH cache DO BEGIN  IF needs_writing THEN BEGIN    Disc_wr(Addr(data),block_size,0,False,which_blk);    needs_writing:=FALSE  END;  which_blk.blk:=255END;C_empty;  {Empty external cache}END;PROCEDURE Un_count;{ Un counts the block described by global <bl_des> }BEGINAlloc(bl_des);Dec_W(free_bl[bl_des.drive])END;PROCEDURE Scan_file(b_list:Blk_vec;exploded:Boolean);{Un counts the blocks occupied by a file. <b_list> is 2nd half of dir ent <exploded> indicates whether this is in fact an exploded file, in which case, all the blocks are loaded & scanned.}VARa:Byte;b:Word;BEGINFOR a:=0 TO 15 DO IF b_list[a]<>0 THEN BEGIN {=0 => not allocated}  bl_des.blk:=b_list[a];  Un_count;  IF exploded THEN BEGIN    Cache_entry(bl_des,True);    IF error=0 THEN WITH cache    DO FOR b:=0 TO M1words_per_block DO BEGIN      bl_des.blk:=EB_list[b];      IF bl_des.blk<>0 THEN Un_count    END  ENDENDEND;PROCEDURE Scan_dir(b_list:blk_vec);{Scans (Recursively!) a directory tree, allocating the blocks which it findsto be already in use. On entry, we have the block list of a dir.These blocks have not yet been counted, so we count them as we scan them,observing the entries which may be files or other dirs.}VARent_off,blk_off:Byte;BEGINent_off:=1; {entry 0 always exists and is reserved, so start at 1}FOR blk_off:=0 TO 15 DO IF b_list[blk_off]<>0 THEN BEGIN  bl_des.blk:=b_list[blk_off];  Un_count;  Cache_entry(bl_des,TRUE);  IF error=0 THEN REPEAT    WITH cache.dir_ent[ent_off] DO  {Check if deleted}    IF next_ent<>(ent_off+blk_off*ents_per_block) THEN BEGIN      IF Land(access,D_bit)=0      {'D' bit in access byte}      THEN Scan_file(blk_list,exploded IN flags)      ELSE Scan_dir(blk_list);      bl_des.blk:=b_list[blk_off];      Cache_entry(bl_des,TRUE)  {c_ent is out of date}    END;    ent_off:=Succ(ent_off)  UNTIL ent_off=ents_per_block;  ent_off:=0  {For all subsequent blocks, first ent is not reserved}ENDEND;PROCEDURE Init_disc;VARch:Char;b_list:Blk_vec;discno:Byte;BEGINWrt('No. of discs :');REPEAT  REPEAT UNTIL Inkey(ch);  IF (ch='d') OR (ch='D') THEN BEGIN    debug:=NOT debug;    IF debug THEN Wrtln('d ON') ELSE Wrtln('d OFF')  ENDUNTIL (ch='1') OR (ch='2');Wrtln(ch);no_discs:=Ord(ch)-49;  {not really, any more. more like max_drive}Inidsk(no_discs);WHILE error<>0 DO BEGIN  Wrtln('Check discs then press space');  REPEAT REPEAT UNTIL Inkey(ch) UNTIL ch=' ';  Inidsk(no_discs)END;FOR discno:=0 TO no_discs DO BEGIN  bl_des.drive:=discno;  bl_des.blk:=0;   {Look @ root}  Cache_entry(bl_des,True);  Uncount;  Scan_dir(cache.dir_ent[0].blk_list); {Main dir. structure}  bl_des.blk:=0;  Cache_entry(bl_des,True);  WITH cache.dir_ent[2] DO Scan_file(blk_list,exploded IN flags) {passwd file}END;messag:=TrueEND;BEGINEND.