PROGRAM FSUTIL;CONSTcache_size=30; {number of blocks in megabuffer}blk_size=1024;block_size=blk_size;ents_per_block=16;words_per_block=512;M1ents_per_block=15;  {Minus 1!!}M1words_per_block=511;M1block_size=1023;cr=13;verified='Verify complete';D_bit=32;TYPEDbl_word=Integer;Byte=0..255;Three_byte=ARRAY [1..3] OF Byte;Word=0..65535;Nibble=0..15;Block_descrip=RECORD  drive:Byte;    {Often set to 255 to indicate disc changed.                  If so, it will be caught at the cache request stage}  blk:Word    {Block number. Each block is <blk_size> bytes}END;Date_type=RECORD  day:Byte;  mth_yr:ByteEND;Short_time=RECORD  hrs:Byte;  mins:ByteEND;Short_td=RECORD  date:Date_type;  time:Short_timeEND;Disc_address=RECORD  block:block_descrip;  offset:Byte          {64 byte Offset in block : Origin is ZERO}END;dir_flags=(exploded,xx1,xx2,xx3,xx4,xx5,xx6,xx7);blk_vec=ARRAY [0..15] OF Word;ent_type=RECORD CASE Byte OF  1:(bit_map:SET OF Byte;    chain:ARRAY [0..14] OF RECORD      ents_in_chain:Byte;      ent_no:Byte    END;    spare:Word    ); 2:(Dum2:ARRAY [0..11] OF Byte;    def_access:Byte;    cycle_no:Byte;    parent_block:Word;    parent_offset:Byte;    no_of_ents:Byte;    dum1:ARRAY [18..63] OF Byte; {Items common to both}    );3:(account:Byte;    name:PACKED ARRAY[1..10] OF Char;    next_ent:Byte;    load_addr:Dbl_word;    exec_addr:Dbl_word;    extent:Three_byte;    access:Byte;    creation:Date_type;    update:Short_td; {Time & date - no secs }    Aux_acc:Byte;    flags:SET OF dir_flags;    blk_list:blk_vec    )END;c_ent=RECORD  CASE Byte OF    1:(data:ARRAY [0..M1block_size] OF Byte);    2:(root:ent_type;      SJ_msg:PACKED ARRAY [1..23] OF Char;      disc_name:PACKED ARRAY [1..10] OF Char;      DS_flag:Byte;      disc_size:Word;      spare:ARRAY[100..127] OF Byte;      pass_ent:ent_type      );    3:(dir_ent:ARRAY [0..M1ents_per_block] OF ent_type);    4:(Words:Array[0..M1words_per_block] OF Word)END;COMMONch:Char;cache:ARRAY[1..cache_size] OF C_ent;error:Byte;debug,two_sid,stop:Boolean;{ Disc Routines.Dk_init must be called before any R/W activity. Chk_SJ reads block 0 into thecache, checks for the presence of the SJ string, and sets up <two_sid>.Globals <error> and <two_sid> are used. <error> is set on exit to indicateany error, although an error message will have already been displayed.<two_sid> is True on entry if the disc is to be treated as double sided.Format takes drive nos. in the range 0..3, treating the two sides separarately.}PROCEDURE Format(drive,no_tracks:Byte); EXTERNAL;PROCEDURE Verify(drive,no_tracks:Byte); EXTERNAL;PROCEDURE Rw_blk(read:Boolean; VAR buffer:C_ent; disc:Byte; blkno:Word); EXTERNAL;FUNCTION Five_in:Boolean; EXTERNAL; {return 5"/8" version}PROCEDURE Ver_msg; EXTERNAL;PROCEDURE Chk_SJ; EXTERNAL;PROCEDURE Dk_init; EXTERNAL;PROCEDURE FS_exit; EXTERNAL;FUNCTION Inkey(VAR ch:Char):Boolean; EXTERNAL;FUNCTION Get:Char;VARch:Char;BEGINREPEAT UNTIL Inkey(ch);Get:=chEND;FUNCTION Yes_no:Boolean;VARch:Char;yes:Boolean;  {temp result store}BEGINWrite(' (Y/N):');ch:=Get;yes:=(ch <> 'N') AND (ch <> 'n');IF yes THEN Writeln('Yes') ELSE Writeln('No');Yes_no:=yesEND;FUNCTION Get_num(default,max:Word):Word;VARdone_something:Boolean;ch:Char;value:Dbl_word;BEGINREPEAT {until legal}  done_something:=False;  value:=0;  REPEAT {until <return>}    ch:=Get;    IF ch IN ['0'..'9'] THEN BEGIN      done_something:=True;      Write(ch);      value:=(value*10)+Ord(ch)-Ord('0')    END    ELSE IF (Ord(ch)=127) OR (Ord(ch)=8) THEN BEGIN {Backspace}      Write(Chr(8),' ',Chr(8));      value:=value DIV 10    END  UNTIL (Ord(ch)=cr) OR (value > 999999);  IF value>max THEN BEGIN    Writeln;    Writeln('Must not be more than ',max:1);    Write(' Try again :')  ENDUNTIL value<=max;IF done_something THEN Get_num:=value ELSE BEGIN  Get_num:=default;  Write(default:1)END;Writeln;END;FUNCTION Get_hex:Byte;VARch:Char;value:Byte;BEGINvalue:=0;REPEAT {until <return>}  ch:=Get;  IF (Ord(ch)=127) OR (Ord(ch)=8) THEN BEGIN {Backspace}    Write(Chr(8),' ',Chr(8));    value:=value DIV 16  END  ELSE IF value < 16 THEN BEGIN    IF ch IN ['0'..'9'] THEN BEGIN      Write(ch);      value:=(value*16)+Ord(ch)-Ord('0')    END    ELSE IF ch IN ['A'..'F'] THEN BEGIN      Write(ch);      value:=(value*16)+Ord(ch)-Ord('A')+10    END    ELSE IF ch IN ['a'..'f'] THEN BEGIN      Write(ch);      value:=(value*16)+Ord(ch)-Ord('a')+10    END  ENDUNTIL Ord(ch)=cr;Get_hex:=value;WritelnEND;PROCEDURE Get_blk0;VARb:Byte;BEGINREPEAT  Writeln('Check discs & press space when ready');  REPEAT UNTIL Get=' ';  Chk_SJ;  {updates cache,<two_sid>}  IF error=1 THEN Writeln('Not a file server format disc')UNTIL error=0;Writeln;Write('Disc Name = ');b:=1;REPEAT  Write(cache[1].disc_name[b]);  b:=Succ(b)UNTIL (b>10) OR (cache[1].disc_name[b-1] = Chr(13));Writeln;Writeln('Two sided =',two_sid);Writeln('Disc size =',cache[1].disc_size:5,'K')END;PROCEDURE Get_disc_name;VARch:Char;b:Byte;BEGINWrite('disc name (max 10 characters) :');b:=0; {Offset in name - cache is used as i/p buffer}REPEAT  ch:=Get;  IF (ch=Chr(127)) OR (ch=Chr(8)) THEN BEGIN {Del or backspace}    IF b>0 THEN BEGIN            {Can't delete @ start of line}      Write(Chr(8),' ',Chr(8));  {Erase char from screen}      b:=Pred(b)    END  END  ELSE IF (b<10) THEN BEGIN    cache[1].data[87+b]:=Ord(ch);    IF Ord(ch) > 32 THEN Write(ch)    ELSE Write('.');  {Don't echo ctrl chars or spaces}    b:=Succ(b)  ENDUNTIL ch=Chr(13);WritelnEND;{$Ifsutil1}