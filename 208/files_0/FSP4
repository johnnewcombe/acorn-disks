{ FSP4  File Server Procedures & Functions }SEGMENT Fscat;CONST{$Ifsdecs}{$Ifsext}{$Ifsp1e}{$Ifsdire}{$Ifsdatae}PROCEDURE Read_info;VARmainTx:stdTx;fname:min_string;DDA:Disc_address;a,arg:Byte;BEGINarg:=mainRX.data[1];GetScr(Addr(mainRX.data[2]),min_size-1,fname);a:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[a].DDA;  Strip_dirs(fname,DDA,False);  IF error=0 THEN Find(fname,DDA);  mainTx.data[1]:=0FFH; {File exists flag}  IF (arg<>6) AND (error=0D6H) THEN BEGIN {Not found, so clear flag (no error)}    error:=0;    MainTx.data[1]:=0; {File exists flag (it doesn't)}    a:=3 {Tx size}  END ELSE IF error=0 THEN WITH cache.dir_ent[DDA.offset] DO BEGIN    IF Land(access,D_bit)=0 THEN mainTx.data[1]:=1 ELSE mainTx.data[1]:=2;                                {exists/is a file/dir flag}    CASE arg OF    1:BEGIN { creation date }      Move(creation,mainTx.data[2],2);      a:=5  {number of bytes to transmit}      END;    2:BEGIN { Load, execute addresses }      Check_not_dir(DDA.offset);      Move(load_addr,mainTx.data[2],8);      a:=11  {number of bytes to transmit}      END;    3:BEGIN {'Size' (really means extent) }      Check_not_dir(DDA.offset);      Move(extent,mainTx.data[2],3);      a:=6  {number of bytes to transmit}      END;    4:BEGIN { Access byte }      mainTx.data[2]:=access;      a:=4      END;    5:BEGIN { All info }      Move(load_addr,mainTx.data[2],14);      a:=17      END;    6:BEGIN      Check_dir(DDA.offset);      GetScr(Addr(name),10,fname);      Pad(fname,10);      WITH mainTx DO BEGIN        PutS(addr(data[4]),fname);        data[1]:=0; {Spurious byte set to 0 for uniformity}        data[2]:=0;        data[3]:=10; {required by BBC NFS!}        IF Owner(account,aux_acc) THEN data[14]:=0 {Owner access}        ELSE data[14]:=255; {Public}        data[15]:=cache.dir_ent[DDA.offset].cycle_no;      END;      a:=17  {Tx size}      END;      OTHERWISE error:=4FH    END {of case}  ENDEND;IF error<>0 THEN Err_messageELSE BEGIN  WITH mainTx DO BEGIN    rtncode:=0;    cmd:=0  END;  Ecotx(0,mainRX.reply,client_stn,addr(mainTX),a,a)ENDEND;PROCEDURE Write_info;VARmainTx:stdTx;fname:min_string;DDA:Disc_address;a,arg:Byte;BEGINerror:=0;arg:=mainRX.data[1];CASE arg OF  1:a:=11;  2,3:a:=6;  4:a:=3;  OTHERWISE error:=04FHEND;IF error=0 THEN GetScr(Addr(mainRX.data[a]),min_size-1,fname);a:=Fcb_no(mainRx.envir.CSD);IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[a].DDA;  Strip_dirs(fname,DDA,False);  IF error=0 THEN Find(fname,DDA);  IF error=0 THEN WITH cache.dir_ent[DDA.offset] DO CASE arg OF    1:BEGIN { load,exec,access }      Check_not_dir(DDA.offset);      IF error=0 THEN        Set_att(access,Land( 255-D_bit-X_bit ,mainRX.data[10]));                  {Mask out dir & X bits in case someone sets them}      IF error=0 THEN Move(mainRx.data[2],load_addr,8)      END; {Set_att can set error}    2:BEGIN { Load address }      Check_not_dir(DDA.offset);      IF error=0 THEN Move(mainRx.data[2],load_addr,4)      END;    3:BEGIN { Execute addr }      Check_not_dir(DDA.offset);      IF error=0 THEN Move(mainRx.data[2],exec_addr,4)      END;    4:{ Set access }      Set_att(access,Land( 255-D_bit-X_bit ,mainRX.data[2]))        {Mask out dir & X bits in case someone sets them}   END {of case}END;IF error=0 THEN cache.needs_writing:=True;Err_messageEND;PROCEDURE User_envir;VARmainTx:stdTx;aS:min_string;DDA:Disc_address;lib_no,csd_no,a:Byte;BEGINmaintx.cmd:=0;maintx.rtncode:=0;csd_no:=Fcb_no(mainRx.envir.CSD);lib_no:=2; {SHOULD BE Fcb_no(mainRx.envir.LIB) BUT BBC DOES NOT ALWAYS SEND HANDLE!!}IF error=0 THEN BEGIN  DDA:=user_info^.fcbs[csd_no].DDA;  Cache_entry(DDA.block,True);  IF error=0 THEN BEGIN    GetScr(Addr(cache.dir_ent[DDA.offset].Name),10,aS);    Pad(aS,10); {pad out CSD name}    PutS(Addr(mainTX.data[18]),aS);    DDA.block.blk:=0; {Get disc name out of blk 0}    Cache_entry(DDA.block,True);    IF error=0 THEN BEGIN      GetScr(Addr(cache.data[87]),10,aS);      maintx.data[1]:=16; {Length of disc name}      Pad(aS,16);      PutS(Addr(mainTX.data[2]),aS);      DDA:=user_info^.fcbs[lib_no].DDA;      Cache_entry(DDA.block,True);      IF error=0 THEN BEGIN        GetScr(Addr(cache.dir_ent[DDA.offset].Name),10,aS);        Pad(aS,10); {pad out LIB name}        PutS(Addr(mainTX.data[28]),aS);        Ecotx(0,mainRX.reply,client_stn,Addr(mainTX),39,a)      END    END  ENDEND;IF error<>0 THEN Err_messageEND;{$IFSCAT}PROCEDURE Disc_info;VARblk0:block_descrip;a:Byte;disc_name:Min_string;Tx:RECORD  cmd_ret_codes:Word;  no_found:Byte;          {number of discs found}  info:ARRAY[1..2] OF RECORD CASE Byte OF    1:(disc_no:Byte);     {NB. overlays length of string}    2:(disc_name:STRING[16])  ENDEND;BEGINWITH blk0 DO BEGIN  drive:=mainRx.data[1];  blk:=0 { Hmm!! }END;error:=0;Tx.no_found:=0;a:=mainRx.data[2];IF a>2 THEN a:=2; {Number of drives asked for}WHILE (error=0) AND (blk0.drive <= no_discs) AND (Tx.no_found < a)DO BEGIN  Cache_entry(blk0,True);  IF error=0 THEN BEGIN    GetScr(Addr(cache.data[87]),10,disc_name);    Pad(disc_name,16);    Inc_B(tx.no_found);    tx.info[tx.no_found].disc_name:=disc_name;    tx.info[tx.no_found].disc_no:=blk0.drive  END;  Inc_B(blk0.drive)END;IF error<>0 THEN Err_messageELSE BEGIN  Tx.cmd_ret_codes:=0;  Ecotx(0,mainRX.reply,client_stn,Addr(TX),Tx.no_found*17+3,a)ENDEND;PROCEDURE Free_space;VARTx:RECORD  cmd_ret_codes:Word;  answer:Dbl_word {NB. last byte not transmitted}END;a:Byte;aS,disc_name:Min_string;BEGINGetScr(Addr(mainRx.data),10,aS);GSread(aS,disc_name,True);a:=Drive_no(disc_name);IF error<>0 THEN Err_messageELSE BEGIN  Tx.cmd_ret_codes:=0;  Tx.answer:=free_bl[a]*4; {answer is in units of 256 bytes - 3 bytes only}  Ecotx(0,mainRX.reply,client_stn,Addr(TX),5,a)ENDEND;PROCEDURE Acct_space;CONSTmaxno=128; {Max no. of accounts to scan @ once}VARTx:RECORD  cmd_code:Byte;  return_code:Byte;  next_acc:Word;  no_sent:Word;  {Number of accounts scanned}  info:ARRAY[1..maxno] OF RECORD acc:Word; bal:Word ENDEND;bl_des:Block_descrip;out_ptr,max_ptr:Byte;account:Word;BEGINMove(mainRx.data[4],account,2); {max no. of accounts to <account> }IF account<maxno THEN max_ptr:=account ELSE max_ptr:=maxno;out_ptr:=1;tx.cmd_code:=040H; {Normal value}Move(mainRx.data[2],account,2); {start account to <account> }IF mainRx.data[6] > no_discs THEN tx.cmd_code:=0   {Test for out of range disc}ELSE BEGIN  bl_des.blk:=0;  bl_des.drive:=mainRx.data[6];  Cache_entry(bl_des,True);  WHILE (out_ptr<=max_ptr) AND (account < 256) DO BEGIN    IF (account IN user_info^.owner)THEN WITH tx.info[out_ptr] DO BEGIN      acc:=account;      bal:=cache.account_space[account];      Inc_b(out_ptr)    END;    REPEAT      Inc_W(account);    UNTIL (account > 255) OR (account IN user_info^.owner)  END;  IF account>255 THEN BEGIN    IF bl_des.drive<no_discs THEN tx.cmd_code:=080H {'go to next disc'}    ELSE tx.cmd_code:=0; {Finished}    account:=0  ENDEND;IF error<>0 THEN Err_messageELSE BEGIN  Tx.return_code:=0;  tx.next_acc:=account;  tx.no_sent:=Pred(out_ptr); {out_ptr points to free slot}  Ecotx(0,mainRX.reply,client_stn,Addr(TX),2+4*out_ptr,max_ptr)END        {NB max_ptr is dummy location here}END;BEGINEND.