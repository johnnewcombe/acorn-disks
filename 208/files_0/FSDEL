{ FSDEL  File Server delete operation }SEGMENT fsdel;CONST{$Ifsdecs}{$Ifsext}{$Ifsp1e}{$Ifsdatae}{$Ifsdire}{$Ifsrnde}PROCEDURE Delete(dir_DDA:Disc_address;VAR fname:Min_string;d_flags:del_flags);{Sets <error>, Corrupts <c_ent>}{Deletes one or many files, as specified by <fname> which may be ambiguous.First builds a map of entries to delete, whilst removing them from the chain,then deletes them. This minimises the possibility of broken dirs.}VARmap:SET of Byte; {Set to hold all those to be deleted}list2,b_list:Blk_vec;DDA:Disc_address;total:Word;tot_count,chain_no,ent_no,previous,count,b:Byte;go_on,wild,deleted:Boolean;PROCEDURE Get_blk(a:Word);{Local procedure - sets c_ent if the current block <DDA.block> is not the same as <a> }BEGINIF DDA.block.blk<>a THEN BEGIN  DDA.block.blk:=a;  Cache_entry(DDA.block,True)ENDEND;BEGINIF Not Legal(fname,chain_no,wild) THEN error:=204 {Bad name}ELSE IF wild AND (no_wildcard IN d_flags) THEN error:=2  {bad wildcard}ELSE Cache_entry(dir_DDA.block,True);IF error=0 THEN BEGIN  tot_count:=0; {Count of total files deleted}  map:=[]; {Map of deleted files}  b_list:=cache.dir_ent[dir_DDA.offset].blk_list;  DDA:=dir_DDA;  REPEAT {for all the chains if wild, else just 1}    previous:=0; {Dummy value to indicate start of chain}    count:=0;    {Count of successive entries to be deleted}    Get_blk(b_list[0]);    IF error=0 THEN BEGIN      ent_no:=cache.dir_ent[0].chain[chain_no].ent_no;      go_on:=True;      WHILE (error=0) AND go_on AND (ent_no<>0) DO BEGIN   {ent_no=0 <=> end chain}        DDA.offset:=ent_no MOD ents_per_block;        deleted:=False;        Get_blk(b_list[ent_no DIV ents_per_block]);        WITH cache.dir_ent[DDA.offset] DO BEGIN          b:=next_ent; {save to move on ent_no at end}          IF (error=0) AND Match(fname,Addr(name),go_on) THEN BEGIN            IF NOT Owner(account,aux_acc) THEN error:=0BDH            ELSE IF Land(access,L_bit)<>0 THEN error:=0C3H {locked}            ELSE IF Check_open(DDA,[in_use]) THEN error:=0C2H {already open}                            {<Check_open> sets <aux_error>, but not <error>}            ELSE IF (Land(access,D_bit)<>0) AND(no_of_ents<>0) THEN error:=0B4H            ELSE BEGIN                                          {Dir not empty}              Inc_B(count);              Inc_B(tot_count);              deleted:=True;              map:=map+[ent_no]            END;            IF wild THEN error:=0;          {If wild, ignore non-serious errors as there may be more files}          END        END;        IF NOT deleted THEN BEGIN          IF count<>0 THEN BEGIN {count gives number of files to delete}            Get_blk(b_list[previous DIV ents_per_block]);            IF error=0 THEN BEGIN              WITH cache.dir_ent[previous MOD ents_per_block] DO              IF previous=0 THEN chain[chain_no].ent_no:=ent_no              ELSE next_ent:=ent_no;              cache.needs_writing:=True;              Get_blk(b_list[0]);              IF error=0 THEN BEGIN                WITH cache.dir_ent[0].chain[chain_no] DO                  ents_in_chain:=ents_in_chain - count;                cache.needs_writing:=True              END;              count:=0            END          END;          previous:=ent_no {ent_no of last non-deleted file}        END;        ent_no:=b {b holds next ent as cache contents undef. here}      END    END;    IF (error=0) AND (count<>0) THEN BEGIN {End of chain to cut off}      Get_blk(b_list[previous DIV ents_per_block]);      IF error=0 THEN BEGIN        WITH cache.dir_ent[previous MOD ents_per_block] DO        IF previous=0 THEN chain[chain_no].ent_no:=ent_no        ELSE next_ent:=ent_no;        cache.needs_writing:=True;        Get_blk(b_list[0]);        IF error=0 THEN BEGIN          WITH cache.dir_ent[0].chain[chain_no] DO            ents_in_chain:=ents_in_chain - count;          cache.needs_writing:=True        END;      END    END;    Inc_B(chain_no)  UNTIL NOT(go_on) OR (error<>0) OR (chain_no=15) OR NOT(wild)END;IF (error=0) AND (map=[]) THEN  IF wild THEN error:=1  {Nothing happened}  ELSE BEGIN    error:=214;    aux_error:=fname  ENDELSE IF Not(no_dealloc IN d_flags) THEN FOR ent_no:=1 TO 255 DO  IF (error=0) AND (ent_no IN map) THEN BEGIN  total:=0; {Count of blocks released}  DDA.block.blk:=b_list[ent_no DIV ents_per_block];  Cache_entry(DDA.block,True);  IF error=0 THEN WITH cache.dir_ent[ent_no MOD ents_per_block] DO BEGIN    next_ent:=ent_no; {Mark as deleted}    list2:=blk_list;    chain_no:=account; {Using chain_no,wild to store info from cache}    wild:=exploded IN flags; { for later use }    cache.needs_writing:=True  END;  IF error=0 THEN FOR count:=0 TO 15 DO IF list2[count]<>0 THEN BEGIN    DDA.block.blk:=list2[count];    D_alloc(DDA.block);    Inc_W(total);    IF wild THEN BEGIN {really IF exploded ... }      Cache_entry(DDA.block,True);      IF error=0 THEN WITH cache DO       FOR b:=0 TO M1words_per_block DO BEGIN        DDA.block.blk:=EB_list[b];        IF DDA.block.blk<>0 THEN BEGIN Inc_W(total); D_alloc(DDA.block) END      END    END  END;  IF error=0 THEN BEGIN    DDA.block.blk:=0; {Account allocation in blk 0}    Cache_entry(DDA.block,True);    IF error=0 THEN WITH cache DO BEGIN {chain_no holds account no}      Add_no_wrap(total,account_space[chain_no]);      free_bl[DDA.block.drive]:=free_bl[DDA.block.drive]+total;      needs_writing:=True    END  ENDEND;IF error=0 THEN BEGIN  DDA.block.blk:=b_list[0]; {Remove files from bit map in entry 0}  Cache_entry(DDA.block,True);  IF error=0 THEN BEGIN    WITH cache.dir_ent[0] DO bit_map:=bit_map-map;    cache.needs_writing:=True;    Cache_entry(dir_DDA.block,True);    IF error=0 THEN WITH cache DO BEGIN      WITH dir_ent[dir_DDA.offset] DO BEGIN        no_of_ents:=no_of_ents-tot_count;        Move(now,update,Sizeof(short_td)); {Insert update date}        Inc_B(cycle_no)      END;      needs_writing:=True    END  END {***** should rationalise block allocations here  ?***}ENDEND;BEGINEND.