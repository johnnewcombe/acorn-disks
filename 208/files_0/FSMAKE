{ FSMAKE  Include file for FSdir } { IF NOT make THEN BEGIN ~was a find type operation~    IF (Not found1) AND (error=0) THEN BEGIN error:=214; aux_error:=fname END    ~Find call stops here~  END ELSE BEGIN ~Make call}    {DDA currently points to the file which has been found, or the one     after which the new one must be inserted if none is found. <ent_no> holds     the entry no. of the next file in the chain - ie. the one we will point     to in our new entry}    Dec_B(chain_no); {Has been inc'd!}    blocks_reqd:=init_blks;    IF blocks_reqd > 16 THEN      blocks_reqd:=blocks_reqd+(blocks_reqd DIV words_per_block)+1;        {allow for explosion blocks}    IF found THEN BEGIN {Existing file}      {<Check_open> sets <aux_error>, but not <error> if any FCB found       with given flags}      IF Check_open(DDA,[in_use]) THEN error:=0C2H      ELSE IF dir IN l_flags THEN BEGIN        Check_dir(DDA.offset);        IF error=0 THEN error:=0C4H          {Already exists - the easiest way to exit without doing anything!}      END ELSE BEGIN        Check_not_dir(DDA.offset);        IF error=0 THEN BEGIN          error:=0C4H        END      END    END ELSE     {New file, so think about a new entry}    IF NOT dir_owner THEN error:=0BDH    ELSE IF blocks_reqd > free_bl[bl_des.drive] THEN error:=0C6H    ELSE BEGIN      bl_des.blk:=b_list[0]; {look at bit map in entry 0}      Cache_entry(bl_des,True);      IF error=0 THEN WITH cache.dir_ent[0] DO BEGIN        new_ent:=0; {Find a new entry number, ignoring empty blocks}        REPEAT          Inc_B(new_ent);          WHILE (new_ent IN bit_map) AND (new_ent<255) DO Inc_B(new_ent);          found1:=b_list[new_ent DIV ents_per_block] <> 0          {found1 <=> new dir block is not needed. Used later}        UNTIL (new_ent=255) OR found1;        IF (NOT found1) OR (new_ent IN bit_map) THEN BEGIN    {new block reqd or dir full}          found1:=False;          new_ent:=ents_per_block;          WHILE (new_ent IN bit_map) AND (new_ent < (256-ents_per_block))            DO new_ent:=new_ent+ents_per_block;          IF new_ent IN bit_map  THEN error:=0B3H {dir full}          ELSE BEGIN            Inc_W(blocks_reqd); {allow 1 more for the dir, noting that the                           dir account is the same as the new account}            IF free_bl[DDA.block.drive] < blocks_reqd THEN error:=0C6H          END    {allow 1 extra for the new directory block}        END      END    END;  {Gets here whether entry was initially found or not}          {disc full must be checked already}    IF error=0 THEN BEGIN      bl_des.blk:=0;      {Get blk0 to check for a/c bankrupt}      Cache_entry(bl_des,True)    END;    IF error=0 THEN BEGIN      IF blocks_reqd > cache.account_space[new_acc] THEN BEGIN        error:=0ABH; {A/C bankrupt}        Hex2S(new_acc,aux_error)      END      ELSE BEGIN  {All possible errors now checked, so do the job}        WITH cache DO          account_space[new_acc]:=account_space[new_acc]-blocks_reqd;        cache.needs_writing:=TRUE;        free_bl[bl_des.drive]:=free_bl[bl_des.drive]-blocks_reqd;        IF found THEN BEGIN        END ELSE BEGIN {insert new entry}          bl_des.blk:=b_list[0];  {Fix entry 0 info}          Cache_entry(bl_des,TRUE);          IF error=0 THEN WITH cache.dir_ent[0] DO BEGIN            bit_map:=bit_map+[new_ent];            Inc_B(chain[chain_no].ents_in_chain);            cache.needs_writing:=True;            IF DDA.block.blk=0 THEN chain[chain_no].ent_no:=new_ent            ELSE BEGIN {Not 1st entry in chain, so update previous}              Cache_entry(DDA.block,True);  {the previous entry}              IF error=0 THEN BEGIN                cache.dir_ent[DDA.offset].next_ent:=new_ent;                cache.needs_writing:=True              END            END;            DDA.block.blk:=b_list[new_ent DIV ents_per_block];            DDA.offset:=new_ent MOD ents_per_block;            IF (NOT found1) AND (error=0) THEN BEGIN {Must allocate new block}              w:=1; {number of blocks reqd}              F_blk(DDA.block,w);            {block has already been subtracted from <free_bl> & account space}              Cache_entry(DDA.block,False); {Should be no error}              WITH cache DO BEGIN                FOR b:=0 TO M1ents_per_block DO dir_ent[b].next_ent:=new_ent+b;                needs_writing:=True              END            END          END;          IF error=0 THEN Cache_entry(dir_DDA.block,True);          IF error=0 THEN WITH cache.dir_ent[dir_DDA.offset] DO BEGIN{Update the dir's dir ent}            IF NOT found1 THEN {put new block no. into block list}              blk_list[new_ent DIV ents_per_block]:=DDA.block.blk;            b:=def_access;            chain_no:=aux_acc; {note temp use of chain_no!}            Inc_B(cycle_no);            Inc_B(no_of_ents);            Move(now,update,Sizeof(short_td)); {Insert update date}            cache.needs_writing:=True;            Cache_entry(DDA.block,True)          END;          IF error=0 THEN WITH cache.dir_ent[DDA.offset] DO BEGIN{Initialise the new dir ent}            account:=new_acc;            next_ent:=ent_no;            PutScr(Addr(name),fname,10);            Move(now,update,Sizeof(short_td)); {Insert update date}            creation:=now.date;   {& create date}            aux_acc:=chain_no;            access:=b;            IF init_blks>16 THEN flags:=[exploded] ELSE flags:=[]          END        END;    {Gets here with DDA->new entry, c_ent->DDA.block}        IF error=0 THEN BEGIN  {Entry ready-initialise it}          IF init_blks>16 THEN w:=(init_blks DIV words_per_block)+1          ELSE w:=init_blks; {IF exploded ...}          FOR ent_no:=0 TO 15 DO b_list[ent_no]:=0;          ent_no:=0;          WHILE w>0 DO BEGIN            blocks_reqd:=w; {Store blocks asked for}            F_blk(bl_des,w); {On return, w holds number of blocks NOT found}            Dec_W(blocks_reqd);            FOR blocks_reqd:=blocks_reqd DOWNTO w DO BEGIN               {ie. once per block}              b_list[ent_no]:=bl_des.blk;              Inc_W(bl_des.blk);              Inc_B(ent_no)            END          END;          cache.dir_ent[DDA.offset].blk_list:=b_list;          cache.needs_writing:=True;          ent_no:=0; {exp. block counter}          blocks_reqd:=init_blks;          IF init_blks>16 THEN REPEAT {Exploded file}            bl_des.blk:=b_list[ent_no];            Cache_entry(bl_des,False); {no error possible}            w:=0; {block counter for this exp block}            WHILE (init_blks>0) AND (w<words_per_block) DO BEGIN              IF blocks_reqd=init_blks THEN F_blk(bl_des,blocks_reqd);                {on exit, blocks_reqd is the no. still to find}              WHILE (init_blks > blocks_reqd) AND (w<words_per_block) DO BEGIN                cache.EB_list[w]:=bl_des.blk;                Inc_W(bl_des.blk);                Dec_W(init_blks);                Inc_W(w)              END            END;            cache.needs_writing:=True          UNTIL init_blks=0        END      END    END  ENDEND{NB. cache contents not valid on exit if the call was a make operation with         init_blks > 16 }END;{This is an include file of FSdir}