{  FS  File Server main code }PROGRAM Fs;{$Ifsdecs}VARa:Word;dummybyte:Byte;ch:Char;aS:Min_string;{$Ifsext}{$Ifsp1e}{$Ifsp2e}{$Ifsp3e}{$Ifscate}{$Ifsdatae}Procedure Print(var txt:Min_string);{Procedure to place contents of string into print buffer. If buffer doesnot have enough free space, it is purged first}VARa:byte;BEGINWhile ((print_space-print_ptr+print_size)MOD print_size) {no of chrs in buffer}  > (print_size-length(txt)) DO BEGIN  List_OT(print_buff[print_ptr]);  If print_ptr=print_size THEN print_ptr:=1 ELSE print_ptr:=succ(print_ptr)END;For a:=1 TO length(txt) DO BEGIN  print_buff[print_space]:=ord(txt[a]);  IF print_space=print_size THEN print_space:=1  ELSE print_space:=succ(print_space)ENDEND;Procedure Instructions;BEGIN{writeln(' SJ Research File Server version ',verA:1,'.',verB:1,verC:1);} writeln('Very Dubious ARGO Server version ',verA:1,'.',verB:1,verC:1);writeln;Writeln('Operator commands :');Writeln;Writeln('Esc - allow discs to be changed');Writeln('F   - flush printer buffer');Writeln('M   - messages off/on');Writeln('Q   - quit');WritelnEND;Procedure Finish_print;VARdummy:Byte;BEGINPrint(end_text);print_active:=false;IF messages THEN BEGIN  StnS(client_stn,aS);  Writeln('Stn ',aS,'end print')END; {Now acknowledge final packet}Ecotx(rx_seq,print_port,print_stn,addr(printRx),1,dummy);print_stn:=0 {Only non-0 if we are talking to someone}END;BEGIN {Main block}stop:=FALSE;     {True means exit FS}disaster:=FALSE; {True for fatal error conditions}FOR a:=1 to cache_size DO WITH cache[a] DO BEGIN  age:=max_age;  which_blk.drive:=255; {Out of range drive no. <=> not in use}  needs_writing:=FALSEEND;messages:=TRUE;messag:=messages; {should be defined this way!}print_ptr:=1;print_space:=1;print_stn:=0; {Only non-0 if we are talking to someone}time_out:=0;print_active:=false;print_waiting:=false; {If TRUE, we have an RxCB open}pre_text:='';post_text:=Concat(chr(13),chr(10)); {CR,LF}banner:='***  SJ Research Econet ';no_banner:=false;end_text:=chr(12);FOR a:=1 TO no_users DO With user_info[a] DO BEGIN  flags:=[];  FOR dummybyte:=1 TO 8 DO fcbs[dummybyte].flags:=[]    {Not in_use,write access etc.}END;Ecoini;Instructions;Init_disc;Writeln('Ready',chr(17)); {ctrl-Q disables page wait on RML}REPEAT {Main operating loop}  Rxset(blockno,cmdport,0,Addr(mainRX),min_size+5);  WHILE NOT (Rxread(blockno,dummybyte,dummybyte,client_stn,a) OR stop)    DO BEGIN    {Idle time in here!}{Handle operator commands}    IF Inkey(ch) THEN CASE Land(Ord(ch),5FH) OF       27:BEGIN Writeln('Dumping Cache to disc');            C_empty;            Writeln('Change disc(s) then press space');            REPEAT REPEAT UNTIL Inkey(ch) UNTIL ch=' ';            Writeln('Ready')          END;       70:BEGIN {Flush print buffer}            print_ptr:=1;            print_space:=1          END;       77:BEGIN            messages:=NOT messages;            messag:=messages;            Write('messages ');            CASE messages OF              TRUE:Writeln('On');              FALSE:Writeln('Off');            END          END;       81:stop:=TRUE;     OTHERWISE Instructions    END; {of Case}{Empty caches}    IF cache_time=0 THEN BEGIN      a:=1;      While (a<cache_size) AND (NOT cache[a].needs_writing) DO a:=Succ(a);      IF cache[a].needs_writing THEN BEGIN        floppy(False,cache[a].which_blk,Addr(cache[a].data),dummybyte);        cache[a].needs_writing:=FALSE      END;      cache_time:=10;      C_idle {Purge EXTERNAL cache}    END ELSE cache_time:=Pred(cache_time);{Attempt to empty print buffer}    FOR a:=1 TO 10 DO    IF (print_ptr<>print_space) AND List_ST THEN BEGIN      List_OT(print_buff[print_ptr]);      IF print_ptr=print_size THEN print_ptr:=1  {wrap around buffer}       ELSE print_ptr:=succ(print_ptr)    END;{Attempt to fill print buffer}    IF print_waiting THEN IF      RXread(print_block,rx_seq,dummybyte,client_stn,blk_len) THEN BEGIN      print_waiting:=FALSE;      IF print_active OR (client_stn=print_stn) THEN BEGIN         {Either still printing or timed out & re-started}        print_active:=TRUE;        IF Land(rx_seq,1)=next_seq THEN BEGIN          next_seq:=Land(succ(next_seq),1); {Increment sequence no}          IF (NOT old_type) AND (Land(rx_seq,4)=4) THEN blk_len:=pred(blk_len);            {Control byte indicates last block, but there is a             spurious ctrl-C at the end as well }          a:=1;          WHILE a<=blk_len DO BEGIN                {Transfer data to output buffer}            IF old_type AND (printRx[a]=3) THEN Finish_print             {Old type block terminator}            ELSE BEGIN {normal byte}              print_buff[print_space]:=printRx[a];              IF print_space=print_size THEN print_space:=1               ELSE print_space:=succ(print_space)            END;            a:=Succ(a)          END; {while}          IF (NOT old_type) AND (Land(rx_seq,4)=4) THEN Finish_print           {Usual terminator}        END      END ELSE BEGIN {Not active, so should be log-on}        IF print_stn<>0 THEN Finish_print;         {Terminate timed-out user}        StnS(client_stn,aS);        old_type:=printRx[prx_size]<>0; {Character sent indicates protocol}        IF messages THEN BEGIN          Writeln('Print stn=',aS);          IF old_type THEN Write('Old') ELSE Write('New');          Writeln(' protocol')        END;        print_stn:=client_stn;        IF NOT no_banner THEN Print(pre_text);        Print(banner);        IF NOT no_banner THEN BEGIN          aS:=Concat(' ***  Station ',aS,' (');{Can't do yet          IF User_ok THEN Append(aS,user_info[user_no].user_ID)            ELSE Append(aS,'No name');}          aS:=Concat(aS,')  ***');          Print(aS);          Print(post_text)        END;        next_seq:=Land(succ(Rx_seq),1); {Initialise sequence no (=0 or =1) }        print_active:=TRUE      END    END;    If (NOT print_waiting) AND      (((print_space-print_ptr+print_size)MOD print_size)      < (print_size-prx_size)) THEN BEGIN      { There is room in the buffer for another recieve block }      print_waiting:=TRUE;      If print_active THEN       Rxset(print_block,print_port,print_stn,addr(printRx),prx_size)      ELSE Rxset(print_block,print_port,0,addr(printRx),prx_size);       { Acknowledge if appropriate }      If print_active THEN Ecotx(rx_seq,print_port,print_stn,        addr(printRx),1,dummybyte);      time_out:=tim_delay    END;    If print_waiting AND print_active THEN time_out:=pred(time_out);    If print_active AND (time_out=0) THEN BEGIN      Delrx(print_block);      print_waiting:=False;  {Allows another rxblk to set itself up}      Msgln('Print timeout');      print_active:=false    END  END;{ Drops through here when a packet arrives on the FS command port }IF NOT stop THEN BEGIN  IF messages THEN BEGIN    StnS(client_stn,aS);    Writeln('Fn=',mainRX.FN:3,' Stn=',aS)  END;   {Check if logged on or *cmd which could be *I AM }  IF (mainRx.fn=0) OR User_ok THEN  CASE mainRX.fn OF    0:Starcmd;    1:Save;    2:Load;    3:Cat;    5:Load;   18:Read_info;   21:User_envir;   23:Log_off;  OTHERWISE Err_message(133)  END {of case}  ELSE Err_message(191) {'Who are U?' }END;cache_time:=cache_del; { Delay before writing cache }UNTIL stop;C_empty;IF disaster THEN BEGIN  Writeln('Fatal error')ENDEND.