{ FScat  File Server Procedures & Functions }SEGMENT Fscat;{$Ifsdecs}{$Ifsext}{$Ifsp1e}{$Ifsdire}{$Ifsdatae}PROCEDURE Read_info;VARmainTx:stdTx;fname:min_string;DDA:Disc_address;c_ent,a,arg,error:BYTE;BEGINarg:=mainRX.data[1];GetScr(Addr(mainRX.data[2]),min_size-1,fname);IF messag THEN Writeln('Rd_info arg=',arg:3,' name=',fname);a:=Fcb_no(mainRx.envir.CSD);IF a=0 THEN error:=222 {'channel' error}ELSE BEGIN  DDA:=user_info[user_no].fcbs[a].DDA;  Strip_dirs(fname,DDA,False,error);  IF error=0 THEN Find(fname,DDA,c_ent,error);  IF error=0 THEN CASE arg OF    6:{Read directory info}      BEGIN      GetScr(Addr(cache[c_ent].dir_ent[DDA.offset].Name),10,fname);      fname:=Concat(fname,'          ');      MidS(fname,0,10);      WITH mainTx DO BEGIN        PutS(addr(data[4]),fname);        data[1]:=0; {Spurious byte set to 0 for uniformity}        data[2]:=0;        data[3]:=10; {required by BBC NFS!}        IF cache[c_ent].dir_ent[DDA.offset].account IN          user_info[user_no].owner THEN data[14]:=0 {Owner access}        ELSE data[14]:=255; {Public}        data[15]:=cache[c_ent].dir_ent[DDA.offset].cycle_no;        rtncode:=0;        cmd:=0      END;      Ecotx(0,mainRX.reply,client_stn,addr(mainTX),17,a);      IF a<128 THEN notlistening      END;    OTHERWISE error:=4FH    END {of case}  END;IF error<>0 THEN Err_message(error)END;PROCEDURE User_envir;VARmainTx:stdTx;aS:min_string;DDA:Disc_address;c_ent,lib_no,csd_no,a,error:BYTE;BEGINmaintx.cmd:=0;maintx.rtncode:=0;csd_no:=Fcb_no(mainRx.envir.CSD);lib_no:=2; {SHOULD BE Fcb_no(mainRx.envir.LIB) BUT BBC DOES NOT ALWAYS SEND HANDLE!!}IF (csd_no=0) OR (lib_no=0) THEN error:=222 {'Channel' error}ELSE BEGIN  DDA:=user_info[user_no].fcbs[csd_no].DDA;  c_ent:=Cache_entry(DDA.block,True,error);  IF error=0 THEN BEGIN    GetScr(Addr(cache[c_ent].dir_ent[DDA.offset].Name),10,aS);    Pad(aS,10); {pad out CSD name}    PutS(Addr(mainTX.data[18]),aS);    DDA.block.blk:=0; {Get disc name out of blk 0}    c_ent:=Cache_entry(DDA.block,True,error);    IF error=0 THEN BEGIN      GetScr(Addr(cache[c_ent].data[87]),10,aS);      maintx.data[1]:=16; {Length of disc name}      Pad(aS,16);      PutS(Addr(mainTX.data[2]),aS);      DDA:=user_info[user_no].fcbs[lib_no].DDA;      c_ent:=Cache_entry(DDA.block,True,error);      IF error=0 THEN BEGIN        GetScr(Addr(cache[c_ent].dir_ent[DDA.offset].Name),10,aS);        Pad(aS,10); {pad out LIB name}        PutS(Addr(mainTX.data[28]),aS);        Ecotx(0,mainRX.reply,client_stn,Addr(mainTX),39,a);        IF a<128 THEN notlistening      END    END  ENDEND;IF error<>0 THEN Err_message(error)END;PROCEDURE Cat;CONSTP_bit=64; { Bit position in access byte }VARfname:min_string;ent_no,c_ent,chain_no,a,arg,error,ent_offset,entry,no_of_ents:BYTE;index:Word;big_buff:ARRAY[1..buff_size] OF Byte;b_list:blk_vec;owner:Boolean;DDA:disc_address;BEGINarg:=mainRX.data[1];ent_offset:=mainRX.data[2];no_of_ents:=mainRX.data[3];{***NB should check that no_ents will fit in buffer}GetScr(Addr(mainRX.data[4]),min_size-10,fname);IF messag THEN BEGIN  Writeln('Cat arg=',arg:1,' name=',fname);  Writeln('1st ent=',ent_offset:3,' no of ents=',no_of_ents:3)END;A:=Fcb_no(mainRx.envir.CSD);IF A=0 THEN error:=222 {'channel' error}ELSE BEGIN  DDA:=user_info[user_no].fcbs[a].DDA;  Strip_dirs(fname,DDA,True,error);  IF error=0 THEN BEGIN    c_ent:=Cache_entry(DDA.block,True,error);    IF error=0 THEN BEGIN      WITH cache[c_ent].dir_ent[DDA.offset] DO BEGIN        owner:=account IN user_info[user_no].owner;        b_list:=blk_list;        big_buff[4]:=cycle_no      END;    { after here, DDA contains the current block, but <offset> is undefined }      DDA.block.blk:=b_list[0];      c_ent:=Cache_entry(DDA.block,True,error);      IF error=0 THEN BEGIN        a:=0; {entry number offset to 1st chain}        chain_no:=0;        REPEAT          ent_offset:=ent_offset-a;          IF owner THEN a:=cache[c_ent].dir_ent[0].chain[chain_no].owner_ents          ELSE a:=cache[c_ent].dir_ent[0].chain[chain_no].public_ents;          chain_no:=Succ(chain_no);        UNTIL (ent_offset<a) OR (chain_no=10);        chain_no:=Pred(chain_no);        entry:=0; {Counter of the number we've done}        index:=5; {Index into the output buffer}        IF ent_offset<a THEN BEGIN          ent_no:=cache[c_ent].dir_ent[0].chain[chain_no].ent_no;          WHILE (ent_offset>1) AND (error=0) DO BEGIN          {scan down to right entry}            ent_offset:=Pred(ent_offset);            DDA.block.blk:=b_list[ent_no DIV ents_per_block];            c_ent:=Cache_entry(DDA.block,True,error);            ent_no:=cache[c_ent].dir_ent[ent_no MOD ents_per_block].next_ent          END;        {Main entry-by entry writing loop starts here}          WHILE (ent_no<>0) AND (entry<no_of_ents) AND (error=0) DO BEGIN            DDA.block.blk:=b_list[ent_no DIV ents_per_block];            DDA.offset:=ent_no MOD ents_per_block;            c_ent:=Cache_entry(DDA.block,True,error);            WITH cache[c_ent].dir_ent[DDA.offset] DO BEGIN              GetScr(Addr(Name),10,fname);                 { Name as a string will come in useful}                IF owner OR (Land(access,P_bit)=0) THEN BEGIN                { User has access to see the file }                entry:=Succ(entry);                CASE arg OF                  1:BEGIN { full character string}                    Info_string(Addr(big_buff[index]),cache[c_ent].dir_ent[DDA                      .offset]),a); {Length returned in <a>}                    index:=index+a+1;                    big_buff[index-1]:=0  {Terminator}                  END;                  2:BEGIN  {Straight name return}                    big_buff[index]:=10;                    Pad(fname,10);                    PutS(addr(big_buff[index+1]);                    index:=index+11                  END;                  3:BEGIN  {name with attribute string}                    Pad(fname,11);                    PutS(addr(big_buff[index]),fname);                    index:=index+11;                    Exp_att(access,fname);  {note temp use of fname}                    Pad(fname,7);                    PutS(addr(big_buff[index]),fname);                    index:=index+8;                    big_buff[index-1]:=0 {terminator}                  END;                  OTHERWISE error:=79 {Illegal ARG}                END {Case}              END;                ent_no:=next_ent            END; {of with block}            WHILE (ent_no=0) AND (chain_no<9) AND (error=0) DO BEGIN              chain_no:=Succ(chain_no);              DDA.block.blk:=b_list[0];              c_ent:=Cache_entry(DDA.block,True,error);              ent_no:=cache[c_ent].dir_ent[0].chain[chain_no].ent_no            END          END {main WHILE loop}        END      END    END  ENDEND;IF error=0 THEN BEGIN  big_buff[index]:=128; {final terminator}  big_buff[1]:=0;  big_buff[2]:=0; {TX header}  big_buff[3]:=entry;  Ecotx(0,mainRX.reply,client_stn,Addr(big_buff),index,error);  IF error<128 THEN notlisteningEND ELSE Err_message(error)END;BEGIN {Dummy block}END.