{ FSDIR  File Server Directory management }SEGMENT fsdir;{$Ifsdecs}{$Ifsext}{$Ifsp1e}{$Ifsdatae}{$Ifslooke}FUNCTION Size(b_list:Blk_vec;exploded:Boolean;VAR error:byte):Word;{Counts blocks occupied by a file. <b_list> is 2nd half of dir ent. <exploded> indicates whether this is in fact an exploded file, in which case, all the blocks are loaded & scanned.}VARbl_des:Block_descrip;c_ent,a,b:Byte;result:Word;BEGINresult:=0;a:=0;WHILE (a<17) AND (error=0) DO IF b_list[a]<>0 THEN BEGIN {=0 => not allocated}  bl_des.blk:=b_list[a];  Inc_W(result);  IF exploded THEN BEGIN    c_ent:=Cache_entry(bl_des,True,error);    WITH cache[c_ent] DO FOR b:=0 TO M1words_per_block DO BEGIN      bl_des.blk:=EB_list[b];      IF bl_des.blk<>0 THEN Inc_W(result)    END  END;  Inc_B(a)END;Size:=resultEND;Function Drive_no(VAR drv_name:min_string;VAR c_ent,error:byte):Byte;VARblk0:block_descrip;a:Byte;bool,found:Boolean;BEGINWITH blk0 DO BEGIN  drive:=0;  blk:=0 { Hmm!! }END;IF Not Legal(drv_name,a,bool) THEN error:=204 {NB dummy parameters}ELSE REPEAT  c_ent:=Cache_entry(blk0,True,error);  IF error=0 THEN found:=Match(drv_name,Addr(cache[c_ent].data[87]),bool);  Inc_B(blk0.drive)UNTIL found OR (blk0.drive > no_discs) OR (error<>0);IF (error=0) AND (Not found) THEN BEGIN aux_error:=drv_name;error:=214 END;    { 'Not found' !! }Drive_no:=Pred(blk0.drive)   {Has just been inc'd}END;PROCEDURE Find(VAR fname:min_string;VAR DDA:disc_address;VAR c_ent,error:Byte);{Looks in the given directory for any files matching the given string, whichmust be a simple name (all directories should have already been stripped).<cache_no> is the cache entry where the relavent directory block has beenput. <DDA> specifies the directory to be searched and returns the DDA ofthe found file. All exit params undefined if error<>0. In the event of a'not found' error, the global <aux_error> contains the filename  }BEGINIF Length(fname)=0 THEN c_ent:=Cache_entry(DDA.block,True,error)ELSE IF fname='$' THEN WITH DDA DO BEGIN  block.blk:=0;  offset:=0;  c_ent:=Cache_entry(block,True,error)ENDELSE IF fname='%' THEN BEGIN  DDA:=user_info[user_no].fcbs[1].DDA;  c_ent:=Cache_entry(DDA.block,True,error)ENDELSE IF fname[1]=':' THEN BEGIN  MidS(fname,1,255);  DDA.block.drive:=Drive_no(fname,c_ent,error);  DDA.block.blk:=0;  DDA.offset:=0ENDELSE IF fname='^' THEN BEGIN  c_ent:=Cache_entry(DDA.block,True,error);  IF error=0 THEN BEGIN    WITH cache[c_ent].dir_ent[DDA.offset] DO BEGIN      DDA.block.blk:=parent_block;      DDA.offset:=parent_offset    END;    c_ent:=Cache_entry(DDA.block,True,error)  ENDENDELSE Look_up(False,0,fname,DDA,c_ent,error)END;Procedure Strip_dirs(VAR fname:min_string;VAR DDA:disc_address;  dir_name:Boolean; VAR error:Byte);{Removes directory prefixes from the given filename, updating the DDAto be the DDA of the effective directory. The last component of the filenameis left in <fname> on return, but if <dir_name> is true, it will have beenused to advance the DDA. All directory names removed are checked for beingdirectories.}VARdirS:min_string;c_ent,ind:Byte;BEGINerror:=0; {No errors yet}ind:=Pos('.',fname);c_ent:=255; {Indicate that we haven't done anything yet}While (ind<>0) AND (error=0) DO BEGIN {There is still a directory to strip}  dirS:=fname;  MidS(dirS,0,ind-1);  MidS(fname,ind,255); {Remove the dir name from the front of fname}  Find(dirS,DDA,c_ent,error);  ind:=Pos('.',fname);  IF ind=Length(fname) THEN ind:=0 {to implement dot abbreviation    <Legal> will convert residual dots into stars}END;IF (error=0) AND dir_name AND (Length(fname)<>0) THEN  Find(fname,DDA,c_ent,error);{ Now check that it's a directory (only if we've changed it) }IF (error=0) AND (c_ent<>255) THEN {We've loaded somthing}  IF (Land(32,cache[c_ent].dir_ent[DDA.offset].access)=0) THEN error:=190END;BEGINEND.