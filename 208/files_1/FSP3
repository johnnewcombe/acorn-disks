{ FSP3  File Server Procedures & Functions }SEGMENT fsp3;{$Ifsdecs}{$Ifsext}{$Ifsp1e}{$Ifsp2e}{$Ifsdire}{$Ifsdatae}Procedure Star_Sdisc(VAR real_name:min_string);VARdrv_no,csd_no:byte;BEGINExtractS(real_name);csd_no:=Fcb_no(mainRx.envir.CSD);IF csd_no=0 THEN Err_message(222) {Channel}Else Writeln('code TBA here')END;Procedure Star_dir(VAR real_name:min_string);CONSTtx_size=3;VARnew_no,csd_no,error:byte;txbuff:Array[1..tx_size] OF Byte;BEGINerror:=0; {no errors yet!}ExtractS(real_name);csd_no:=Fcb_no(mainRx.envir.CSD);IF csd_no=0 THEN error:=222 {Channel}ELSE IF ( Length(real_name)=0 ) THEN new_no:=1 {Select URD as CSD}  ELSE WITH user_info[user_no] DO BEGIN  new_no:=3; {The first FCB that might be free}  WHILE (new_no<8) AND (in_use IN fcbs[new_no].flags) DO new_no:=Succ(new_no);  IF in_use IN fcbs[new_no].flags THEN error:=192 {Too many open files}  ELSE BEGIN    fcbs[new_no]:=fcbs[csd_no];    Strip_dirs(real_name,fcbs[new_no].DDA,True,error);    IF error=0 THEN      IF csd_no<>1 THEN WITH fcbs[csd_no] DO flags:=flags-[in_use]      ELSE  {Don't close URD!}    ELSE WITH fcbs[new_no] DO flags:=flags-[in_use]  ENDEND;IF error<>0 THEN Err_message(error)ELSE BEGIN  txbuff[1]:=7;  {cmd code}  txbuff[2]:=0;  {return code}  txbuff[3]:=Handle(new_no);  Ecotx(0,mainRX.reply,client_stn,Addr(txbuff),3,error);  IF error<128 THEN notlisteningENDEND;FUNCTION User_ok:BOOLEAN;BEGINuser_no:=1;WHILE (user_info[user_no].stn<>client_stn) AND (user_no<>no_users) DO  user_no:=succ(user_no);{Note that if the stn no. appears more than once in the array of users, it willALWAYS be the first one that is relavent, since new ones are allocated from thefirst free one}User_ok:=(user_info[user_no].stn=client_stn) AND  (logged_on IN user_info[user_no].flags)END;Procedure Do_logoff;VARa,b:Byte;BEGINFOR b:=1 to no_users DO WITH user_info[b] DO BEGIN  IF stn=client_stn THEN BEGIN    flags:=[]; {ie. logged_on false}    FOR a:=1 TO 8 DO fcbs[a].flags:=[]  ENDEND{****** should close(properly) all open files here *******}END;Procedure I_am(VAR cmd_text:min_string);VAR a,result:BYTE;mainTx:stdTx;BEGINDo_logoff;user_no:=1;WHILE (logged_on IN user_info[user_no].flags) AND (user_no<no_users) DO  user_no:=Succ(user_no);With user_info[user_no] DO  IF logged_on IN flags THEN Err_message(184) {Too many users}  ELSE BEGIN  {First get hold of user name}  a:=1;  WHILE ((cmd_text[a]<'!') OR ((cmd_text[a]>='0')AND(cmd_text[a]<='9')))     AND (a<=Length(cmd_text)) DO a:=succ(a);  MidS(cmd_text,a-1,10);{At this point, cmd_text contains the user ID. Currently not used !}{***TRAILING SPACES????***}  flags:=[logged_on];  stn:=client_stn;{**TEMP** Set URD,LIB to root}  For a:=1 to 2 DO With fcbs[a] DO BEGIN    flags:=[in_use]; {Not write_access Otherwise no-one else can open it}    DDA.block.drive:=1;    DDA.block.blk:=0; {This is the root}    DDA.offset:=0  END;  Writeln('User ID -->',cmd_text,'<--');  IF cmd_text='ARG' THEN owner:=[0..255] ELSE owner:=[];  WITH mainTx DO BEGIN    cmd:=5;    rtncode:=0;    data[1]:=Handle(1); {URD handle(fixed)}    data[2]:=Handle(1); {CSD handle (may change later)}    data[3]:=Handle(2); {LIB handle (fixed)}    data[4]:=0; {Boot option (Don't !)}    Ecotx(0,mainRX.reply,client_stn,addr(mainTX),6,result);    IF result<128 THEN notlistening  ENDENDEND;PROCEDURE Log_off;BEGINDo_logoff;ReplyokEND;PROCEDURE Starcmd;VARcmd_text:min_string;result,cmd_code:byte;a:Word;mainTx:stdTx;BEGINIF messages THEN BEGIN  StnS(client_stn,cmd_text); {Using cmd_text as temp store}  Write('Stn:',cmd_text,' *')END;GetScr(Addr(mainRX.data),min_size,cmd_text);Msgln(cmd_text);cmd_code:=CLI(cmd_text);IF (cmd_code=5) OR User_ok THEN {Check logged on if not a *I AM }  CASE cmd_code OF     4:Star_info(cmd_text);     5:I_am(cmd_text);     6:Star_Sdisc(cmd_text);     7:Star_dir(cmd_text);   247:BEGIN ExtractS(cmd_text);banner:=cmd_text;no_banner:=TRUE;ReplyOK END;   248:BEGIN extractS(cmd_text);end_text:=cmd_text;ReplyOK END;   249:BEGIN extractS(cmd_text);post_text:=cmd_text;ReplyOK END;   250:BEGIN extractS(cmd_text);pre_text:=cmd_text;ReplyOK END;   251:BEGIN extractS(cmd_text);banner:=cmd_text;no_banner:=FALSE;ReplyOK END;   252:Replyok; {*CDIR}   253:Log_off; {*BYE}   254:Star_delete(cmd_text);   OTHERWISE BEGIN {Unrecognised command}      mainTX.cmd:=8;      mainTX.rtncode:=0;      PutS(addr(mainTX.data),cmd_text);      a:=length(cmd_text);      mainTx.data[a+1]:=CR; {Append a CR to the text}      Ecotx(0,mainRX.reply,client_stn,addr(mainTX),a+3,result);    IF result<128 THEN notlistening    ENDEND {case}ELSE Err_message(191); {Not logged on}MsglineEND;BEGIN {dummy block}END.