{ FSP1  File Server Procedures & Functions }SEGMENT fsp1;{$I fsdecs}{$Ifsext}{ A set of procedures to replace Writeln etc. allowing the operator to turnthem off. }Procedure Msgline;BEGINIF messag THEN WritelnEND;Procedure Msg(a:Min_string);BEGINIF messag THEN Write(a)END;Procedure Msgln(a:Min_string);BEGINIF messag THEN Writeln(a)END;{ Assorted string handling routines }PROCEDURE Append(VAR left,right:Min_string);BEGINleft:=Concat(right,left)END;PROCEDURE stnS(stn:Word;VAR dumS:Min_string);{ Returns a string giving a station number in decimal, with the two bytesseparated if it is a distant station (high byte <>0) }VARhiS:string [5];BEGINStr(Lo(stn),dumS);IF Hi(stn)<>0 THEN BEGIN  Str(Hi(stn),hiS);  dumS:=Concat(hiS,'.',dumS)ENDEND;PROCEDURE Hex2S(x:BYTE;VAR dummy:Min_string);VARlo,hi:BYTE;BEGINlo:=x MOD 16;hi:=x DIV 16;IF lo>9 THEN lo:=lo+7;IF hi>9 THEN hi:=hi+7;dummy:=Concat(chr(hi+48),chr(lo+48))END;Procedure ExtractS(VAR data:Min_string);{ Performs the function of GSREAD in a BBC Computer : processes a string sorting out quotes and | sequences.}VARtop_bit,ctrl,quoted,no_char,close_quote:Boolean;out_ptr,in_ptr:Byte;ch:char;BEGINin_ptr:=1; {Index into given string}top_bit:=FALSE;ctrl:=FALSE;close_quote:=FALSE;WHILE data[in_ptr]=' ' DO in_ptr:=Succ(in_ptr);quoted:=data[in_ptr]='"'; {If 1st char is " then whole string considered quoted}IF quoted THEN in_ptr:=succ(in_ptr);WHILE (in_ptr<=Length(data)) AND   NOT(quoted AND close_quote AND (data[in_ptr]<>'"')) DO BEGIN  no_char:=FALSE; {Indicates that this char generates no output if TRUE}  IF ctrl THEN BEGIN {Last was a control (|) symbol}    CASE data[in_ptr] OF      '?':ch:=chr(127);      '!':BEGIN top_bit:=TRUE;no_char:=TRUE END;      '"':ch:='"';      OTHERWISE ch:=chr(Land(ord(data[in_ptr]),31))    END; {Case}    ctrl:=FALSE  END ELSE BEGIN    CASE data[in_ptr] OF      '"':IF close_quote THEN BEGIN ch:='"';close_quote:=FALSE END          ELSE BEGIN close_quote:=TRUE; no_char:=TRUE END;      '|':BEGIN no_char:=TRUE;ctrl:=TRUE END;      OTHERWISE ch:=data[in_ptr]    END {case}  END;  IF NOT no_char THEN BEGIN    IF top_bit THEN BEGIN  {***** THIS SECTION CAUSES RUN TIME ERRORS ****}      ch:=chr(Land(ord(ch),127)+128);      top_bit:=FALSE    END;    data[out_ptr]:=ch;    out_ptr:=succ(out_ptr)  END;  in_ptr:=succ(in_ptr)END;MidS(data,0,out_ptr-1)END;PROCEDURE Hex_word(A:Word);{ Print out Word }BEGINIF a>0FH THEN Hex_word(a DIV 10H);a:=Land(a,0FH);IF a<10 THEN Write(a:1) ELSE Write(Chr(a+55))END;PROCEDURE Hex_print(A:dbl_word);{ Print out double Word }BEGINHex_word(a DIV 10000H);Hex_word(a MOD 10000H)END;PROCEDURE Make3(VAR dest:Three_byte;srce:Dbl_word);BEGINMove(srce,dest,3)END;PROCEDURE Make4(VAR dest:Dbl_word;srce:Three_byte);BEGINdest:=0; {For the hi byte}Move(srce,dest,3)END;{Error (and no error) handling routines}PROCEDURE Notlistening;BEGINWRITELN('Stn',client_stn,'Not Listening')END;PROCEDURE ReplyOK;VAR result:BYTE;mainTx:Word;BEGINmainTX:=0;   {rtn_code & cmd_code both zero}Ecotx(0,mainRX.reply,client_stn,Addr(mainTX),2,result);IF result<128 THEN notlisteningEND;PROCEDURE Err_message(errno:BYTE);VARmainTx:RECORD  cmd_code:Byte;  CASE boolean OF    True:(msg:Min_string);    False:(rtn_code:Byte)        {Overlays length of string!}END;result:Byte;len:Word;BEGINIF errno<>0 THEN WITH mainTx DO BEGIN  CASE errno OF    85H:msg:='Invalid function';    179:msg:='Directory full';    184:msg:='Too many users';    191:msg:='Who are you?';    190:msg:='Not a directory';    198:msg:='Disc Full';    204:msg:='Bad file name';    214:msg:=Concat(aux_error,' not found');    222:msg:='Channel';    223:msg:='EOF';    OTHERWISE BEGIN Hex2S(errno,msg);      msg:=Concat('FS unusual error ',msg) END;  END {Case};    IF messag THEN WRITELN(msg);  msg:=Concat(msg,chr(CR));  len:=Length(msg)+2;  cmd_code:=0;  rtn_code:=errnoEND ELSE BEGIN  mainTx.cmd_code:=0;  {this is a 'reply OK' }  mainTx.rtn_code:=0;  len:=2END;Ecotx(0,mainRX.reply,client_stn,Addr(mainTX),len,result);IF result<128 THEN notlisteningEND;{ Routines to convert internal FCB numbers 1..8 to/from external handlesin the form of one bit set in a byte }Function Fcb_no(handle:Byte):nibble;{ Takes a handle of the form 2^(n-1) and returns 'n', or 0 if the handle does not refer to a currently open FCB }VARcount,bit:Byte;BEGINbit:=1;count:=1;While (handle<>bit) AND (count<8) DO BEGIN bit:=bit*2;count:=Succ(count) END;IF (handle=bit) AND (in_use IN user_info[user_no].fcbs[count].flags)  THEN Fcb_no:=countELSE Fcb_no:=0END;Function Handle(n:nibble):Byte;{ Returns the handle equivalent to the given fcb number (ie. 2^(n-1) )}VARbit,count:byte;BEGINbit:=1;For count:=2 To n DO bit:=bit*2;Handle:=bitEND;BEGINEND.