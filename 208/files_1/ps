{  PS  Printer Server main code }PROGRAM Ps;CONST{$Ipsdecs}VARw:Word;a,block_no,print_block,next_seq,b:Byte;ch:Char;print_buff:ARRAY[1..print_size] OF Byte;aS:Min_string;PROCEDURE FSexit; EXTERNAL;PROCEDURE Ecoini; EXTERNAL; {Initialise}PROCEDURE Rxset(VAR blockno:BYTE;port:BYTE;stn,start,length:Word);EXTERNAL;FUNCTION Rxread(blockno:BYTE;VAR ctrl,port:BYTE;VAR stn,length:Word)  :BOOLEAN;EXTERNAL;PROCEDURE Delrx(blockno:BYTE);EXTERNAL;PROCEDURE Ecotx(ctrl,port:byte;stn,start,length:Word;VAR result:byte);  EXTERNAL;PROCEDURE PutS(addr:Word;VAR srce:Min_string); EXTERNAL;PROCEDURE GetScr(addr:Word;maxlength:BYTE;VAR dest:Min_string); EXTERNAL;PROCEDURE PutScr(addr:Word;VAR source:Min_string; max_length:Byte); EXTERNAL;PROCEDURE MidS(VAR text:Min_string;start,length:BYTE); EXTERNAL;FUNCTION Land(a,b:Word):Word;EXTERNAL; {Logical AND (bitwise)}FUNCTION Hi(a:Word):BYTE; EXTERNAL;FUNCTION Lo(a:Word):BYTE; EXTERNAL;FUNCTION Cli(VAR line:Min_string):BYTE;EXTERNAL;PROCEDURE ListOT(a:byte); EXTERNAL;  {List output}FUNCTION ListST:boolean; EXTERNAL;   {List status (TRUE=ready)}FUNCTION Inkey(VAR ch:Char):boolean; EXTERNAL;PROCEDURE Dec_W(VAR x:Word); EXTERNAL;PROCEDURE Dec_B(VAR y:Byte); EXTERNAL;PROCEDURE Inc_W(VAR x:Word); EXTERNAL;PROCEDURE Inc_B(VAR y:Byte); EXTERNAL;PROCEDURE GSread(VAR in_S,out_S:Min_string;stop_on_delimeters:Boolean);EXTERNAL;PROCEDURE stnS(stn:Word;VAR dumS:Min_string); EXTERNAL;PROCEDURE Err_message; EXTERNAL; {uses <error>}PROCEDURE Starcmd; EXTERNAL;PROCEDURE Log_off; EXTERNAL;Procedure Print(var txt:Min_string);{Procedure to place contents of string into print buffer. If buffer doesnot have enough free space, it is purged first}VARa:Byte;BEGINWHILE ((print_space-print_ptr+print_size)MOD print_size) {no of chrs in buffer}  > (print_size-length(txt)) DO BEGIN  List_OT(print_buff[print_ptr]);  IF print_ptr=print_size THEN print_ptr:=1 ELSE Inc_W(print_ptr)END;For a:=1 TO length(txt) DO BEGIN  print_buff[print_space]:=ord(txt[a]);  IF print_space=print_size THEN print_space:=1  ELSE Inc_W(print_space)ENDEND;Procedure Instructions;BEGIN writeln(' SJ Research Printer Server version ',verA:1,'.',verB:1,verC:1); {writeln('Very Dubious ARGO }writeln;Writeln('Operator commands :');Writeln;Writeln('F   - flush printer buffer');Writeln('M   - messages off/on');Writeln('Q   - quit');WritelnEND;Procedure Finish_print;VARdummy:Byte;BEGINPrint(end_text);print_active:=false;IF messag THEN BEGIN  StnS(client_stn,aS);  Writeln('Stn ',aS,'end print')END; {Now acknowledge final packet}Ecotx(rx_seq,print_port,print_stn,addr(printRx),1,dummy);print_stn:=0 {Only non-0 if we are talking to someone}END;BEGIN {Main block}print_ptr:=1;print_space:=1;print_stn:=0; {Only non-0 if we are talking to someone}time_out:=0;print_active:=false;print_waiting:=false; {If TRUE, we have an RxCB open}pre_text:='';post_text:=Concat(chr(13),chr(10)); {CR,LF}banner:='***  SJ Research Econet ';no_banner:=false;end_text:=chr(12);Ecoini;Writeln(chr(17)); {ctrl-Q disables page wait on RML}Instructions;messag:=True;Writeln('Ready');REPEAT {Main loop}  Rxset(blockno,cmdport,0,Addr(mainRX),min_size+5);  WHILE NOT Rxread(blockno,rx_seq,b,client_stn,w)    DO BEGIN{operator commands}    IF Inkey(ch) THEN CASE Land(Ord(ch),5FH) OF       70:BEGIN {Flush print buff}            Writeln('Flushed');            print_ptr:=1;            print_space:=1          END;       77:BEGIN            messag:=NOT messag;            Write('messages ');            IF messag THEN Writeln('On') ELSE Writeln('Off')          END;       81:Fs_exit; {exit to outside world}     OTHERWISE Instructions    END; {of Case}{Try to empty print buffer}    WHILE (print_ptr<>print_space) AND List_ST DO BEGIN      List_OT(print_buff[print_ptr]);      IF print_ptr=print_size THEN print_ptr:=1  {wrap round buffer}       ELSE Inc_W(print_ptr)    END;{Try to fill print buffer}    IF print_waiting THEN IF      RXread(print_block,rx_seq,b,client_stn,blk_len) THEN BEGIN      print_waiting:=FALSE;      IF print_active OR (client_stn=print_stn) THEN BEGIN         {Either still printing or timed out & re-started}        print_active:=TRUE;        IF Land(rx_seq,1)=next_seq THEN BEGIN          next_seq:=Land(succ(next_seq),1); {Increment sequence no}          IF (NOT old_type) AND (Land(rx_seq,4)=4) THEN blk_len:=pred(blk_len);            {Control byte indicates last block, but there is a             spurious ctrl-C at the end as well }          a:=1;          WHILE a<=blk_len DO BEGIN             {Transfer data to output buffer}            IF old_type AND (printRx[a]=3) THEN Finish_print             {Old type block terminator}            ELSE BEGIN {normal byte}              print_buff[print_space]:=printRx[a];              IF print_space=print_size THEN print_space:=1               ELSE print_space:=succ(print_space)            END;            a:=Succ(a)          END; {while}          IF (NOT old_type) AND (Land(rx_seq,4)=4) THEN Finish_print           {Usual terminator}        END      END ELSE BEGIN {Not active, so should be log-on}        IF print_stn<>0 THEN Print(end_text);         {Terminate timed-out user}        StnS(client_stn,aS);        old_type:=printRx[1]<>0; {Character sent indicates protocol}        IF messag THEN BEGIN          Writeln('Print stn=',aS);          IF old_type THEN Write('Old') ELSE Write('New');          Writeln(' protocol')        END;        print_stn:=client_stn;        IF NOT no_banner THEN Print(pre_text);        Print(banner);        IF NOT no_banner THEN BEGIN          aS:=Concat(' ***  Station ',aS,'  *** ');          Print(aS);          Print(post_text)        END;        next_seq:=Land(succ(Rx_seq),1); {Initialise sequence no (=0 or =1) }        print_active:=TRUE      END    END;    IF (NOT print_waiting) AND      (((print_space-print_ptr+print_size)MOD print_size)      < (print_size-prx_size)) THEN BEGIN      { There is room in the buffer for another recieve block }      print_waiting:=TRUE;      IF print_active THEN       Rxset(print_block,print_port,print_stn,addr(printRx),prx_size)      ELSE Rxset(print_block,print_port,0,addr(printRx),prx_size);       { Acknowledge if appropriate }      IF print_active THEN Ecotx(rx_seq,print_port,print_stn,        addr(printRx),1,b);      time_out:=tim_delay    END;    IF print_active AND print_waiting THEN Dec_W(time_out);    IF print_active AND (time_out=0) THEN BEGIN      Delrx(print_block);      print_waiting:=False;  {Allows another rxblk to set itself up}      IF messag THEN Writeln('Print timeout');      print_active:=false    END  END;{ Drops through here when a packet arrives on the FS command port }  IF messag THEN BEGIN    StnS(client_stn,aS);    Writeln('Fn=',mainRX.FN:3,' Stn=',aS)  END;  CASE mainRX.fn OF    0:Starcmd;   23:Log_off;   OTHERWISE BEGIN error:=133; Err_message END;  END {of case}UNTIL False;END.