{ FSDATA  File Server data management }SEGMENT fsdata;{$Ifsdecs}VARc_ent:Byte; {Declare as global to save new copies at each level of recursion}error:Byte;bl_des:Block_descrip;{$Ifsext}PROCEDURE Scan_dir(b_list:blk_vec);{Scans (Recursively!) a directory tree, allocating the blocks which it findsto be already in use. On entry, we have the block list of a dir.These blocks will already have been counted, so we go straight on toobserving the entries which may be files or other dirs.}VARent_off,blk_off:Byte;BEGINent_off:=1; {entry 0 always exists and is reserved, so start at 1}FOR blk_off:=0 TO 15 DO IF b_list[blk_off]<>0 THEN BEGIN  bl_des.blk:=b_list[blk_off];  Alloc(bl_des);  Dec_W(free_bl[bl_des.drive]);  {Un-count it as a free block}  c_ent:=Cache_entry(bl_des,TRUE,error);  IF error<>0 THEN Writeln('Disc error')  ELSE REPEAT    WITH cache[c_ent].dir_ent[ent_off] DO  {Check if deleted}    IF next_ent<>(ent_off+(blk_off*ents_per_blk) THEN BEGIN      IF Land(access,32)=0      {'D' bit in access byte}      THEN Scan_file(ent_off)   {Gets it's context from global c_ent}      ELSE Scan_dir(block_list);      c_ent:=Cache_entry(bl_des,TRUE,error);  {c_ent is out of date}      IF error<>0 THEN Writeln('Disc error')    END;    ent_off:=Succ(ent_off)  UNTIL ent_off=0;  ent_off:=0  {For all subsequent blocks, first ent is not reserved}ENDEND;PROCEDURE Init_disc;VARch:Char;error:Byte;BEGINWrite('Number of discs :');REPEAT  REPEAT UNTIL Inkey(ch)UNTIL (ch='1') OR (ch='2');Writeln(ch);no_discs:=Ord(ch)-48;Inidsk(no_discs,error);WHILE error<>0 DO BEGIN  Writeln('Check discs then press space');  REPEAT REPEAT UNTIL Inkey(ch) UNTIL ch=' ';  Inidsk(no_discs,error)ENDFOR discno:=0 TO no_discs DO BEGIN  DDA.block.drive:=no_discs;  DDA.block.blk:=0;  {Point to root}  DDA.offset:=0;  Dir_scan(DDA)ENDEND;FUNCTION Same_blk(a,b:Block_descrip):Boolean;BEGINSame_blk:=(a.blk=b.blk) AND (a.drive=b.drive)END;FUNCTION Cache_entry(desired:block_descrip;read_in:Boolean;VAR error:Byte)  :BYTE;{ Either finds the required block in the cache or allocates a new entry. If a new entry is required, the block will only be brought in off disc if the <read_in> parameter is TRUE (it would be false for a block which is going to be re-written eg. if the block has only just been allocated) In either event, the cache entry number allocated to that sector is returnedHOW IT WORKSEach cache operation leaves the entry in question with a low age (zero=highestpriority). Before each operation, all entries in the cache have their ageincreased, unless they reach the maximum age of cache_size-1. It is notallowed to do anything other than decrease the age of an entry.This ensures that there will always be at least one entry with maximum age}VARa,ent_age:BYTE;BEGINerror:=0;FOR a:=1 TO cache_size DO BEGIN  ent_age:=cache[a].age;  IF ent_age<max_age THEN cache[a].age:=succ(ent_age)END;a:=1;WHILE (NOT Same_blk(cache[a].which_blk,desired)) AND (a<cache_size)  DO a:=Succ(a);IF Same_blk(cache[a].which_blk,desired) THEN BEGIN  cache[a].age:=0;  Cache_entry:=a  {Entry found already in cache, so set age to best value, and return entry}END ELSE BEGIN {Find oldest entry in cache}  a:=1;  While cache[a].age<>max_age DO a:=Succ(a); {Should always find one..}  IF cache[a].needs_writing THEN    Floppy(FALSE,cache[a].which_blk,addr(cache[a].data),error);  IF error<>0 THEN Writeln('Write error from cache: Blk=',desired.blk);  IF read_in THEN Floppy(TRUE,desired,Addr(cache[a].data),error);  cache[a].which_blk:=desired;  cache[a].age:=2; {not quite so favourable as twice used entries}  cache[a].needs_writing:=FALSE;  Cache_entry:=a {Return value}ENDEND;BEGINEND.