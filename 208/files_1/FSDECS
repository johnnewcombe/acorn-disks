{ FSDECS}CONSTverA=0; {Version number verA.verB verC}verB=2;verC=2;min_size=80; {Size of minibuffers}name_size=128;CR=13;cmdport=099H;data_port=1;ack_port=2; {These are both re-declared locally when they are variables}cache_size=6; {size in blocks}max_age=5; {**MUST BE cache_size-1}no_users=20; {Max number of logged on users}blk_size=1024; {Size of unit in which disc is allocated. Not easily changed. }block_size=blk_size;ents_per_block=16;words_per_block=512;M1ents_per_block=15;  {Minus 1!!}M1words_per_block=511;M1block_size=1023;buff_size=4096; {MUST be an integer no. of blocks (for save/load) }max_drive=4;print_size=1024; {print buffer size}print_port=0D1H;prx_size=128;cache_del=500; {Wait before writing cache}tim_delay=20000; {print timeout delay}TYPEDbl_word=Integer;Byte=0..255;Three_byte=ARRAY [1..3] OF Byte;Word=0..65535;Nibble=0..15; Buffer=ARRAY [1..buff_size] of BYTE;Minibuffer=ARRAY [1..min_size] of BYTE;{String types}S20string=String[20];S30string=String[30];S80string=String[80];S255string=String[255];min_string=string[min_size];Handles=RECORD  URD,CSD,lib:BYTEEND;StdRX=RECORD  reply:byte;  FN:byte;  envir:handles;  data:minibufferEND;StdTX=RECORD  cmd:byte;  rtncode:byte;  data:minibufferEND;Block_descrip=RECORD  drive:Byte;    {Often set to 255 to indicate disc changed.                  If so, it will be caught at the cache request stage}  blk:Word    {Block number. Each block is <blk_size> bytes}END;Date_type=RECORD  day:Byte;  mth_yr:ByteEND;Short_time=RECORD  hrs:Byte;  mins:ByteEND;Time_type=RECORD  hrs:Byte;  mins:Byte;  secs:ByteEND;Timedate=RECORD  date:Date_type;  time:Time_typeEND;Short_td=RECORD  date:Date_type;  time:Short_timeEND;ent_type=(E0,dir,fil);dir_flags=(exploded,xx1,xx2,xx3,xx4,xx5,xx6,xx7);blk_vec=ARRAY [0..15] OF Word;Cache_descrip=RECORD  which_blk:block_descrip;  age:Byte;  needs_writing:Boolean;  CASE Byte OF  1:(data:ARRAY [0..M1block_size] OF Byte);  2:(EB_list:ARRAY [0..M1words_per_block] OF Word);  3:(dir_ent:ARRAY [0..M1ents_per_block] OF RECORD CASE ent_type OF    E0:(bit_map:SET OF Byte;        chain:ARRAY [0..9] OF RECORD          public_ents:Byte;          owner_ents:Byte;          ent_no:Byte        END;        spare:Word        );    Dir:(Dum2:ARRAY [0..11] OF Byte;        cycle_no:Byte;        def_access:Byte;        dum1:ARRAY [14..63] OF Byte; {Items common to both}        );    Fil:(account:Byte;        name:ARRAY[0..9] OF Byte;        next_ent:Byte;        load_addr:Dbl_word;        exec_addr:Dbl_word;        extent:Three_byte;        access:Byte;        creation:Date_type;        update:Short_td; {Time & date - no secs }        Aux_acc:Byte;        flags:SET OF dir_flags;        blk_list:blk_vec        )    END    )END;Disc_address=RECORD  offset:Byte; {64 byte Offset in block : Origin is ZERO}  block:block_descripEND;fcb_flags=(in_use,write_access,yy2,yy3,yy4,yy5,yy6,yy7);fcb=RECORD  flags:SET OF fcb_flags;  DDA:Disc_address; {The directory disc address : the disc address of the                     directory entry for the file. This implicitly contains                     the drive of the file as files can't refer from                     drive to drive. Drive set to 255 if disc changed }  curr_blk:Word; {The block pointed to by the random pointer}  ptr:three_byte;   {The random pointer (PTR# in Basic)}END;user_flags=(logged_on,aa1,aa2,aa3,aa4,aa5,aa6,aa7);user_descrip=RECORD  flags:SET OF user_flags;  stn:Word;  fcbs:array[1..8] OF fcb;  {1,2 defined: 1=URD, 2=LIB}  pass_ptr:Word; {index into password file}  owner:SET of Byte;END;COMMONmainRX:stdRX;user_info:ARRAY[1..no_users] OF User_descrip;cache:array[1..cache_size] OF Cache_descrip;print_buff:array[1..print_size] OF byte;printRx:array[1..prx_size] OF byte;aux_error:min_string; {contains auxilliary error message}pre_text,post_text,banner,end_text:Min_string;free_bl:ARRAY[0..max_drive] OF Word;client_stn,cache_time,time_out,blk_len,print_stn,print_space,print_ptr:Word;  {<print_space> points to free space in the print buffer, <print ptr> points   to the next byte to be printed}no_discs,user_no,block_no,print_block,next_seq,rx_seq:Byte;messages:Boolean;  {old fashioned version of messag- too long}no_banner,stop,messag,disaster,old_type,print_waiting,print_active:Boolean;