{ PSP  Print Server Procedures & Functions }SEGMENT fsp1;CONST{$Ipsdecs}PROCEDURE FSexit; EXTERNAL;PROCEDURE Ecoini; EXTERNAL; {Initialise}PROCEDURE Rxset(VAR blockno:BYTE;port:BYTE;stn,start,length:Word);EXTERNAL;FUNCTION Rxread(blockno:BYTE;VAR ctrl,port:BYTE;VAR stn,length:Word)  :BOOLEAN;EXTERNAL;PROCEDURE Delrx(blockno:BYTE);EXTERNAL;PROCEDURE Ecotx(ctrl,port:byte;stn,start,length:Word;VAR result:byte);  EXTERNAL;PROCEDURE PutS(addr:Word;VAR srce:Min_string); EXTERNAL;PROCEDURE GetScr(addr:Word;maxlength:BYTE;VAR dest:Min_string); EXTERNAL;PROCEDURE PutScr(addr:Word;VAR source:Min_string; max_length:Byte); EXTERNAL;PROCEDURE MidS(VAR text:Min_string;start,length:BYTE); EXTERNAL;FUNCTION Land(a,b:Word):Word;EXTERNAL; {Logical AND (bitwise)}FUNCTION Hi(a:Word):BYTE; EXTERNAL;FUNCTION Lo(a:Word):BYTE; EXTERNAL;FUNCTION Cli(VAR line:Min_string):BYTE;EXTERNAL;PROCEDURE ListOT(a:byte); EXTERNAL;  {List output}FUNCTION ListST:boolean; EXTERNAL;   {List status (TRUE=ready)}FUNCTION Inkey(VAR ch:Char):boolean; EXTERNAL;PROCEDURE Dec_W(VAR x:Word); EXTERNAL;PROCEDURE Dec_B(VAR y:Byte); EXTERNAL;PROCEDURE Inc_W(VAR x:Word); EXTERNAL;PROCEDURE Inc_B(VAR y:Byte); EXTERNAL;PROCEDURE GSread(VAR in_S,out_S:Min_string;stop_on_delimeters:Boolean);EXTERNAL;PROCEDURE Hex2S(x:BYTE;VAR dummy:Min_string); EXTERNAL;PROCEDURE stnS(stn:Word;VAR dumS:Min_string);{ Returns a string giving a station number in decimal, with the two bytesseparated if it is a distant station (high byte <>0) }VARhiS:string [5];BEGINStr(Lo(stn),dumS);IF Hi(stn)<>0 THEN BEGIN  Str(Hi(stn),hiS);  dumS:=Concat(hiS,'.',dumS)ENDEND;{Error (and no error) handling routines}PROCEDURE Err_message;{Uses global <error> & sends appropriate msg to client stn. Sends 'reply OK'if error=0}VARmainTx:RECORD  cmd_code:Byte;  CASE boolean OF    True:(msg:Min_string);    False:(rtn_code:Byte)        {Overlays length of string!}END;result:Byte;len:Word;BEGINIF error<>0 THEN WITH mainTx DO BEGIN  CASE error OF      2:BEGIN msg:='Bad wildcard'; error:=0CCH END;    85H:msg:='Not possible on the Print server';   0FDH:msg:='Bad string';    OTHERWISE BEGIN Hex2S(error,msg);      msg:=Concat('PS unusual error ',msg) END;  END {Case};    IF messag THEN Writeln(msg);  msg:=Concat(msg,chr(CR));  len:=Length(msg)+2;END ELSE len:=2;{reply OK}mainTx.rtn_code:=error;mainTx.cmd_code:=0;{use rx_seq since BGET will only report errors if the sequence no. is right!}Ecotx(rx_seq,mainRX.reply,client_stn,Addr(mainTX),len,result)END;Procedure I_am(VAR cmd_text:min_string);VARa:BYTE;mainTx:RECORD cmd_code,rtn_code,URD,CSD,LIB,boot:Byte END;BEGINWITH mainTx DO BEGIN  cmd_code:=5;  rtn_code:=0;  URD:=1; {URD handle(fixed)}  CSD:=1; {CSD handle (may change later)}  LIB:=2; {LIB handle (fixed)}  Boot:=0; {Boot option (Don't !)}  Ecotx(0,mainRX.reply,client_stn,addr(mainTX),6,a)ENDEND;PROCEDURE Log_off;BEGINerror:=0;Err_messageEND;PROCEDURE Starcmd;VARcmd_text:min_string;result,cmd_code:byte;a:Word;mainTx:RECORD  cmd_code,rtn_code:Byte;  data:ARRAY[1..min_size] OF ByteEND;BEGINerror:=0;IF messag THEN BEGIN  StnS(client_stn,cmd_text); {Using cmd_text as temp store}  Write('Stn:',cmd_text,' *')END;GetScr(Addr(mainRX.data),min_size,cmd_text);IF messag THEN writeln(cmd_text);cmd_code:=CLI(cmd_text);  CASE cmd_code OF     5:I_am(cmd_text);   247:BEGIN GSread(cmd_text,banner,False);no_banner:=TRUE;Err_message END;   248:BEGIN GSread(cmd_text,end_text,False);Err_message END;   249:BEGIN GSread(cmd_text,post_text,False);Err_message END;   250:BEGIN GSread(cmd_text,pre_text,False);Err_message END;   251:BEGIN GSread(cmd_text,banner,False);no_banner:=FALSE;Err_message END;   OTHERWISE BEGIN {Unrecognised command}      error:=085H;      Err_message    ENDEND {case}END;BEGIN {dummy block}END.