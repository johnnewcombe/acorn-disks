.\ EDOC.o12.c.b.uBBC Computer Screen Editor.bIntroduction   The editor program allows the creation of text files, either documents or programs, which may be edited and neatly printed out using the integral text formatter and justifier. The editor program provides extremely flexible enter and edit facilities controlled by a cursor. These are designed for rapid composing, altering, and shifting around of text at the keyboard.   All commands to the program are in the form of single characters. The set of commands and their layout on the keyboard has been designed to use a minimum number of keystrokes while maintaining good resistance to mistakes. When a command is a letter, it may be in either upper or lower case. In order that strings containing carriage returns can be handled, input of text and all other strings is terminated not by typing {carriage return} but by0typing a special end-of-text character, control D or {EOT}. On the BBC keyboard you can use the COPY key..bGetting started  You don't need to read the whole of this document to become competent in the basic uses of the editor. The best way to begin is to run the program and then try out the most basic operations described on the next two or three pages.   On startup a message "Old text?" appears on the screen. To keep what is in memory, answer Y or y; but be warned that if memory contains anything in non-text form it may cause the editor to malfunction. In that case, start again! Anything else as a response will give you an empty memory. If you are just entering the editor then it is very convenient to just press RETURN in answer to the question.   The block marker which appears at the top left hand corner of the screen indicates the end of text in the edit buffer. The edit buffer is the portion of memory allocated to the text. It will be empty in the present instance. The group of numbers at the bottom left of the screen give the cursor X position (1 upwards), the cursor Y position and the location in memory of the first character on the screen, in this case just the end-of-text marker.   The symbol near the centre of the screen is the cursor, which is a steady cursor to make it easier for the eye to follow rapid cursor movements..bCursor control, and {ESC}   The first thing to get used to is control of the cursor position. If anything unexpected happens while you are experimenting, you may have touched some other command key by accident; the safest thing to do then is to press the {ESC} key. This never changes anything in the edit buffer, and aborts all operations which can be aborted.   The cursor can be moved around the screen with the four keys which make a diamond-shaped pattern around the + key (think of the tips of the + symbol as arrows):-.i5P p            cursor up? /            cursor downL l            cursor left: *            cursor right.i  It is worth going to a little trouble to develop an efficient right-hand position for cursor control, so that you can move the cursor around while watching the screen. It is recommended that the middle finger of the right hand is positioned over the + key, the index over cursor left, and the ring finger over cursor right. After depressing a cursor control key, the repeat key can be triggered with the little finger (or you can wait for the auto repeat to start) to give continuous cursor movement in the chosen direction. The middle finger extends up or down to operate cursor up or down, in the manner of touch typing. The keys to left and right of the diamond are accessible to the index and little fingers; they cause the cursor to jump to the start and end of a line:.i5H h            cursor homeK k            move cursor to start of current line] }            move cursor to right-hand end of current line.iThe last of these will be found useful for finding out how long a line of text is; the line may end with an invisible carriage-return character. H will cause the cursor to move the the upper left-hand corner of the screen (coordinates 1,1), which is occasionally useful..bThe Q (append to tail) and < (load) commands   When the edit buffer is empty the only way to start working on text is to use either the Q or the < command. For instance, after typing Q or q, a prompt appears on the bottom line and text may be entered. Input is terminated by typing {EOT}. Further text may be appended by doing the same again. Each time, the new text appears at the tail end of the edit buffer. {ESC} may be typed at any stage before the final {EOT} to abort the operation.   If you have typed in more than a screenful of text, some of it will lie below the screen. You can bring it into view by pushing the cursor against the bottom of the screen. To move back towards the beginning, push the cursor against the top of the screen.   If you have a text file on disk, you can load it into the edit buffer by typing < (shift comma on the Acorn keyboard), followed by the name of the file. The file name must not begin with the character line feed (for reasons to become apparent in the section on the Save command). The file name can consist of up to seven characters, and is terminated by typing {EOT} as before.   A file called for by < will always be loaded into the edit buffer, whatever the file's own load address. If a message "Press ESC to continue" appears after the < command, the file will NOT have been loaded, and an operating-system message will normally appear giving the reason. The screen will show the place in the edit buffer where the file should have appeared, and so will be blank in this case. Type {RETURN} to get back to where you were. Other ways of moving the text past the screen will be described in the next section but two..bThe message "Press ESC to continue"   This appears whenever an error is detected either by the editor or by the operating system. For instance it occurs if the user calls for an impossible operation such as pressing {delete} too many times when inputting a string. It should not be confused with another message "Press space to continue", which appears on some occasions. The latter message does not indicate any error, and usually indicates that the program is waiting for the user to decide whether to carry on with some .vvalid.z operation which has been called for..bThe basic text-manipulation commands.   These can be tried out as soon as you have some text on the screen. They are:.i5{delete}       delete character at cursorI i            .vinsert.z after cursor the character next typed X x            e.vx.zchange character at cursor for the next typedA a            insert new string .vafter.z character at cursorB b            ditto .vbefore.z character at cursorC c            .vchange.z character at cursor into new stringE e            .vexchange.z two characters{space}        insert a space at the cursor (just like I{space}).i   A temporary block marker appears over the character indicated by the cursor, upon entering any of these commands. For {delete} and {space} it will vanish fairly quickly as the command executes and redisplays the screen. In the case of I, X, A, B and C a new string of text may then be typed, as for the Q command. The string consists of one character in the case of the I and X commands, and one or more followed by {EOT} in the case of A, B, C and Q. For A, B, C and Q the string is stored temporarily in the "change buffer", which has room for 2047 characters. Insertion into the edit buffer does not take place until the {EOT} is typed. Delete and carriage return may be used normally during input, except that if a carriage return is deleted the input display will not show the effect of this correctly, and it is best to press {EOT} and treat the rest as a new insertion.   The cursor movements after I and {delete} are complementary. If you change your mind about inserting a comma, for instance, you can type {delete} to take it out again without having to move the cursor first. You can also use X on the character just inserted, again without having to move the cursor.   E must be pressed twice in order to have any effect on the edit buffer, with the cursor at one and then at the other of the two characters to be exchanged. {ESC}, as always, can be used at any stage to abort the operation.   The X command has special uses inasmuch as it enables ANY character, except {ESC} and {delete}, to be placed in memory. Note therefore that X should NOT be followed by {EOT}, unless it is desired to kill the remainder of the edit buffer by putting in a new end-of-text marker. No edit command besides X can be used to insert an {EOT}. X is also the only command which can insert {backspace} or {line feed}. Note that the last two should normally be avoided, since they confuse the display and cursor-positioning routines.   If you do type X {EOT}, a warning message "KILL?" appears; type {ESC} if you wish to make no change. If you type Y or y, the {EOT} will be inserted and you will have truncated your current edit buffer. This can be used to clear the buffer (S, H, X, COPY, Y).bScreen control   All the commands mentioned so far are .vimmediate.z commands; they are accepted without any preparatory action. Another set of immediate commands move the contents of the edit buffer past the screen..i5G g or J j     go back one frame (approximately)O o            go on one frame@              step one line back[ {            step one line onS s            go to start of textZ z            go to last frame of text.iSome of these won't do anything until you have more than one screenful of text in the edit buffer.   There are two other screen control commands, which are useful when handling large text files. These are M and {RETURN}. M marks the current screen position for subsequent use of {RETURN}. {RETURN} itself (the carriage return key, equivalent to ctrl M) will jump back to that place from wherever else you have got to. If you are at the currently marked position, a small m appears just after the memory-location readout at bottom left of the screen.   {RETURN} automatically marks the place jumped from; thus it can be used to flip back and forth between two widely separated places in a large file. If you hit {RETURN} unintentionally, you can regain your position simply by hitting it once again (but then type M if you want to stay there). There is only one other command which marks a place for {RETURN}. That is the < (load) command, which displays the position to which text is to be loaded (to make the start of the newly loaded file visible) but marks the previous position for subsequent return if desired..bString and block-move operations   Operations involving strings of text in the edit buffer are made possible by the following commands, which can be entered after a position in text has been marked with the + key. Place the cursor over the character to be marked, and type + (or ;). The + key causes a temporary block marker to appear at the marked position. A message "Marked" also appears at the bottom of the screen. The cursor can then be moved to another position before a command key is pressed. The command will operate, where appropriate, on the string marked off by the two positions. Afterwards the cursor will return to the leftmost position, i.z. the position furthest back in the edit buffer.   There is no limit on the length of the string which can be marked, although some operations will not take place if the string is larger than the change buffer. Because large strings can be marked (and thus, for instance, deleted in one operation) be careful what you do when the message "Marked" is present at the bottom of the screen. If in doubt about what keys you have just pressed, type {ESC} and start again!   There is a second warning signal to help prevent really serious accidents. Most operations which move the text past the screen will cause the temporary block marker to disappear, either because the position is no longer on the screen or because the screen has been re-displayed. In all such cases the cursor, wherever it is, will turn into a rapidly-flashing cursor.   IF THIS OCCURS WHEN YOU DON'T EXPECT IT, STOP! Then type {ESC} before doing anything else. You may, for instance, have inadvertently marked a position at the far end of the edit buffer.   The main edit commands which can operate on marked strings are:.i5{delete}            delete marked stringR r                 remove string and transfer to change bufferT t                 transfer marked string to the change bufferC c                 change marked string into new stringE e                 exchange two nonoverlapping strings.i   I, X, A and B will also work after marking, ignoring the position marked by the + key. Conversely, all commands in the last group work as immediate commands too, in which case the marked string is taken to be the single character under the cursor. E uses the sequence {+ key} E {+ key} E.   If {EOT} is typed immediately after the initial prompt put out by the A, B, C and Q commands, the previous contents of the change buffer are used. Thus the A, B, C, Q, R, and T  commands can be combined to move blocks of text around in various ways. Try, for instance, the effect of using T on some string, followed by A {EOT}. As another useful example, a marked string can be copied to the tail end of the edit buffer (e.g. for subsequent indexing or referencing operations) simply by typing T then Q then {EOT}.   None of {delete}, I and X affect the change buffer.   If you type {ESC} by mistake, instead of {EOT}, after entering a long string into the change buffer when using A, B, C or Q, you can avoid having to retype the string as follows. Simply mark the place or string in the edit buffer as before, and type the desired command followed immediately by {EOT}, just as if you were moving text copied into the change buffer by the R or T commands. The string you typed will be inserted, possibly followed by some extra material depending on how the change buffer was used previously. Provided you take this action straight away, you cannot insert .vless.z material than you typed; and if more is inserted it is a simple matter to delete it. For further notes on sophisticated uses of the change buffer, see the section on "Miscellaneous Technicalities" near the end of this document.   For handling a block of text too large to fit into the change buffer, it is sometimes convenient to use instead the marked mode of the "save" command to be described next..bThe save, append and * commands   To save the current contents of the edit buffer on to the disk, type > followed by the desired file name. Names beginning with the character line feed are not allowed. If the message "Press ESC to continue" appears after the > command, the file will probably .vnot.z have been saved, and an operating-system message will normally appear giving the reason. If you want to see what files are on the disk without resetting the system, type *CAT {EOT} or *.{EOT}.   Save will also work in marked mode. This is the most convenient way of saving part of the edit buffer.   To append a file to the end of the edit buffer, type ( followed by the desired file name. The action is then as for the < load command.   The command * sends to the ACORN operating system whatever is typed between the * and the {EOT}. It can thus can be used to enter any other system command, as well as CAT. The response, if any, of the operating system is displayed near the bottom of the screen. Normally a message "Press space to continue" will also appear, and you can then continue using the editor after pressing the space bar. If, however, the operating system detects an error, the message "Press ESC to continue" will appear instead. If the operating system has produced no additional message to explain the reason for the error, the system may need resetting. Remember to type y in answer to the query "Old text?" if you want to keep the contents of the edit buffer on re-entering the editor.   >{COPY} has a special action, designed primarily for convenience (and accident avoidance) when handling many editor files. With the > command you have to type in the name of the file when you save the current buffer and it is easy to make disastrous mistakes by saving to the wrong file.   >{COPY} allows the file name to be written once and for all into the file itself. Its action is to save the source file .vusing as the file name the word at the end of the first line in the buffer.z. The return character denoting the end of this line is assumed to occur within the first 256 locations. The very first character of the buffer could also be a return in which case the second return will be looked for. For text files the name can be written into the end of a comment line at the start of the file e.g.     .\ This is the first file: edit1   in which case the >{COPY} command would save the buffer to "edit1". >{COPY} cannot be used in marked mode.   Evidently the ordinary > command cannot be used with a filename whose first character is {COPY}. (The same applies to < and (; <{COPY} will work in the same way, but is less useful since the file name in the edit buffer is seldom relevant to a load operation.).bThe Find (F) and Continue Search (ctrl C) commandsThese search the edit buffer for a specified string, with options for replacing the string by another if desired. They can be used in immediate, marked, interactive and automatic-replace modes. If used in marked mode they will find only those occurrences of the string beginning within the marked domain. If used without marking, the cursor position is ignored and the entire region from the start of the .vcurrent frame.z to the end of the edit buffer is searched.   If you want to search the whole edit buffer, type S before proceeding. You may want to type M first, so that {RETURN} will afterwards get you back to where you were. The various options are now described..i5F/string/{EOT}   will find the first occurrence of the string within the specified domain..iCarriage returns and most other control characters are permitted in the string (although their effect will not always be displayed correctly during input). The delimiter characters enclosing the string need not be slashes; they can be replaced by any other character not occurring in the string itself..i   The search is initiated as soon as the {EOT} is entered. If the string is found, the screen is rewritten with the cursor marking the string on the second line, unless the string occurs on the very first line of the edit buffer. The cursor is placed on the first character of the string.   To abandon the search and return to the place started from, type {RETURN} (and type {RETURN} .vagain.z if you want to regain your marked position). To abandon the search and stay at the current place, type {ESC}. To continue the search, type {space}. If no further occurrences are found, a message "End of search" is output, and the place started from is returned to automatically.   To carry out an editing operation at the location found, type {ESC} then proceed normally. The search can still be continued after this by typing ctrl C. The effect of ctrl C is the same as that of F, except that the input buffer need not be re-typed. Its contents are displayed before proceeding and a message "Go on?" will appear, which can be answered Y, N or {ESC}. Take care that the contents of the buffer are what you intended, before typing Y to proceed. Otherwise you may, if unlucky, initiate an unintended automatic replace mode (see below). Note that *, > and < change the input buffer..i5F/string1/string2/{EOT}   will find string1 as above and then prompt?/string1/string2/.ito ask the user whether to replace string1 at the current location by string2. (Enough room is allocated at the bottom of the screen to cope with up to five carriage returns in the input buffer; if there are more, not all the buffer will be visible but apart from this the procedure will work.)  Typing {space} now has no effect, but you may use {RETURN} and {ESC} in the same way as before. You may also type.i5.nY y   to replace the string then find its next occurrence,N n   to leave the string alone then find its next occurrence, andC c   to replace string1 by a string other than string2, entered in the same manner as for the C command..i.jIf C followed by {EOT} is typed, replacement takes place with the last replacement string used (which for example will be string2 if option Y was chosen last).   String2 can be a null string (//), which is useful for multiple deletion operations (and also "blind" deletions of control characters which are confusing the display and therefore difficult to pin down). String1 can also be null, in which case .vevery.z character will be "found". Since by convention F places the cursor on the first character of the string, F//... is finding, in effect, the zero length string "at" the left-hand edge of the cursor. Thus F// /, for instance, will insert a space before every character in the domain searched.   Two .vautomatic.z find-and-replace modes are available:.i5F/string1/string2/R{EOT} (r will do in place of R)   will find and replace all occurrences of string1, within the specified domain, by string2..i5F/string1/string2/C{EOT} (c will do in place of C)   will find and replace all occurrences of string1, within the specified domain, by the contents of the change buffer. String2 is ignored..i.jIn current versions of the editor, these automatic find-and-replace modes will work fastest if the two strings involved have the same length.   If you enter an automatic mode by mistake, e.g. by careless use of ctrl C, hit {ESC} as quickly as possible to limit the damage!  No automatic replacement mode can be entered, however, unless the delimiter character after F is repeated at least twice more in the input buffer and its third occurrence immediately followed by one of R, r, C or c.   If the second delimiter is omitted from the input and {EOT} typed, the search will still commence. Should the string following the delimiter be found, however, a "Press ESC to continue" message will be output and no further action taken.   There are also facilities for generic searches, in which some or all of the characters in string1 can be .vany.z character in a specified equivalence class. These facilities are described in a separate section, since it is helpful first to know about the V and H commands and related matters. The user who is not interested in sophisticated facilities for the moment may wish to skip to the section on the print command..bThe F and ctrl C commands: "generic find" facilities   Sometimes it is useful to be able to look for unspecified control characters, or for all occurrences of a certain word regardless of whether the letters are capital or lower case. Another example is a string such as "model xxxx", where the xxxx might be any of the digits 0 to 9, and where occurrences of the word "model" without the number after it are to be ignored.   The generic-find facility permits a fairly wide variety of searches of this type. To use it, one enters a marked or unmarked F command exactly as described above, except that in place of the final {EOT} a single carriage return is typed. Two control V's are then typed, which cause block markers to be inserted into the input buffer up to the position below the first delimiter character, as illustrated below. One then types, below each character of string1, a "generic control character" which governs the equivalence class of characters to be looked for in the search. For example,.i5_ (ASCII 5F: shift "backspace" on the ACORN keyboard) is the generic control character which specifies that the difference between capital and small letters is to be ignored..iIn such a case the input appears on the screen as follows,.i5F/string1/XX_______.ifor the find-only option. {EOT} is typed under the second delimiter to terminate input. For the find-and-replace option, the input looks like.i5F/string1/string2/XX_______.iIf string1 contains carriage returns, however, you will have to count generic control characters carefully since not all of them will then appear under the correponding character in string1. Other specially useful generic control characters are as follows. They can be strung together in any order:.i5ctrl V  (.vvoid.z): does nothing - i.z. the character above it is treated as in the ordinary find function.ctrl @:  This will find .vany.z character, which is useful when a particular character in the middle of string1 is completely unknown.ctrl F (.vfont.z - echoed on the screen by a dash):  Finds any character of the same "font" as the proximate character in string1, e.g. any capital letter, any small letter, any control character..iMore precisely, for ctrl F the equivalence classes of characters are just the successive pairs of rows of the table of ASCII codes, when that table is arranged in eight rows by values of the leading hexadecimal digit, thus:.i5  .  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _     !  "  #  $  %  &  '  (  )  *  +  ,  -  .  /  0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?  .  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _  `  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~.i(where the first two rows are to be understood as signifying .vcontrol.z characters).To find any control character, it is recommended that ctrl. is used in string1 (with ctrl F entered below it). The search will be carried out correctly even when some of the characters sought interfere with the screen display and even though the ctrl @ itself is invisible..i5p:  (.vpseudo.z-font):  Finds any character in a given SINGLE row of the ASCII table. For example, p will find any decimal digit 0 to 9 or any of ?>=<;: if placed under a digit in string1.o:  (.vopposites.z)  finds either one of a pair of characters opposite each other in any of the four pairs of rows of the ASCII table. For example, E and U, e and u, and ctrl E and ctrl U are opposites; so o will find ctrl U as well as ctrl E if placed under ctrl E..i   The effect of any other character when used as a generic control character can be determined by seeing where the zeros are in its binary ASCII code. The generic search operates by ignoring the corresponding bits of the proximate character in string1. Note that in the prompt which appears after ctrl C or when interactive find and replace is set in motion, string1 will have changed into a set of standard equivalence-class representatives. The representatives are those class members having binary zeros at all positions being ignored: so for the "font" option, for example, the standard representatives are ctrl @ for control characters, {space} for figures, shifted figures, and their relatives in the same two rows of the ASCII table, @ for capital letters and their relatives, and dash (ASCII $60) for small letters and their relatives. Note also that ctrl F and ctrl V are specially treated by the input buffer to produce ASCII 60 and FF respectively.   Since negative characters (ASCII codes > 7F) cannot be directly input from the keyboard, generic find ignores bit 7 of the characters searched for, unless a negative generic control character is input..bThe V and W commands   The V command counts the number of words in either the whole text buffer or in the currently marked string. It displays the information as a decimal number at the bottom right of the screen.   The W command displays the address of the {EOT} which marks the end of text in the edit buffer. The information is displayed as a hexadecimal number at bottom right of the screen..bThe print (U) command   Typing U outputs text to the printer. The U command can be used in immediate or marked mode. In immediate mode, the whole of the edit buffer will be output, in marked mode just the marked string. The print layout is controlled by the format commands to be described the next section. The last character in the edit buffer must be a carriage return. Text will be split up at word boundaries for printing out in the output line size. The two characters indicating word boundaries are space and return. To stop the system splitting at a space (e.g. to stop 2 Hz appearing on two lines) the line feed key can be used instead of a space. On the screen this will appear as a down arrow (character hex 1F) but during printing it will appear as a space.   Before any printing takes place, a prompt "Daisy?" appears. Answer Y for a daisy-wheel printer, N for formatted output directly to your own screen, and {ESC} if you didn't really mean it. The editor then prompts "Page wait?": answer Y or N according to whether you want to pause for new paper at the end of each page. Printing then commences. The default page-size setting is suitable for A4 paper..bFormatter commands   The formatter commands are built into the text. They are single-letter commands preceded by "." [if "." is inconvenient to use, the .x command will allow it to be changed to anything else] :-.i5.x!.aN       allow for N lines blank here (throws page if no room).b        print line in bold letters (daisy-wheel only).c        centre this line.d        double-space the following lines.f        right-flush this line.g<name>  get file <name> and continue printing.h        half line feed down (daisy-wheel only).iN       set left margin to number; if none, to zero.j        justify lines to right margin.k        suppress line feed at the end of this line.l        set line zero of the page (assumed initially).m        equivalent to temporary indent zero.n        suppress justification.oN       output character N to printer (decimal ASCII code).pN       set page number to N (default 1 initially).rN       set right margin to column number N.s        single-space the following lines.tN       temporarily indent line.u        underline this line (daisy-wheel only).v        turn on persistent underline (daisy-wheel only).wN       wait after N lines (set number on page, default 60).w        throw rest of page with page number at end.xC       exchange current formatter ch!racter to next character.y        set centred line numbers mode.z        turn off persistent underline (daisy-wheel only).\        causes rest of line not to be printed.U        half line feed up (daisy-wheel only).D        half line feed down (daisy-wheel only)!i   N represents a decimal number, which is taken to be 0 if not present. No spaces are allowed in N. C represents any character.   Except for!i5.v, .z, .U, and .D,!iformatter commands may at present occur in two places: (1) after other formatter commands, (2) at the start of an original text line (just after a return or at the start of the buffer). The four exceptional commands just mentioned may, however, occur anywhere and are useful for underlining individual words, and printing superscripts and subscripts on a daisy-wheel printer. .h works only at the beginning of a line.   The .g command should have the file name immediately following the z and should have a return at the end of the name, thus     .gtest   This document is actually held as three independant files on disk with appropriate get commands at the ends of the first two. If you are using .g then you should have all monitor systems (e.g. *NOMON in Acorn DOS) turned off, otherwise the load of the new file will get written out to the printer.   "Persistent underline" means that all following characters will be underlined up to the next .z or carriage return, whichever occurs soonest. The character . will be printed as itself if not followed by a valid formatter argument; fornstance .{space} will always be printed as . .!x.   The .k command causes the following line to be printed on top of the line with the .k, and the counting of lines per page is compensated accordingly. Its main use is to allow a centred and a right-flush and/or a left-flush string string all to be printed on the same line, as is required in some technical applications. In the following example, the three strings are entered on .vsuccessive.z lines on the screen, preceded by the formatter commands  .k, .k.f, and .c respectively:.kfirst string.k.fsecond string.cthird string   Attempts to print too long a line centred or right flush may cause the printer to reset and the print operation to be aborted, on some printers.   The formatter, if requested via the j command, will right-justify text, splitting the text at spaces by inserting 1/120th inch pitch spacing between characters on the daisy wheel, and appropriate spaces on the screen. The formatter will not justify a line ending in a carriage return. The formatter assumes an initial setting of '.j.s.l.p1.i.r70.w60' with no underline. The title line of this document carries the format command ".b.u.c"..bMiscellaneous technicalities   To realize the full power of the software for rapid editing, it is recommended that variable repeat rate be installed on the keyboard. As the user develops skill he will want to move the cursor faster and faster!  On the ACORN keyboard the required modification is very easy:  simply replace R5 by a 50K or 100K resistor in series with a one megohm variable resistor. It may also be found convenient to suppress automatic repeat-after-wait, by removing R6. The change buffer begins at location 2800 and ends at 2FFF, while the edit buffer begins at 3000. Checks are made to warn the user when the capacities of the main edit buffer and change buffer are exceeded.   When the change buffer becomes full during input from the keyboard, a message will be output and no further text accepted. The contents of the change buffer, as they stand, can still be recovered by inserting them normally using any of A {EOT}, B {EOT}, C {EOT} or Q {EOT}. If the change buffer becomes full during a T or R command, a warning is output and as much text as possible is copied into the change buffer. If an R command is being used, then the delete part of the operation will not take place.   If an A, B, C, E, Q, R, T or F/../../ command is used causing fresh input to the change buffer, then its previous contents become temporarily inaccessible. However, they are still present in memory apart from the part overwritten by the largest new string that has been introduced. If that string is not too large, and you subsequently want to recover the remaining contents of the change buffer, this can easily be done. Start by entering an A,B,C or Q command and inputting any string one greater in length than the largest new string. Then press {ESC} in place of {EOT}. The effect on the change buffer is to overwrite both the unwanted string and its {EOT} terminator, freeing the rest of the change buffer for subsequent use.   A string insertion or append from disk could cause the edit buffer to overflow, in which case a message is output and the insertion will not take place. One way to recover the contents of the change buffer in the first case is to save all or part of the current edit buffer using global or marked save (>), clear all or part of the edit buffer using X {EOT} Y, and then type Q {EOT}.   If you have saved a file from an edit buffer which is larger than the edit buffer into which you are trying to reload it, then the end of the file will be missing. This may also occur when using the append command.   If the wanted part of the disk file is even longer than the edit buffer for some reason, you can recover more of it by LOADing it to the start of the change buffer instead, usually location 2800. When the editor is re-entered you can then, as before, save and delete those parts of the file which have been loaded into the edit buffer.   When enough room has been made you can recover the part of the file which fell within the change buffer, less its first and last characters, by the procedure already described for recovering large strings from the change buffer. On entering the editor and typing "N" the change buffer was set to a null state with an {EOT} in its first position. Therefore enter an A,B,C or Q command, type exactly one character (any sensible character) into the change buffer, and then press {ESC}. The remainder of the change buffer can now be inserted at the beginning of the edit buffer by moving the cursor to the beginning and typing B {EOT}. The character you typed into the change buffer will now appear at the first place in the edit buffer. This place can easily be repaired using X, and the place corresponding to the other lost character, which was originally loaded to the far end of the change buffer, can be repaired using I.   Two internal consistency checks are made by the editor on its own working. The user need not be aware of these unless a fault of some kind arises. For the sake of speed the insertion and deletion routines recalculate the position of the top of the edit buffer after each editing operation, rather than directly searching for the {EOT} at the end each time. It is annoying for the user if the delay to insert every comma is too long. Several kinds of malfunction could cause the calculated size to disagree with the actual position of the {EOT}, and the subsequent effects on the edit buffer could be disastrous. Consequently a check for agreement is made every time {ESC} is pressed during or after after an edit operation (this accounts for some of the slight delay which then occurs). The check is made on a few other occasions as well. If the check fails, a message "Edit buffer error t" is output. This should normally not happen; if it does, the cause is either a software bug or a hardware fault.   The other internal consistency check made by the editor program is as follows. Certain routines insert temporary {EOT} markers into the edit buffer; for example E does this since there is a large gain in speed as a result. Marked save and marked print are the other two routines which do it at present. In each case the temporary {EOT} is inserted just to the right of the rightmost mark. Again in the case of a fault either in software or hardware it is conceivable that the process of restoring the edit buffer to normal after such operations could malfunction and insert a spurious {EOT} marker in the edit buffer. The check already referred to will show this up sooner or later. An additional check, which can detect some malfunctions immediately, is made every time the temporary {EOT} is about to be swopped back for the character which was there before the operation was entered. The check is whether the re-swopping process is about to .vinsert.z an {EOT}. If this is so, the swop is aborted and a message "Edit buffer error s" is output. Again, you should never see this in normal operation. If you do see it, it is probably best to reset the system, re-enter the editor with the "y" response to the question "Old text?", check that all your text is still there, and save all of it on disk before investigating further.   If for some reason you reset the system while the editor is manipulating text, the result will of course be unpredictable and possibly unpleasant. In particular, a reset just after setting any of the above operations in motion could leave the temporary {EOT} in position, and on re-entry the editor will have no way of knowing that this {EOT} is not the wanted one. If you think this may have happened, press Z and inspect the end of the edit buffer before doing anything else. The damage may still be easily repairable.   The input buffer used for *, <, > and F will accept almost any character. But ctrl V and ctrl F, as well as {ESC} and {EOT}, are treated specially - see Generic Find. The change buffer ignores {backspace} but treats no other character specially apart from {ESC} and {EOT}. It should be remembered that some control characters confuse the display or have special effects on the operating system - e.g. ctrl U will cause the editor to hang up on its first attempt to write out the screen..w