.x||\  prin4|t3The first problem encountered when drafting a preliminary specification was the size of file names. The simplest approach is to remove the last character of the name part of a CP/M filename, yielding a 10 character filename which fits the limit set by the file server. Whilst the prototype was implemented in this way, this is by no means ideal for a final version as the last character is often significant. A far neater solution is to treat the extension as a directory name, since this gives a very close parallel with the intended use of the extension to specify the type of a file. The problems assocated with this are purely in terms of effort required to implement all the consequences  : it may now be necessary to create a new directory each time a file is saved. Also, when a directory listing is requested, it is necessary first to check which directories are present and then to list each one separately if the simulation of CP/M is to be complete.|t3A further problem related to file names is that the file server only allows a restricted range of characters in file names, and also treats lower case letters as equivalent to upper case. CP/M has no defined range of allowed characters : indeed, certain applications programs allow the creation of files with lower case names which can not then be deleted with the standard delete command. Case equivalence is perhaps an advantage. Not so convenient is the fact that the file server treats '$' as a reference to the root directory, while '$$$' is used by convention in CP/M systems for temporary files. The sloution here is to translate '$' into one of the legal characters, such as '!', but the limit on the total number of legal punctuation characters means that most will remain illegal, which could cause problems in some obscure applications.|t3It is necessary to provide a facility to enter commands to be sent to the file server. In CP/M, there is no facility for applications programs to send commands to the operating system : all the facilities are provided for machine code programs to obtain directory information, for example, but each application program must provide its own command, and perform its own formatting of the information on the screen. This leads to better implementations of the standard commands, but no possibility of inserting extra ones. The command interpreter in the operating system itself can be re-written to include extra commands, and to take advantage of the fact that Acorn systems have a special facility for faster loading of complete files, rather than record by record, but this does not entirely solve the problem. One approach is to require that users select the correct disc environment - log on, select the correct directory etc. - before starting a language or applications program. However, there will often be a requirement to select a different directory to read a shared database, or to change the password protection on a file, in the middle of some applications program. The soloution adopted is to allow operating system commands to be issued by user programs by 'printing' an escape sequence to the console output, in the manner used by some VDUs to achieve special effects. The command is preceded by the character 'escape' and a star to separate it from normal output. The other possibility is to make use of some of the existing commands - an attempt to load a file of no name could enter a mode where commands may be entered, for example, but most permutations of this sort are confusing to the user without being any more universal than the type described above.|t3The remaining problem with file server access is concerned with the way machine code programs request files from CP/M. In all Acorn systems, the user passes the file name to the operating system and is given in return a channel number which refers to that file until the channel is 'closed' ; there is a restriction on the number of active channels at any one time since the operating system must keep some information about the current state of the file. In CP/M, the user passes to the operating system an area of memory in which such information is to be kept : the only restriction on the number of open files is the amount of available memory. This is not vitally important, since the number of active files at any one time is usually very small, but CP/M programs often do not bother to close files to which no change has been made. For a system with a network, it is not practical for the file server to make use of the memory in the client, so a limit has to be made. CP/NET also suffers from this problem, and imposes a limit of 8. One approach, which provides a limited solution to the problem, is to close all files each time the operating system is restarted. Also, if a note is made of which memory areas refer to which files, a common case can be detected where a program opens another file using the same memory, the first file being implicitly closeThe complete soloution is to keep a record of which files are currently open, and to close the least recently used when the limit is exceeded. In this way, the limit can be made totally invisible as files are re-opened automatically if they are used again having been closed to make way for others. Almost all existing software can be used unchanged with the network, whether it conforms to the file closing rules of CP/NET or not.|x..gprin5