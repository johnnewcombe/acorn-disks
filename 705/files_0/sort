.x|| \ sort|c|u|bSorting Techniques|u 1. Methods|bShell SortThis is similar to a simple bubble sort, but at each stage the list of items is split into two and sorted individually by the same method -  sorted pairs are prepared, which are then sorted into fours which are then sorted into 8's etc.|bHeapsortA heap (in this context) is a binary tree structure of near-uniform depth : the deepest level of the tree has nodes missing at one side unless the tree has (2^n)-1 elements. In addition, the tree has the property that the value associated with each node is greater than either of the two nodes below it. To perform the sort, the largest element is removed (which is easy as this must be at the root) and the heap property is then restored by exchanging elements ready to remove the next value.|bQuicksortThis technique choses an element in the input data and divides the remaining elements into (unsorted) sets of those greater than, equal to, and less than the referance. The unsorted sets are then sorted by a recursive call to the quicksort routine until the trivial case of sets containing one or less elements is reached. The difference between this and the Shellsort is that this splits up the list by value rather than by original position.|u 2. Advantages / disadvantages|bShellsort?|bHeapsortThis is a very efficient sort, requiring only n Log n comparisons to sort any list of n elements. It is, however complex to implement.|bQuicksortThis is of order n^2, but in many cases will sort very rapidly - the actual sort time depends upon luck with the method chosen for selecting reference elements. In particular, if the data is already sorted approximately, the simple method of taking the first element as the reference fails dismally and the worst-case n^2 comparisons will occur. If the median is guessed (by some means) very rapid sorting occurs. It can be worthwhile to calculate the median by some statistical method on a small sample of the data. Overall, a fast but unreliable sort, easy to implement.