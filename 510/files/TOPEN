|c|uListing 1   10 REM Econet Open file routines   20 REM ARG, KSJ, SRL   30    40 REM This program attempts to deal with the problems of   50 REM  a) handling errors within BASIC programs (see FNopen_CMOS)   60 REM  b) how NOT to generate errors in the first place (FNopen_NMOS)   70 REM   80 REM The need for a) is because   90 REM BASIC's error-handling (ON ERROR ...) cannot be used within a  100 REM PROCedure/Function, FOR/NEXT loop etc, etc.  110   120 REM The need for b) is because  130 REM 'NMOS' 6502 CPUs (ie 6502s as opposed to 65C02s) will  140 REM crash if an NMI occurs during a BRK instruction. All errors on the  150 REM BBC OS happen by executing BRK instructions, and ANY frame on the  160 REM network, whether addressed to your local machine or not, will cause  170 REM NMI. The fact there are 8 such frames in any communication with a  180 REM File Server makes things much worse!  190   200 REM Note:  210 REM BBC model Bs and B+s have NMOS 6502 processors: only 'Master'  220 REM series microcomputers have CMOS (65C12) processors.  230   240 timeout=30    : REM a thirty second timeout  250 DIM name 80  260 $name=""  270 osbyte=&FFF4  280 osword=&FFF1  290 osfind=&FFCE  300 brk_vec=&0202  310   320REM initialisation for 'open_NMOS'  330 DIM Tx_buffer 100  340 handle_base=FNread_handle_base  350   360REM initialisation for 'open_CMOS'  370 DIM code% 80  380 PROCassemble  390   400 got_anfs%=FNis_anfs  410   420REM FNopenup is now ready for use  430REM so main program goes here...  440 INPUT"Object name: "A$  450 PRINT"Doing"  460 h%=FNopenup(A$)  470 PRINT h%  480 IF h%<>0 THEN CLOSE#h%  490REM ...to here  500   510 END|w  540DEFFNopenup($name)  550   560 REM this is the BASIC function to open a file,  570 REM File is opened for update  580 REM Routine retries if "already open" error returned by file server  590 REM   Entry parameter is file name to be opened  600 REM   Returns File handle if open worked  610 REM     Returns zero if file not found  620 REM     Ends program if open times out (30 seconds)  630 REM     Ends program immediately if other error occours  640   650 REM Error number &C2 is the 'Already Open' error  660 REM Error number &D6 is the 'Not found' error  670   680 REM both functions use the value of the global variable '$name'.  690 REM $name is stored as a string of ASCII characters  700 REM starting at location 'name', terminated with a CHR$(13).  710 REM MOS routines require strings to be in this format.  720   730   740 IF got_anfs% THEN =FNopen_CMOS ELSE =FNopen_NMOS  750   760   770REM ie IF we have ANFS then we MUST use open_CMOS (open_NMOS won't work)  780REM       otherwise use open_NMOS  790REM In the case of ANFS and a NMOS 6502 we risk crashing the processor  800REM but that is the best that we can do.|w   840DEFFNopen_NMOS  850REM This version uses 'FSCALL' which a routine that allows direct  860REM communication to the FileServer.  870   880REM The advantage of using FSCALL instead of OSFIND is that, except  890REM in the case of 'Net' errors (eg Not listening), FSCALL does not  900REM cause a BRK instruction to be executed.  910REM Its disadvantage is that,  920REM in the case of the 'OPEN FILE' call, it bypasses the  930REM routine which converts FileServer-format handles  940REM into NFS-format handles. With NFS 3.34 & 3.6 this is quite  950REM easy as the translation is well defined. However with the  960REM ANFS no direct translation is possible: as far as the ANFS  970REM is concerned, any handle will cause a 'Channel' error  980REM unless it has been opened using OSFIND (or *I AM, *DIR).  990  1000REM This means that 'open_NMOS' WILL NOT WORK WITH ANFS. The only 1010REM machines to be adversely affected are ordinary BBCs with ANFS 1020REM ROMs fitted.|w(DEFFNopen_NMOS continued...)  1040 REM set up FSCALL Buffer as follows:- 1050 REM   0: <0> 1060 REM   1: number of bytes to send = 9+LEN(object name)+1 1070 REM   2: <0> 1080 REM   3: Function code   - = 6  for OPEN 1090 REM   4,5,6: all <0> 1100 REM   7: File Must Exist - =1 for OPENUP 1110 REM   8: File Open R/O   - =0 for OPENUP (use 1 for OPENIN) 1120 REM   9: object name, terminated <cr> 1130  1140 LOCAL A%,X%,Y%,then% 1150 then%=TIME 1160  1170REPEAT 1180 REM set up FSCALL Buffer 1190 Tx_buffer?0=0          :REM 'reason code': 0 means 'talk to F.S.' 1200 Tx_buffer?1=9+LEN($name)+1 1210 Tx_buffer?2=0 1220 Tx_buffer!3=6 1230 Tx_buffer!7=&0001             :REM magic for openup 1240 $(Tx_buffer+9)=$name 1250  1260 X%=Tx_buffer:Y%=X% DIV 256 1270 A%=&14 : REM code for FSCALL 1280 CALL osword 1290  1300 REM result is now in Tx_buffer: 1310 REM   Offset    Contents      If worked           If failed 1320 REM     2      Command code    =0?                 =?? 1330 REM     3      Return Code     =0                  non-zero (=error no) 1340 REM     4      Data            Required Handle     String term by cr 1350  1360 Error=Tx_buffer?3 1370 IF Error=&C2 THEN PROCwait(100) :REM don't thrash FS 1380UNTIL (Error<>&C2) OR (TIME > then%+timeout*100) 1390 REM go round again if "Already Open" 1400  1410 IF Error=0 THEN =FNconv_fs_usr(Tx_buffer?4) : REM convert to NFS format 1420 IF Error=&D6 THEN =0 : REM 'Not found' should give a handle of ZERO 1430  1440 REM drop through to handle other errors 1450  1460 Tx_buffer?2=0                       :REM insert a BRK instruction 1470 Tx_buffer?(4+LEN($(Tx_buffer+4)))=0 :REM insert <null> as term. 1480 CALL Tx_buffer+2 : REM cause a BRK|w  1510DEFFNconv_fs_usr(Fs_ver%) 1520 REM takes a single fs format handle and converts it to NFS format 1530 REM NOTE: not suitable for use with ANFS, Master series etc. 1540  1550REM FS-format handles go: 1,2,4,8, etc; NFS-format goes 32,33,34, etc 1560 IF Fs_ver%=0 THEN =0 : REM special case for zero handle 1570  1580 LOCAL I% 1590 I% = handle_base-1 1600 REPEAT 1610  Fs_ver%=Fs_ver% DIV 2 1620  I%=I%+1 1630 UNTIL Fs_ver%=0 1640=I% 1650  1660  1670  1680  1690DEFFNis_anfs 1700 REM Function tests for presence of ANFS 1710 REM Returns "TRUE" if ANFS present, else "FALSE" 1720 REM tests by reading and attempting to change retry rates 1730 REM   which only works on ANFS (This is the "official" way - Eugh!) 1740  1750 LOCAL A%,X%,Y%,T%,!name,name!4 1760 A%=&13                   :REM osword 13 1770 X%=name: Y%=X% DIV 256 1780 ?X%=15                   :REM function code for "Read Retry Rates" 1790 CALL osword 1800 REM now &FFFFFF AND name!1 contains current retry rates for ANFS 1810 REM   but on NFS will contain garbage 1820 T%=X%!1                  :REM preserve current values 1830  1840 REM now try to change the values 1850 X%!1=T% EOR &AA0000 1860 ?X%=16                   :REM function code for "Write Retry Rates" 1870 CALL osword 1880 REM . . . and see if we succeeded in changing values 1890 X%!1=T%                  :REM restore original values 1900 ?X%=15                   :REM function code for "Read Retry Rates" 1910 CALL osword 1920 IF X%!1<>(T% EOR &AA0000) THEN =FALSE :REM not ANFS as value Read was 1930                          :REM not the same as value Written 1940  1950 REM here if ANFS is present 1960 REM restore original Tx/Rx delay values 1970 X%!1=T% 1980 ?X%=16                   :REM function code for "Write Retry Rates" 1990 CALL osword 2000=TRUE 2010  2020DEFFNread_handle_base 2030 REM gets the lowest possible handle number from the current filing system 2040 REM Uses OSFSC, A=7: Result returned in X 2050  2060 LOCAL A% 2070 A%=7 2080=(&FF00 AND USR!&21E) DIV 256:REM JSR(osfscv) - no direct call address|w  2130DEFFNopen_CMOS 2140 REM This version of function assumes NMI/BRK interaction does not occur 2150 REM It will work with either NFS or ANFS, but has the possibility 2160 REM of crashing on a NMOS 6502 2170  2180 LOCAL A%,X%,Y%,then% 2190 then%=TIME 2200 X%=name:Y%=X% DIV 256      :REM [YX] points to name of object 2210  2220 REPEAT 2230 A%=&C0 : REM value for OPENUP (use &40 for OPENIN) 2240 A%=USR(open_code) AND &FF : REM set A% to value of 6502 Accumulator 2250 REM A=&FF means an error of some sort occured, with ERR=error number 2260  2270 IF A%=&FF AND ERR<>&C2 THEN REPORT: PRINT" - error in Open":END 2280 IF A%=&FF THEN PROCwait(100) 2290 REM Wait 1 second after an 'Already Open' to avoid jamming FS/network 2300  2310 UNTIL A%<>&FF OR TIME > then%+timeout*100 2320  2330 IF A%=&FF THEN REPORT:PRINT;" - Open timed out":END 2340=A% 2350  2360DEFPROCwait(n) 2370LOCAL then% 2380then%=TIME 2390REPEAT UNTIL TIME>then%+n 2400ENDPROC 2410  2420  2430DEFPROCassemble 2440 FOR pass=0 TO 2 STEP 2 2450 P%=code% 2460[OPT pass 2470  2480.open_code 2490\ On entry, A holds the type of open reqd - &40, &80 or &C0 (as osfind) 2500  2510\ On exit, 2520\  A=0 => file not found 2530\  A=&FF => error occured 2540\  else A=handle 2550  2560 LDX brk_vec                  \ save the old BRK handling routine address 2570 STX brk_vec_store 2580 LDX brk_vec+1 2590 STX brk_vec_store+1 2600  2610 SEI                          \ changing vectors is dangerous! 2620 LDX #(fail_rtn MOD 256)      \ install our alternative BRK routine 2630 STX brk_vec 2640 LDX #(fail_rtn DIV 256) 2650 STX brk_vec+1 2660 CLI 2670  2680 TSX                          \ save current value of stack pointer 2690 STX stack_store 2700  2710 LDX #(name MOD 256)  \ now try the open 2720 LDY #(name DIV 256) 2730 JSR osfind                   \ Returns handle or zero in A 2740                              \ or jumps to fail_rtn if an error occured 2750  2760.wind_up 2770  2780 SEI                          \ restore the old BRK vector and return 2790 LDY brk_vec_store 2800 STY brk_vec 2810 LDY brk_vec_store+1 2820 STY brk_vec+1 2830 CLI 2840 RTS                          \ with handle in A 2850  2860.fail_rtn                     \ an error has occured 2870  2880 \ MOS has set (&FD) to point to ERR byte 2890 \ which BASIC uses for REPORT and ERR 2900  2910 LDX stack_store              \ Reset stack 2920 TXS 2930 LDA #&FF                     \ Flag error condition 2940 JMP wind_up                  \  ... and return 2950  2960.stack_store 2970 EQUB 0 2980.brk_vec_store 2990 EQUW 0 3000  3010]:NEXT 3020ENDPROC