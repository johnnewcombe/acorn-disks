{ FSP2  File Server Procedures & Functions }External FS::fsp2(2);{$E+ Extended error messages}{$C- No ctrl-C check}{$L- No listing}PROCEDURE Star_info(VAR fname:min_string);VARA,result:BYTE;fiddle$:min_string;fcb1:fcb;BEGINExtract(fiddle$,fname); {deal with quotes etc.}A:=Fcb_no(mainRx.envir.CSD);IF A=0 THEN result:=222 {'channel' error}ELSE Block(fcb1,user_info[user_no].fcbs[a],fiddle$,result);IF result=0 THEN BEGIN  Open(fcb1,rd,result);  IF result=0 THEN BEGIN    Get(fcb1,addrint(big_buff[buff_size]),128,result);    Close(fcb1)  ENDEND;IF result=0 THEN BEGIN  Append(fiddle$,'    ');  FOR a:=0 TO 3 DO Append(fiddle$,Hex2$(big_buff[buff_size-3+a]));  Append(fiddle$,'  ');  FOR a:=0 TO 3 DO Append(fiddle$,Hex2$(big_buff[buff_size-7+a]));  Append(fiddle$,'  ');  FOR a:=0 TO 2 DO Append(fiddle$,Hex2$(big_buff[buff_size-10+a]));  mainTX.cmd:=4;  mainTX.rtncode:=0;  a:=Length(fiddle$);  Putstr(addrint(mainTX.data[min_size]),fiddle$);  mainTX.data[min_size-a]:=13; {Terminators}  mainTX.data[min_size-1-a]:=128;  TRANSMIT(0,mainRX.reply,client_stn,addrint(mainTX.data[min_size-1-a])    ,a+4,result);  IF result<128 THEN notlisteningENDELSE Err_message(result)END;PROCEDURE Star_delete(VAR fname:min_string);VARA,error:byte;real_name:min_string;fcb1:fcb;BEGINExtract(real_name,fname);A:=Fcb_no(mainRx.envir.CSD);IF A=0 THEN error:=222 {'channel' error}ELSE Block(fcb1,user_info[user_no].fcbs[a],real_name,error);IF error=0 THEN Delete(fcb1,error);IF error=0 THEN ReplyOK ELSE Err_message(error)END;PROCEDURE Save;CONST wait_count=MAXINT;VARbytes_left,fsize:dbl_word;fname:STRING name_size;RXCB,result,ack_port,errno:BYTE;save_size,a,block_size,buff_ptr:INTEGER;abort,error:BOOLEAN;fcb1:fcb;BEGINack_port:=mainRX.envir.URD;  {ack port in URD slot for no good reason!}getstrCR(ADDR2(mainRX)-min_size+12,name_size,fname);{Usually, files have a header added containing the load & execute addressesplus the length. If the file name has /C added, it is treated as a straightCP/M file and does not have a header added.}IF index(fname,'/C')<>0 THEN BEGIN  buff_ptr:=0; {No header on file}  Mid$(fname,0,index(fname,'/C')-1)END ELSE BEGIN  {Transfer load, execute,size to file}  FOR a:=1 TO 11 DO big_buff[buff_size+1-a]:=mainRX.data[min_size+1-a];  buff_ptr:=11END;FOR a:=1 TO 3 DO BEGIN  fsize[a]:=mainRX.data[min_size-7-a];  bytes_left[a]:=fsize[a]END;fsize[4]:=0;bytes_left[4]:=0;MSG('Name :');Msgln(fname);MSG(' Size :');dbl_print(fsize);MSGLINE;abort:=FALSE;error:=FALSE;A:=Fcb_no(mainRx.envir.CSD);IF A=0 THEN errno:=222 {'channel' error}ELSE Block(fcb1,user_info[user_no].fcbs[a],fname,errno);IF errno=0 THEN Open(fcb1,wr,errno);IF errno<>0 THEN BEGIN  error:=TRUE;  abort:=TRUE;  Err_message(errno)END;IF NOT error THEN BEGIN  block_size:=buff_size-buff_ptr;  block_size:=Land(block_size,32767-127); {must be able to save whole block}  mainTX.cmd:=1;  mainTX.rtncode:=0;  mainTX.data[min_size]:=data_port;  mainTX.data[min_size-1]:=Lo(block_size);  mainTX.data[min_size-2]:=Hi(block_size);    IF NOT dbl_zero(fsize) THEN RXset(rxcb,data_port,client_stn,    ADDRint(big_buffer[1]),buff_size-buff_ptr);   {must be ready to Rx immediately after transmission}    TRANSMIT(0,mainRX.reply,client_stn,addrint(mainTX.data[min_size-2])    ,5,result);  IF result<128 THEN BEGIN notlistening; abort:=TRUE END;    WHILE NOT (abort OR dbl_zero(bytes_left)) DO BEGIN    a:=wait_count;    REPEAT      a:=a-1;      IF a=0 THEN abort:=TRUE;         {Written this way because <abort> must not be set to FALSE}    UNTIL (RXread(RXcb,dummy,dummy,dummy,block_size) OR abort);    IF NOT abort THEN BEGIN      bytes_left:=dbl_subt(bytes_left,makedbl(block_size));      save_size:=block_size+buff_ptr;      save_size:=Land(save_size,32767-127);       {Round down block size to whole sectors}      IF NOT error THEN BEGIN        put(fcb1,addrint(big_buff[buff_size]),save_size,errno);        error:=errno<>0      END;      FOR a:=1 TO block_size+buff_ptr-save_size DO        big_buff[buff_size+1-a]:=big_buff[buff_size+1-save_size-a];      {Move any surplus less than 1 sector to start of buffer for next time}      buff_ptr:=block_size+buff_ptr-save_size;      IF NOT dbl_zero(bytes_left) THEN BEGIN        RXset(rxcb,data_port,client_stn,ADDRint(big_buff[1]),          buff_size-buff_ptr);        TRANSMIT(0,ack_port,client_stn,0,1,result);        IF result<128 THEN BEGIN notlistening; abort:=TRUE END      END    END  END;  IF ((buff_ptr<>0) AND NOT error) THEN BEGIN    Put(fcb1,addrint(big_buff[buff_size]),128,errno);    IF errno<>0 THEN error:=TRUE  END;  IF NOT dbl_zero(bytes_left) THEN RXdel(RXcb);    {Premature end, but not 0 length file}  IF NOT (abort OR error) THEN replyOK;  IF error THEN Err_message(errno);  IF abort THEN MSGLN('Aborted');  close(fcb1);  IF errno=198 THEN Delete(fcb1,errno) {If disc full, might as well erase}ENDEND;PROCEDURE Load;CONST wait_count=MAXINT;VARbytes_left,fsize,execaddr,loadaddr:dbl_word;fname:STRING name_size;RXCB,result,data_port,errno:BYTE;buff_ptr,loaded,a,block_size:INTEGER;CP_M,abort,error:BOOLEAN;fcb1:fcb;BEGINdata_port:=mainRX.envir.URD;  {data port in URD slot for no good reason!}getstrCR(ADDR2(mainRX)-min_size+1,name_size,fname);MSG('Load - Name :');MSGLN(fname);CP_M:=index(fname,'/C')<>0;IF CP_M THEN Mid$(fname,0,index(fname,'/C')-1);abort:=FALSE;error:=FALSE;A:=Fcb_no(mainRx.envir.CSD);IF A=0 THEN errno:=222 {'channel' error}ELSE Block(fcb1,user_info[user_no].fcbs[a],fname,errno);IF errno=0 THEN Open(fcb1,rd,errno);IF errno<>0 THEN BEGIN  error:=TRUE;  abort:=TRUE;  Err_message(errno)ENDELSE BEGIN{Usually, files have a header containing the load & execute addresses plus thelength. If the file name has /C added, it is treated as a straight CP/M fileand the file 'Size' is taken as the length, load & execute being undefined.}     IF CP_M THEN BEGIN    fsize:=size(fcb1);    FOR a:=1 to 3 DO BEGIN      mainTX.data[min_size-7-a]:=fsize[a];      bytes_left[a]:=fsize[a]    END;    buff_ptr:=0; {No header on file}    loaded:=0  END ELSE BEGIN    {Transfer load, execute,size from file}    get(fcb1,addrint(big_buff[buff_size]),128,errno);    IF errno<>0 THEN WRITELN('Read past EOF in Load : System ERROR');    FOR a:=1 TO 11 DO mainTX.data[min_size+1-a]:=big_buff[buff_size+1-a];    buff_ptr:=11;    FOR a:=1 TO 3 DO BEGIN      fsize[a]:=big_buff[buff_size-7-a];      bytes_left[a]:=fsize[a]    END;    loaded:=128-11  END;  bytes_left[4]:=0;  fsize[4]:=0;  MSG(' Size :');dbl_print(fsize);MSGLINE;  mainTX.cmd:=2;  mainTX.rtncode:=0;  TRANSMIT(0,mainRX.reply,client_stn,addrint(mainTX.data[min_size-13]),     16,result);  IF result<128 THEN BEGIN notlistening; abort:=TRUE ENDEND;WHILE NOT (abort OR dbl_zero(bytes_left)) DO BEGIN  block_size:=buff_size-buff_ptr;  IF (bytes_left[3] = 0) AND (bytes_left[2] <= Hi(block_size))    AND ((bytes_left[2]<>Hi(block_size)) OR (bytes_left[1] < Lo(block_size)))    THEN block_size:=bytes_left[2]*256+bytes_left[1];  IF block_size>loaded THEN    get(fcb1,addrint(big_buff[buff_size])+loaded+buff_ptr,block_size-loaded    ,errno);  IF errno<>0 THEN WRITELN('Read past EOF in Load');  bytes_left:=dbl_subt(bytes_left,makedbl(block_size));  TRANSMIT(0,data_port,client_stn,addrint(big_buff[buff_size])+buff_ptr    +block_size-1,block_size,result);  buff_ptr:=0; {nothing left over in buffer}  loaded:=0;  IF result<128 THEN BEGIN notlistening; abort:=TRUE ENDEND;IF NOT abort THEN replyOK ELSE MSGLN('aborted');IF NOT error THEN close(fcb1);END;.