{ FSP3  File Server Procedures & Functions }External FS::fsp3(3);{$E+  Extended error messages}{$C- No ctrl-C check}{$L- No listing}{$I+ Put source stmts in assembler file}PROCEDURE Read_info;VARa$:STRING 30;fname:STRING min_size;arg,result:BYTE;BEGINarg:=mainRX.data[min_size];Getstrcr(Addrint(mainRX.data[min_size-1]),min_size-1,fname);Msg('Rd_info arg=');IF messages THEN write(arg:3);Msg(' name=');Msgln(fname);CASE arg OF6:{Read directory info}  BEGIN  IF Length(fname)=0 THEN fname:='SJ Econet';  Append(fname,'          '); {Pad with spaces}  Mid$(fname,0,10); {Cut to size}  Putstr(addrint(mainTX.data[min_size-3]),fname);  WITH mainTx DO BEGIN    data[min_size-1]:=0;    data[min_size-2]:=10; {required by BBC NFS!}    data[min_size-13]:=0; {Owner access}    data[min_size-14]:=0; {cycle no}    rtncode:=0;    cmd:=0  END;  TRANSMIT(0,mainRX.reply,client_stn,addrint(mainTX.data[min_size-14]),17     ,result);  IF result<128 THEN notlistening  END;ELSE:Err_message(4*16+15)END {of case}END;PROCEDURE User_envir;VARa$:STRING 20;csd_no,a,result:BYTE;BEGINmaintx.cmd:=0;maintx.rtncode:=0;maintx.data[min_size]:=1; {Length of disc name}csd_no:=Fcb_no(mainRx.envir.CSD);IF csd_no=0 THEN Err_message(222) {'Channel' error}ELSE BEGIN  a$:=Chr(user_info[user_no].fcbs[csd_no].drive +64);  Append(a$,'               ');  Putstr(Addrint(mainTX.data[min_size-1]),a$);  FOR a:=1 to 3 DO    mainTx.data[min_size-16-a]:=user_info[user_no].fcbs[csd_no].name[9-a];  a$:='       '; {pad out CSD name}  Putstr(Addrint(mainTX.data[min_size-20]),a$);  a$:='None      ';  Putstr(Addrint(mainTX.data[min_size-27]),a$);  TRANSMIT(0,mainRX.reply,client_stn,Addrint(mainTX.data[min_size-36]),39,    result);  IF result<128 THEN notlisteningENDEND;PROCEDURE Cat;VARa$:STRING 30;fname:STRING min_size;a,dir_code,arg,result,first_entry,entry,no_of_ents:BYTE;index:INTEGER;fcb1:fcb;BEGINarg:=mainRX.data[min_size];first_entry:=mainRX.data[min_size-1];no_of_ents:=mainRX.data[min_size-2];Getstrcr(Addrint(mainRX.data[min_size-3]),min_size-10,fname);IF messages THEN BEGIN  Writeln('Cat arg=',arg,' name=',fname);  Writeln('1st ent=',first_entry:3,' no of ents=',no_of_ents:3)END;Append(fname,'.????????'); {file name is wild unless specified}A:=Fcb_no(mainRx.envir.CSD);IF A=0 THEN result:=222 {'channel' error}ELSE Block(fcb1,user_info[user_no].fcbs[a],fname,result);{***temp****}IF result<>0 THEN Writeln('file name error',result:3);dir_code:=Dir_first(fcb1,addrint(big_buffer[128]));entry:=0;WHILE entry<first_entry DO BEGIN  dir_code:=Dir_next(fcb1,addrint(big_buffer[128]));  entry:=succ(entry)END;index:=buff_size-4; {pointer into big buffer}WHILE (dir_code<>255) AND ((entry-first_ent)<no_of_ents) DO BEGIN  getstr(addrint(big_buff[127])+dir_code*32,11,fname);  CASE arg OF  3:BEGIN    Mid$(fname,0,8);    append(fname,'          ');    Putstr(addrint(big_buff[index]),fname);    index:=index-19;    big_buff[index+1]:=0; {terminator}    END  END;  dir_code:=Dir_next(fcb1,addrint(big_buffer[128]));  entry:=succ(entry)END;big_buff[index]:=128; {final terminator}big_buff[buff_size]:=0;big_buff[buff_size-1]:=0; {TX header}big_buff[buff_size-2]:=entry-first_entry;TRANSMIT(0,mainRX.reply,client_stn,Addrint(big_buff[index]),buff_size-index+1,  result);IF result<128 THEN notlisteningEND;Procedure Star_Sdisc(VAR cmd_text:min_string);VARdrv_no,csd_no:byte;real_name:min_string;BEGINExtract(real_name,cmd_text);csd_no:=Fcb_no(mainRx.envir.CSD);IF csd_no=0 THEN error:=222 {Channel}ELSE WITH user_info[user_no] DO BEGIN  drv_no:=Ord(real_name[1])-64;  fcbs[1].drive:=drv_no; { URD }  fcbs[csd_no].drive:=drv_no;  ReplyokENDEND;Procedure Star_dir(VAR cmd_text:min_string);VARnew_no,csd_no,error:byte;real_name:min_string;BEGINExtract(real_name,cmd_text);csd_no:=Fcb_no(mainRx.envir.CSD);IF csd_no=0 THEN error:=222 {Channel}ELSE IF ( Length(real_name)=0 ) THEN new_no:=1 {Select URD as CSD}  ELSE WITH user_info[user_no] DO BEGIN  new_no:=3; {The first FCB that might be free}  WHILE (new_no<8) AND fcbs[new_no].in_use DO new_no:=Succ(new_no);  IF fcbs[new_no].in_use THEN error:=192 {Too many open files}  ELSE BEGIN    Block(fcbs[new_no],fcbs[csd_no],real_name,error);    IF error=0 THEN BEGIN      IF csd_no<>1 THEN fcbs[csd_no].in_use:=FALSE; {Don't close URD!}      fcbs[new_no].in_use:=TRUE    END  ENDEND;IF error<>0 THEN Err_message(error)ELSE WITH mainTx DO BEGIN  cmd:=7;  rtncode:=0;  data[min_size]:=Handle(new_no);  TRANSMIT(0,mainRX.reply,client_stn,Addrint(data[min_size]),3,error);  IF error<128 THEN notlisteningENDEND;PROCEDURE Starcmd;VAR cmd_text:min_string;result,cmd_code:byte;a:Integer;BEGINGETSTRCR(ADDR2(mainRX)-min_size+1,min_size,cmd_text);Msg('Stn:');Msg(stn$(client_stn));Msg(' *');Msgln(cmd_text);cmd_code:=CLI(cmd_text);Writeln('cmd_text=',cmd_text);IF (cmd_code=5) OR User_ok THEN BEGIN {Check logged on if not a *I AM }  CASE cmd_code OF     2:BEGIN txerr('You must be joking',123) END; {Load}     4:Star_info(cmd_text);     5:I_am(cmd_text);     6:Star_Sdisc(cmd_text);     7:Star_dir(cmd_text);   119:BEGIN no_banner:=TRUE;ReplyOK END;   120:BEGIN extract$(end_text,cmd_text);ReplyOK END   121:BEGIN extract$(post_text,cmd_text);ReplyOK END;   122:BEGIN extract$(pre_text,cmd_text);ReplyOK END;   123:BEGIN extract$(banner,cmd_text); no_banner:=FALSE;ReplyOK END;   124:Replyok; {*CDIR}   125:Log_off; {*BYE}   126:Star_delete(cmd_text);   ELSE:BEGIN {Unrecognised command}      mainTX.cmd:=8;      mainTX.rtncode:=0;      append(cmd_text,chr(13));      Putstr(addrint(mainTX.data[min_size]),cmd_text);      a:=length(cmd_text);      TRANSMIT(0,mainRX.reply,client_stn,addrint(mainTX.data[min_size+1-a])        ,a+2,result);    IF result<128 THEN notlistening    END  END {case}END;MsglineEND;Procedure Do_logoff;BEGINFOR user_no:=1 to no_users DO IF user_info[user_no].stn=client_stn THEN  user_info[user_no].logged_on:=FALSE{****** should close all open files here *******}END;Procedure I_am(VAR cmd_text:min_string);VAR a,result:BYTE;BEGINDo_logoff;user_no:=1;WHILE user_info[user_no].logged_on AND (user_no<no_users) DO  user_no:=Succ(user_no);With user_info[user_no] DO IF logged_on THEN Err_message(184)ELSE BEGIN  {First get hold of user name}  a:=1;  WHILE ((cmd_text[a]<'!') OR ((cmd_text[a]>='0')AND(cmd_text[a]<='9')))     AND (a<=Length(cmd_text)) DO a:=succ(a);  Mid$(cmd_text,a,3); {**TEMP max 3 char user ID**}  IF ( Length(cmd_text)=0 ) THEN cmd_text:="$";  logged_on:=TRUE;  user_ID:=cmd_text;  stn:=client_stn;  fcbs[1].drive:=1; {Default to A:}  fcbs[1].in_use:=TRUE;  Block(fcbs[1],fcbs[1],cmd_text,result); {Transfer userid to URD FCB}  mainTX.cmd:=5;  mainTX.rtncode:=0;  mainTx.data[min_size]:=Handle(1); {URD handle(fixed)}  mainTx.data[min_size-1]:=Handle(1); {CSD handle (may change later)}  mainTx.data[min_size-2]:=Handle(2); {LIB handle (fixed)}  mainTx.data[min_size-3]:=0; {Boot option (Don't !)}  TRANSMIT(0,mainRX.reply,client_stn,addrint(mainTX.data[min_size-3])    ,6,result);  IF result<128 THEN notlisteningENDEND;FUNCTION User_ok:BOOLEAN;BEGINuser_no:=1;WHILE (user_info[user_no].stn<>client_stn) AND (user_no<>no_users) DO  user_no:=succ(user_no);IF (user_info[user_no].stn=client_stn) AND user_info[user_no].logged_on THEN  User_ok:=TRUEELSE BEGIN  User_ok:=FALSE;  Err_message(191) {Who are you?}ENDEND;PROCEDURE Log_off;BEGINDo_logoff;ReplyokEND;.