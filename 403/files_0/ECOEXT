 NAME ECOEXT PROG ; ; ENTRY ECOINIT ENTRY RXSET ENTRY RXREAD ENTRY RXDEL ENTRY TRANSMIT ;BDOS EQU 0005BOOT EQU 0NORXCBS EQU 20 ; Number of RXCBsRXCBLEN EQU 12 ; Length of RXCBLENBITS EQU 4 ; Number of bits in RXCBLEN ; ; ; ; PROCEDURE TRANSMIT(ctrl:BYTE,port:BYTE,stn:INTEGER,data:INTEGER,length:INTEGER,VAR result:BYTE); ; ; Passes a control block to the Econet TRANSMIT routine. ; <data> is the address of the variable containing the data ; <length> is the length of the data, in bytes ; <result> aquires the value of the result byte ;TRANSMIT ENTR 0,2,0 MOV A,18(IX) ; Ctrl code ORI 080H ; Set compolsary top bit STA TXCB MOV A,17(IX) ; Port STA TXCB+1 MOV L,15(IX) ; STN low MOV H,16(IX) ; STN hi SHLD TXCB+2 MOV L,13(IX) ; ADDR low (NB. This is END of data structure!) MOV H,14(IX) ; ADDR hi INX H ; End for primitives is EXCLUSIVE SHLD TXCB+8 ; Buffer end MOV D,12(IX) ; LENGTH hi MOV E,11(IX) ; LENGTH lo ORA A ; Clear carry DSBC D ; Start = End - length SHLD TXCB+4 LXI H,0 SHLD TXCB+6 ; Clear high order addresses SHLD TXCB+10 ; (Not strictly required?) ; ; MVI C,041H ; 'High level' transmit (auto repeats) LXI D,0A80H ; Send max 128 packets, 10ms apart PUSH X PUSH Y ; May be killed by Stephen? CALL BDOS ; Jump to BDOS (really econet!) POP Y POP X ; ; MOV H,10(IX) ; Hi of addr of result variable MOV L,9(IX) ; Lo - 8(IX) is size - assumed 1 MOV M,A ; If 2 bytes, then points to hi byte! ; ; EXIT 0,11 ; ; ; ; ; ; PROCEDURE ECOINIT; ;ECOINIT ; Initialise all RxCBs to empty, set RxCB & TxCB vectors etc. PUSH X ; For saftey PUSH Y MVI C,67 ; Set TxCB vector LXI D,TXCB CALL BDOS ; MVI B,NORXCBS ; Count RXCBs LXI H,INUSECLEAR MVI M,0 ; Set all entries to not in use INX H DJNZ CLEAR ; LXI H,RXCB ; Now initialise RXCBs to full so network does not use them MVI B,NORXCBS LXI D,RXCBLENFILL MVI M,80H; Value of flag to indicate full DAD D ; Move to next RXCB DJNZ FILL ; LXI D,RXCB MVI C,66 ; Set RXCB vector CALL BDOS ; MVI C,70 ; Read FLAG MVI D,0FFH CALL BDOS ORI 80H ; Indicate RXCB present MOV E,A ; Entry parameter in E! MVI C,70 ; In case changed MVI D,0 ; Indicate set CALL BDOS ; POP Y POP X ; MVI A,0 ; Indicate satisfactory external routine RET ; ; ; ; PROCDURE RXSET(VAR blockno:BYTE;port:BYTE;stn,data,length:INTEGER); ; ; Create RXCB with given parameters and return block no. ; If no space available, currently prints a message and expires (reboot) ;RXSET ENTR 0,2,0 MVI B,NORXCBS LXI H,INUSEFINDMT MOV A,M ORA A JRZ GOT1 ; Found an empty RXCB INX H DJNZ FINDMT ; Falls out if none available (disaster) LXI D,MRXBAD MVI C,9 ; Print string CALL BDOS JMP 0 ; ;MRXBAD DB 'HELP!! All RxCBs Full',13,10,'$' ;GOT1 INR M ; Set flag to indicate in use LXI D,INUSE ORA A ; Clear carry DSBC D ; HL now has a value in the range 0..NORXCBS MOV C,L MOV H,17(IX) ; Address of blockno variable MOV L,16(IX) MOV M,C ; INR C ; Get address one beyond the RxCB we want CALL CALCADR ; Result in HL DCX H ; Points to end of RxCB MVI C,0 ; Now zero high order addresses (keep C=0 for later) MOV M,C DCX H MOV M,C ; MOV D,11(IX) ; Hi of data addr MOV E,10(IX) ; Lo INX D ; See TRANSMIT for explanation of address calculations DCX H MOV M,D ; Buffer end DCX H MOV M,E DCX H MOV M,C DCX H MOV M,C ; C still zero DCX H PUSH H MOV H,D MOV L,E MOV D,9(IX) ; Length MOV E,8(IX) ORA A DSBC D MOV D,H MOV E,L POP H MOV M,D DCX H MOV M,E DCX H MOV A,13(IX) ; Station Hi MOV M,A DCX H MOV A,12(IX) MOV M,A DCX H MOV A,14(IX) ; Port MOV M,A DCX H MVI M,7FH ; Flag => Not full EXIT 0,10 ; ; ; ; FUNCTION RXREAD(blockno:BYTE;VAR ctrl,port:BYTE;VAR stn,length:INTEGER):BOOLEAN ; ; Returns TRUE if a packet has been received on the specified RxCB, ; and fills in the VAR parameters from the block, then deletes block ; Otherwise, returns FALSE with all parameters unchanged. ;RXREAD SSPD TEMP2 LHLD TEMP2 LXI D,14 DAD D MOV C,M ; C=Blockno POP H ; Return addr SHLD TEMP2 ;Save CALL CALCADR ; Find RxCB MOV A,M ORA A JM FULL ; Top bit set <=> full ; MVI B,13 ; Bytes of paramsPULLIT INX SP DJNZ PULLIT LHLD TEMP2 ; Return addr XRA A ; A=0 to keep Pascal happy ; Carry clear <=> False PCHL ;FULL ANI 7FH ; AND out top bit - rest is ctrl MOV C,A ; Save for when stack is sorted out INX SP ; Skip length INX H INX H INX H PUSH H ; Stn Hi INX H MOV E,M ; Start data INX H MOV D,M INX H INX H INX H MOV A,M ; End addr INX H MOV H,M MOV L,A ORA A DSBC D XCHG ; DE now contains result (= length) POP H ; Points to useful part of RxCB XTHL ; Now got address of parameter, ptr back on stack MOV M,D DCX H MOV M,E POP H ; Now points to stn Lo INX SP POP D ; Pointer to stn param MOV A,M STAX D DCX D DCX H MOV A,M STAX D DCX H MOV A,M INX SP POP D ; Addr of Port var STAX D INX SP POP D ; Addr of ctrl var MOV A,C STAX D ; JMP DEL1 ; Jump into delete rtn ; ; ; PROCEDURE RXDEL(blockno:BYTE) ; ; Delete given RxCB ;RXDEL POP H ; Return addr SHLD TEMP2DEL1 ; RXREAD enters here DCX SP ; Push one byte of garbage POP B ; <blockno> to B MOV C,B MVI B,0 LXI H,INUSE DAD B ; HL now address of inuse flag MVI M,0 ; Clear it CALL CALCADR ; Find RxCB MVI M,80H ; Set to full to prevent reception XRA A ; A=0 to keep Pascal happy LHLD TEMP2 STC ; For RxRead, Carry set <=> TRUE PCHL ; ; ; ; ; ; ; Calculate address of RxCB whose number is in C, result in HL ; most things corrupted. ;CALCADR MVI D,RXCBLEN MVI B,LENBITS ; Number of bits in RXCBLEN MVI A,0 ; Partial resultCALC1 RRAR D ; Next bit of multiplier to C (increasing significance) JRNC CALC2 ADD CCALC2 SLAR C ; Multiply by 2 DJNZ CALC1 ; MVI D,0 ; High byte MOV E,A ; Offset LXI H,RXCB DAD D ; HL now contains answer RET ; ; ; ; ; ; ; DATA ;RXCB DS NORXCBS*RXCBLENTXCB DS 12INUSE DS NORXCBSTEMP2 DS 2 ; Temporary W/S ; ;