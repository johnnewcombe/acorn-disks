 NAME CACHE ; ENTRY CACHE_INIT ENTRY CACHE_IDLE ENTRY CACHE_EMPTY ;TRUE EQU 0FFFFHFALSE EQU NOT TRUE ; ; BIOS EQUATES ;secvec EQU 0DB22Htrkvec EQU 0DB1FHdscvec EQU 0DB1CHrdvec  EQU 0DB28Hwrtvec EQU 0DB2BH ;fullmem EQU FALSE ; True if already a 56K system before adding mem board ; ; ; ; CACHE MANAGER FOR RML DISC SYSTEM ; WITH PSJ EXPANSION MEMORY BOARD ; ; Data structure: ; ; 256 entries, one for each possible memory page. Sectors are ; buffered in pairs, physically adjacent, so the sector number ; of each entry is always ODD, the even numbered sector also being ; available. ; ; Byte 0 - status byte: =0 if not available (memory not fitted) ;          bit 0 : available ;          bit 1 : contains a valid sector ;          bit 2 : contains information needing to be written back ; Byte 1 - age (0=most valuable, &FF=least valuable) ; Byte 2 - sector number ; Bytes 3,4 - track number ;CACHE_INIT LXI H,table ; Clear down all entries to empty, available LXI D,01FFH ; D=01, E=FF MVI B,0 ; Entry countinit1 MOV M,D ; Status byte INX H MOV M,E ; Age to max INX H INX H INX H INX H DJNZ init1 ; LHLD secvec SHLD setsec+1 ; This code ***** NOT ROM-ABLE ***** LHLD trkvec SHLD settrk+1 LHLD dscvec SHLD seldsc+1 LHLD dmavec SHLD setdma+1 LHLD rdvec SHLD read+1 LHLD wrtvec SHLD write+1 ; LXI H,dosetsec SHLD secvec LXI H,dosettrk SHLD trkvec LXI H,doseldsc SHLD dscvec LXI H,dosetdma SHLD dmavec LXI H,dordsec SHLD rdvec LXI H,dowrtsec SHLD wrtvec ; IF NOT fullmem LXI H,table+5*7CH ; If full memory not available then LXI B,5*100 ; wipe out all entries not available XRA Ainit2 MOV M,A INX H DCX B JRNZ init2 ; ELSE XRA A ; For pascal, A=0 ENDIF ; RET ; ; ;setsec JMP 0 ; real values filled in at run timesettrk JMP 0seldsc JMP 0setdma JMP 0read JMP 0write JMP 0 ; ; ;dosetsec MOV a,c STA sector RET ; ;dosettrk SBCD track RET ; ;doseldsc MOV A,C STA disc RET ; ;dosetdma SBCD dma RET ; ; ;dordsec CALL incage ; age whole cache before starting CALL findsec ; Returns pointer to entry in HL, or Z=0 if not found JRZ gotone CALL spare_slot ; Now read this entry ; <spare_slot> has already updated the table PUSH H ; Save for later LDA sector MOV C,A MVI B,0 CALL setsec LDA track MOV C,A LDA track+1 MOV B,A CALL settrk LDA disc MOV C,A CALL seldsc LXI B,0F000H ; Window address CALL setdma ; Now open the window ; ; ;dowrtsec CALL incage ; ; ;incage LXI H,table+1 ; Point to all age bytes LXI D,5 ; Offset to next entry MVI B,0 ; Number of entriesage1 MOV A,M INR A JRZ age2 ; Don't allow wrap-round MOV M,Aage2 DJNZ age1 RET ; ; ; ; ; DATA ;table DS 5*256sector DS 1track DS 2disc DS 1 ; ;