{  DOFS  File Server main code }External FS::dofs(9);{$E+  Extended error messages}Procedure Dofs;CONSTprint_size=256*4; {print buffer size}print_port=13*16+1;{port D1}prx_size=128;msg_size=40;TYPEmessage=String msg_size;VARa,blk_len,print_stn,print_space,print_ptr:Integer;  {<print_space> points to free space in the print buffer, <print ptr> points   to the next byte to be printed}print_block,next_seq,rx_seq:Byte;old_type,no_banner,print_waiting,print_active:Boolean;print_buff:array[1..print_size] OF byte;printRx:array[1..prx_size] OF byte;dum$,pre_text,post_text,banner,end_text:message;Procedure Print(var txt:message);{Procedure to place contents of string into print buffer. If buffer doesnot have enough free space, it is purged first}VARa:byte;BEGINWhile ((print_space-print_ptr+print_size)MOD print_size) {no of chrs in buffer}  > (print_size-length(txt)) DO BEGIN  List_out(print_buff[print_ptr]);  If print_ptr=print_size THEN print_ptr:=1 ELSE print_ptr:=succ(print_ptr)END;For a:=1 TO length(txt) DO BEGIN  print_buff[print_space]:=ord(txt[a]);  IF print_space=print_size THEN print_space:=1  ELSE print_space:=succ(print_space)ENDEND;Procedure Finish_print;BEGINPrint(end_text);print_active:=false;Writeln('Station ',client_stn:3,' print terminated'); {Now acknowledge final packet}Transmit(rx_seq,print_port,client_stn,addrint(printRx[prx_size]),1 ,dummy)END;BEGINwriteln(' SJ Research File Server version ',verA:1,'.',verB:1,verC:1);writeln;ECOINIT;cache_init;print_ptr:=1;print_space:=1;print_stn:=0; {Current print client}print_active:=false;print_waiting:=false; {If TRUE, we have an RxCB open}pre_text:='pre';post_text:='why does this not work??';banner:='banner';no_banner:=false;end_text:='End';Writeln('Ready',chr(17)); {ctrl-Q disables page wait on RML}REPEAT {Main operating loop}  RXSET(blockno,cmdport,0,ADDR2(mainRX),min_size+5);  WHILE NOT RXREAD(blockno,dummybyte,dummybyte,client_stn,dummy) DO BEGIN    {Idle time in here!}    Cache_idle;    IF (print_ptr<>print_space) AND List_ready THEN BEGIN      List_out(print_buff[print_ptr]);      IF print_ptr=print_size THEN print_ptr:=1  {wrap around buffer}       ELSE print_ptr:=succ(print_ptr) {; here?}    END;    IF print_waiting AND      RXread(print_block,rx_seq,dummy,client_stn,blk_len) THEN BEGIN      print_waiting:=FALSE;      IF print_active THEN BEGIN        IF Land(rx_seq,1)=next_seq THEN BEGIN          next_seq:=Land(succ(next_seq),1); {Increment sequence no}          IF Land(rx_seq,4)=4 THEN blk_len:=pred(blk_len);            {Control byte indicates last block, but there is a             spurious ctrl-C at the end as well }          a:=prx_size;          REPEAT   {Transfer data to output buffer}            IF old_type AND (printRx[a]=3) THEN Finish_print             {Old type block terminator}            ELSE BEGIN {normal byte}              print_buff[print_space]:=printRx[a];              IF print_space=print_size THEN print_space:=1               ELSE print_space:=succ(print_space)            END;            a:=pred(a);          UNTIL a=prx_size-blk_len;          IF Land(rx_seq,4)=4 THEN Finish_print {Usual terminator}        END      END ELSE BEGIN {Not active, so should be log-on}        Writeln('Print starting : stn =',client_stn);        old_type:=printRx[prx_size]=2; {Character sent indicates protocol}        writeln('Old protocol =',old_type);        print_stn:=client_stn;        IF NOT no_banner THEN BEGIN          Print(pre_text);          Print(banner);          dum$:='***  Station  ';          append(dum$,'  ***');          Print(dum$);          Print(post_text)        END;        next_seq:=Land(succ(Rx_seq),1); {Initialise sequence no (=0 or =1) }        print_active:=TRUE      END    END;    If (NOT print_waiting) AND      (((print_space-print_ptr+print_size)MOD print_size)      < (print_size-prx_size)) THEN BEGIN      { There is room in the buffer for another recieve block }      print_waiting:=TRUE;      If print_active THEN       Rxset(print_bl,print_po,print_stn,addrint(printRx[1]),prx_size)      ELSE Rxset(print_block,print_port,0,addrint(printRx[1]),prx_size);       { Acknowledge if appropriate }      If print_active THEN Transmit(rx_seq,print_port,client_stn,        addrint(printRx[prx_size]),1,dummy)    END  END;{ Drops through here when a packet arrives on the FS command port }  WRITELN('FN=',mainRX.FN:3,' Stn=',client_stn:3);  CASE mainRX.fn OF    0:Starcmd;    1:Save;    2:Load;    3:Cat;    5:Load;   18:Read_info;   21:User_envir;   23:Log_off;  ELSE:txerr('Invalid FN code',133)  END;{of case}  UNTIL FALSE;END;.