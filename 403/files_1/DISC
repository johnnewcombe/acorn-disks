 NAME DISC PROG ; ; ENTRY PUT ENTRY GET ENTRY SIZE ENTRY BLOCK ENTRY OPEN ENTRY CLOSE ENTRY DELETE ENTRY DIR_FIRST ENTRY DIR_NEXT ; ;BDOS EQU 0005H ; ; ; FUNCTION BLOCK(VAR fname:$STRING0;VAR error:BYTE):INTEGER; ; ; Sets up an FCB for the specified file and returns the handle ;BLOCK POP H ; Return addr INX SP ; Size of error no variable POP D ; addr. of error no. SDED temp1 XTHL ; String addr to HL, return addr back on stack ; CALL NEWFCB ; Addr to DE SDED temp2 ; For routine <FNAME> and to return at end ; ; In general, B= no of chars left EXCLUDING (HL) ; (HL)=the character just finished with ; MOV B,M ; Length of stringDESPACE DCX H DCR B ; Count the 1st char JM BADNAME MOV A,M CPI ' ' JRZ DESPACE ; CPI ':' ; Is there a drive name? MVI A,0 ; Value for default drive JRNZ NODSC ; Z flag still from compare DCX H DCR B ; Skip the : JM BADNAME MOV C,M ; Disc nameSKIP MOV A,M CPI '.' JRZ ENDDSC DCX H DJNZ SKIP JP BADNAMEENDDSC MOV A,C ; Get back disc name ANI 0FH ; Put in range 1..15 DCX H DCR BNODSC ; At this point, the 'previous' character [(HL)] is still valid STAX D ; Store drive no. in FCB PUSH B PUSH H ; ; Now check if there is a '.' in the file name ; <=> is there a directory name ;FINDDOT MOV A,M CPI '.' JRZ GOTDOT DCX H DJNZ FINDDOT ; ; Falls through if no dots - hence no directory name ; POP H POP B ; Restore pointer to start of name CALL FNAME ; Get file NAME into FCB from current position in string MVI A,' ' ; Fill up with an extent of spaces for now STAX D INX D STAX D INX D STAX D JR TIDYUP ; ;GOTDOT DCX H ; Found a dot, so skip it DCR B CALL FNAME POP H POP B ; Get back to start of string (=dir name) MVI B,3DODIR MOV A,M CPI '.' JRNZ NODOT INX H ; So we see it next time as well MVI A,' 'NODOT STAX D INX D DCX H DJNZ DODIR ;TIDYUP LDED temp2 ; FCB LXI H,0CH ; Offset to 1st byte to zero DAD D MVI B,23 ; No of bytes to zero XRA AZEROFCB MOV M,A INX H DJNZ ZEROFCB XRA A LHLD temp1 ; Error location MOV M,A ; Set to 0 LDED temp2 ; handle value RET ; ; ; ; Routine to put the filename in the FCB, starting with ; the char at (HL) ;FNAME LDED temp2 INX D MVI C,8 ; Count the bytes actually stored INR B ; Un-count the 1st char INX H MOV A,B CPI 8 ; Max meaningful value JRC DONAME MOV B,C ; If too long, only use 8 bytes (C=8)DONAME DCR C DCX H MOV A,M STAX D INX D DJNZ DONAME ;SPACEOUT MVI A,' ' DCR C ; Count out the spaces to fill up name RM ; *EXIT THIS RTN* STAX D INX D JR SPACEOUT ; ;BADNAME LHLD temp1 MVI A,0CCH ; Bad file name MOV M,A ; Set error no. XRA A RET ; ; ; PROCEDURE OPEN(handle:INTEGER;rw:R_W;CSD:BYTE;VAR error:BYTE); ; ; Activates FCB previously set up by <HANDLE> ;OPEN POP D ; Return addr INX SP ; Size of error no variable POP H ; addr. of error no. SHLD temp1 POP H ; L is CSD, H is R/W POP B PUSH D ; Handle to BC, return addr back on stack ; CALL ADDR ; Handle in BC converts to FCB addr in DE MOV A,H ; R/W value ORA A JRZ READ MVI C,13H ; First delete file in case already exists PUSH X PUSH Y CALL BDOS POP Y POP X LDED temp2 ; FCB addr back MVI C,016H ; Make file PUSH X PUSH Y CALL BDOS POP Y POP X INR A JRNZ RETURNOK MVI A,0B3H ; Directory full LHLD temp1 MOV M,A XRA A RET ;READ MVI C,0FH ; Open(in) file PUSH X PUSH Y CALL BDOS POP Y POP X INR A JRNZ RETURNOK MVI A,0D6H ; File not found LHLD temp1 MOV M,A XRA A RET ; ;RETURNOK MVI A,0 ; Error code LDED temp1 STAX D XRA A; For Pascal RET ; ; ; ; ; PROCEDURE DELETE(handle:INTEGER;VAR error:BYTE); ; ; Activates FCB previously set up by <HANDLE> ;DELETE POP D ; Return addr INX SP ; Size of error no variable POP H ; addr. of error no. SHLD temp1 POP B PUSH D ; Handle to BC, return addr back on stack ; CALL ADDR ; Handle in BC converts to FCB addr in DE MVI C,13H ; Delete file function code PUSH X PUSH Y CALL BDOS POP Y POP X INR A JRNZ RETURNOK MVI A,0D6H ;  File not found LHLD temp1 MOV M,A XRA A RET ; ; ; PROCEDURE PUT(addr,handle,length:INTEGER;VAR error:BYTE); ; ; write disc sectors from memory at <addr> (multiples of 128 bytes only) ; from the file given by <handle>. Error no. is zero if no error. ;PUT POP H ; Return addr INX SP ; Discard integer size POP D POP B ; Length SBCD temp1 POP B ; Handle XTHL  ; Memory addr to HL, return addr back on stack SHLD temp3 PUSH D ; Save error no. addr ; CALL ADDR ; Get FCB addr in DE SDED temp2PLOOP LHLD temp3 LXI D,080H ; Size of a sector DAD D SHLD temp3 DSBC D ; Carry guaranteed clear from DAD XCHG ; Original back in DE MVI C,01AH ; Set DMA addr PUSH X PUSH Y CALL BDOS POP Y POP X LDED temp2 ; FCB MVI C,015H ; Write sequential PUSH X PUSH Y CALL BDOS POP Y POP X ORA A JRNZ DISCFULL LHLD temp1 ; Length LXI D,080H ORA A ; C=0 DSBC D SHLD temp1 JRC PFIN ; Not finished JRNZ PLOOPPFIN POP H ; Addr of error no. XRA A MOV M,A RET ; ; ;DISCFULL POP H MVI A,0C6H ; Error no. for disc full MOV M,A XRA A RET ; ; ; PROCEDURE GET(addr,handle,length:INTEGER;VAR error:BYTE); ; ; Read disc sectors to memory at <addr> (multiples of 128 bytes only) ; from the file given by <handle>. Error no. is zero if no error ;GET POP H ; Return addr INX SP POP D ; Error no addr POP B ; Length SBCD temp1 POP B ; Handle XTHL  ; Memory addr to HL, return addr back on stack SHLD temp3 PUSH D ; Error addr saved ; CALL ADDR ; Get FCB addr in DE SDED temp2GLOOP LHLD temp3 LXI D,080H ; Size of a sector DAD D SHLD temp3 DSBC D ; Carry guaranteed clear from DAD XCHG ; Original back in DE MVI C,01AH ; Set DMA addr PUSH X PUSH Y CALL BDOS POP Y POP X LDED temp2 ; FCB MVI C,014H ; Read sequential PUSH X PUSH Y CALL BDOS POP Y POP X ORA A JRNZ EOF LHLD temp1 ; Length LXI D,080H ORA A ; C=0 DSBC D SHLD temp1 JRC GFIN ; Not finished JRNZ GLOOPGFIN POP H ; Addr of error no. XRA A MOV M,A RET ;EOF POP H ; Error no addr MVI A,0DFH ; EOF error MOV M,A XRA A RET ; ;