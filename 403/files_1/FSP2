{ FSP2  File Server Procedures & Functions }External FS::fsp2(2);{$E+ Extended error messages}PROCEDURE Star_info(VAR fname:$string0);VARA,result:BYTE;handle:INTEGER;fiddle$:STRING min_size;BEGINhandle:=Block(fname,result);IF result=0 THEN BEGIN  Open(handle,rd,mainRX.envir.csd,result);  IF result=0 THEN Get(addrint(big_buff[buff_size]),handle,128,result)END;IF result=0 THEN BEGIN  fiddle$:=fname;  Append(fiddle$,'    ');  FOR a:=0 TO 3 DO Append(fiddle$,Hex2$(big_buff[buff_size-3+a]));  Append(fiddle$,'  ');  FOR a:=0 TO 3 DO Append(fiddle$,Hex2$(big_buff[buff_size-7+a]));  Append(fiddle$,'  ');  FOR a:=0 TO 2 DO Append(fiddle$,Hex2$(big_buff[buff_size-10+a]));  mainTX.cmd:=4;  mainTX.rtncode:=0;  a:=Length(fiddle$);  Putstr(addrint(mainTX.data[min_size]),fiddle$);  mainTX.data[min_size-a]:=13; {Terminators}  mainTX.data[min_size-1-a]:=128;  TRANSMIT(0,mainRX.reply,client_stn,addrint(mainTX.data[min_size-1-a])    ,a+4,result);  IF result<128 THEN notlisteningENDELSE Err_message(result)END;PROCEDURE Star_delete(VAR fname:$STRING0);VARerror:byte;handle:INTEGER;BEGINhandle:=Block(fname,error);IF error=0 THEN Delete(handle,error);IF error=0 THEN ReplyOK ELSE Err_message(error)END;PROCEDURE Starcmd;VAR cmd_text:STRING min_size;result,cmd_code:byte;a:Integer;BEGINGETSTRCR(ADDR2(mainRX)-min_size+1,min_size,cmd_text);WRITELN('Stn:',client_stn:3,' *',cmd_text);cmd_code:=CLI(cmd_text);CASE cmd_code OF   2:BEGIN WRITELN('Load !!');REPLYOK END;   4:Star_info(cmd_text);   5:I_am; 126:Star_delete(cmd_text); ELSE:BEGIN    mainTX.cmd:=8;    mainTX.rtncode:=0;    append(cmd_text,chr(13));    Putstr(addrint(mainTX.data[min_size]),cmd_text);    a:=length(cmd_text);    TRANSMIT(0,mainRX.reply,client_stn,addrint(mainTX.data[min_size+1-a])      ,a+2,result);  IF result<128 THEN notlistening  ENDEND; {case}writelnEND;PROCEDURE Log_off;BEGINTXerr('Goodbye',123)END;PROCEDURE Save;CONST wait_count=MAXINT;VARbytes_left,fsize:dbl_word;fname:STRING name_size;RXCB,result,ack_port,errno:BYTE;save_size,a,block_size,handle,buff_ptr:INTEGER;abort,error:BOOLEAN;BEGINack_port:=mainRX.envir.URD;  {ack port in URD slot for no good reason!}getstrCR(ADDR2(mainRX)-min_size+12,name_size,fname);{Usually, files have a header added containing the load & execute addressesplus the length. If the file name has /C added, it is treated as a straightCP/M file and does not have a header added.}IF index(fname,'/C')<>0 THEN BEGIN  buff_ptr:=0; {No header on file}  Mid$(fname,0,index(fname,'/C')-1)END ELSE BEGIN  {Transfer load, execute,size to file}  FOR a:=1 TO 11 DO big_buff[buff_size+1-a]:=mainRX.data[min_size+1-a];  buff_ptr:=11END;FOR a:=1 TO 3 DO BEGIN  fsize[a]:=mainRX.data[min_size-7-a];  bytes_left[a]:=fsize[a]END;fsize[4]:=0;bytes_left[4]:=0;WRITE('Name :',fname);WRITE(' Size :');dbl_print(fsize);WRITELN;abort:=FALSE;error:=FALSE;handle:=Block(fname,errno);IF errno=0 THEN Open(handle,wr,mainRX.envir.csd,errno);IF errno<>0 THEN BEGIN  error:=TRUE;  abort:=TRUE;  Err_message(errno)END;IF NOT error THEN BEGIN  block_size:=buff_size-buff_ptr;  mainTX.cmd:=1;  mainTX.rtncode:=0;  mainTX.data[min_size]:=data_port;  mainTX.data[min_size-1]:=Lo(block_size);  mainTX.data[min_size-2]:=Hi(block_size);    IF NOT dbl_zero(fsize) THEN RXset(rxcb,data_port,client_stn,    ADDR1(big_buffer),block_size);   {must be ready to Rx immediately after transmission}    TRANSMIT(0,mainRX.reply,client_stn,addrint(mainTX.data[min_size-2])    ,5,result);  IF result<128 THEN BEGIN notlistening; abort:=TRUE END;    WHILE NOT (abort OR dbl_zero(bytes_left)) DO BEGIN    a:=wait_count;    REPEAT      a:=a-1;      IF a=0 THEN abort:=TRUE;         {Written this way because <abort> must not be set to FALSE}    UNTIL (RXread(RXcb,dummy,dummy,dummy,block_size) OR abort);    IF NOT abort THEN BEGIN      bytes_left:=dbl_subt(bytes_left,makedbl(block_size));      Dbl_print(bytes_left);writeln;      save_size:=block_size+buff_ptr;      save_size:=Land(save_size,32767-127);       {Round down block size to whole sectors}      IF NOT error THEN BEGIN        put(addrint(big_buff[buff_size]),handle,save_size,errno);        error:=errno<>0      END;      FOR a:=1 TO block_size+buff_ptr-save_size DO        big_buff[buff_size+1-a]:=big_buff[buff_size+1-save_size-a];      {Move any surplus less than 1 sector to start of buffer for next time}      buff_ptr:=block_size+buff_ptr-save_size;      IF NOT dbl_zero(bytes_left) THEN BEGIN        RXset(rxcb,data_port,client_stn,ADDR1(big_buff),buff_size-buff_ptr);        TRANSMIT(0,ack_port,client_stn,0,1,result);        IF result<128 THEN BEGIN notlistening; abort:=TRUE END      END    END  END;  IF ((buff_ptr<>0) AND NOT error) THEN BEGIN    Put(addrint(big_buff[buff_size]),handle,128,errno);    IF errno<>0 THEN error:=TRUE  END;  IF NOT dbl_zero(bytes_left) THEN RXdel(RXcb);    {Premature end, but not 0 length file}  IF NOT (abort OR error) THEN replyOK;  IF error THEN Err_message(errno);  IF abort THEN WRITELN('Aborted');  close(handle);ENDEND;PROCEDURE Load;CONST wait_count=MAXINT;VARbytes_left,fsize,execaddr,loadaddr:dbl_word;fname:STRING name_size;RXCB,result,data_port,errno:BYTE;buff_ptr,loaded,a,block_size,handle:INTEGER;CP_M,abort,error:BOOLEAN;BEGINdata_port:=mainRX.envir.URD;  {data port in URD slot for no good reason!}getstrCR(ADDR2(mainRX)-min_size+1,name_size,fname);WRITE('Name :',fname);CP_M:=index(fname,'/C')<>0;IF CP_M THEN Mid$(fname,0,index(fname,'/C')-1);abort:=FALSE;error:=FALSE;handle:=Block(fname,errno);IF errno=0 THEN Open(handle,rd,mainRX.envir.csd,errno);IF errno<>0 THEN BEGIN  error:=TRUE;  abort:=TRUE;  Err_message(errno)ENDELSE BEGIN{Usually, files have a header containing the load & execute addresses plus thelength. If the file name has /C added, it is treated as a straight CP/M fileand the file 'Size' is taken as the length, load & execute being undefined.}     IF CP_M THEN BEGIN    fsize:=size(handle);    FOR a:=1 to 3 DO BEGIN      mainTX.data[min_size-7-a]:=fsize[a];      bytes_left[a]:=fsize[a]    END;    buff_ptr:=0; {No header on file}    loaded:=0  END ELSE BEGIN    {Transfer load, execute,size from file}    get(addrint(big_buff[buff_size]),handle,128,errno);    IF errno<>0 THEN WRITELN('Read past EOF in Load : System ERROR');    FOR a:=1 TO 11 DO mainTX.data[min_size+1-a]:=big_buff[buff_size+1-a];    buff_ptr:=11;    FOR a:=1 TO 3 DO BEGIN      fsize[a]:=big_buff[buff_size-7-a];      bytes_left[a]:=fsize[a]    END;    loaded:=128-11  END;  bytes_left[4]:=0;  fsize[4]:=0;  WRITE(' Size :');dbl_print(fsize);WRITELN;  mainTX.cmd:=2;  mainTX.rtncode:=0;  TRANSMIT(0,mainRX.reply,client_stn,addrint(mainTX.data[min_size-13]),     16,result);  IF result<128 THEN BEGIN notlistening; abort:=TRUE ENDEND;WHILE NOT (abort OR dbl_zero(bytes_left)) DO BEGIN  block_size:=buff_size-buff_ptr;  IF (bytes_left[3] = 0) AND (bytes_left[2] <= Hi(block_size))    AND ((bytes_left[2]<>Hi(block_size)) OR (bytes_left[1] < Lo(block_size)))    THEN block_size:=bytes_left[2]*256+bytes_left[1];  IF block_size>loaded THEN    get(addrint(big_buff[buff_size])+loaded+buff_ptr,handle,block_size-loaded    ,errno);  IF errno<>0 THEN WRITELN('Read past EOF in Load : System ERROR');  bytes_left:=dbl_subt(bytes_left,makedbl(block_size));  TRANSMIT(0,data_port,client_stn,addrint(big_buff[buff_size])+buff_ptr    +block_size-1,block_size,result);  buff_ptr:=0; {nothing left over in buffer}  loaded:=0;  IF result<128 THEN BEGIN notlistening; abort:=TRUE ENDEND;IF NOT abort THEN replyOK ELSE WRITELN('aborted');IF NOT error THEN close(handle);END;.