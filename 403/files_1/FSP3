{ FSP3  File Server Procedures & Functions }External FS::fsp3(3);{$E+  Extended error messages}PROCEDURE Read_info;VARa$:STRING 30;fname:STRING min_size;arg,result:BYTE;BEGINarg:=mainRX.data[min_size];Getstrcr(Addrint(mainRX.data[min_size-1]),min_size-1,fname);writeln('Rd_info arg=',arg:3,' name=',fname);CASE arg OF6:{Read directory info}  BEGIN  IF Length(fname)=0 THEN fname:='PSJ Econet';  Append(fname,'          '); {Pad with spaces}  Mid$(fname,0,10); {Cut to size}  Putstr(addrint(mainTX.data[min_size-3]),fname);  mainTX.data[min_size-1]:=0;  mainTX.data[min_size-2]:=10; {required by BBC NFS!}  mainTX.data[min_size-13]:=0; {Owner access}  mainTX.data[min_size-14]:=0; {cycle no}  mainTX.rtncode:=0;  mainTX.cmd:=0;  TRANSMIT(0,mainRX.reply,client_stn,addrint(mainTX.data[min_size-14]),17     ,result);  IF result<128 THEN notlistening  END;ELSE:Err_message(4*16+15)END {of case}END;PROCEDURE User_envir;VARa$:STRING 20;result:BYTE;BEGINmaintx.cmd:=0;maintx.rtncode:=0;maintx.data[min_size]:=3; {Length of disc name}a$:='A:              '; {**************** TEMP ********}Putstr(Addrint(mainTX.data[min_size-1]),a$);a$:='CSD       '; {CSD name}Putstr(Addrint(mainTX.data[min_size-17]),a$);a$:='None      ';Putstr(Addrint(mainTX.data[min_size-27]),a$);TRANSMIT(0,mainRX.reply,client_stn,Addrint(mainTX.data[min_size-36]),39,  result);IF result<128 THEN notlisteningEND;PROCEDURE Cat;VARa$:STRING 30;fname:STRING min_size;dir_code,arg,result,first_entry,entry,no_of_ents:BYTE;index,handle:INTEGER;BEGINarg:=mainRX.data[min_size];first_entry:=mainRX.data[min_size-1];no_of_ents:=mainRX.data[min_size-2];Getstrcr(Addrint(mainRX.data[min_size-3]),min_size-10,fname);writeln('Cat arg=',arg:3,' name=',fname);writeln('1st ent=',first_entry:3,' no of ents=',no_of_ents:3);Append(fname,'.????????'); {file name is wild unless specified}handle:=Block(fname,result);IF result<>0 THEN Writeln('file name error',result:3);dir_code:=Dir_first(handle,addrint(big_buffer[128]));entry:=0;WHILE entry<first_entry DO BEGIN  dir_code:=Dir_next(handle,addrint(big_buffer[128]));  entry:=succ(entry)END;index:=buff_size-4; {pointer into big buffer}WHILE (dir_code<>255) AND ((entry-first_ent)<no_of_ents) DO BEGIN  getstr(addrint(big_buff[127])+dir_code*32,11,fname);  CASE arg OF  3:BEGIN    Mid$(fname,0,8);    append(fname,'          ');    Putstr(addrint(big_buff[index]),fname);    index:=index-19;    big_buff[index+1]:=0; {terminator}    END  END;  dir_code:=Dir_next(handle,addrint(big_buffer[128]));  entry:=succ(entry)END;big_buff[index]:=128; {final terminator}big_buff[buff_size]:=0;big_buff[buff_size-1]:=0; {TX header}big_buff[buff_size-2]:=entry-first_entry;TRANSMIT(0,mainRX.reply,client_stn,Addrint(big_buff[index]),buff_size-index+1,  result);IF result<128 THEN notlisteningEND;Procedure I_am;{Fudge the issue}VAR a,result:BYTE;BEGINmainTX.cmd:=5;mainTX.rtncode:=0;FOR a:=min_size DOWNTO min_size-3 DO mainTX.data[a]:=0;TRANSMIT(0,mainRX.reply,client_stn,addrint(mainTX.data[min_size-3])  ,6,result);IF result<128 THEN notlisteningEND;.