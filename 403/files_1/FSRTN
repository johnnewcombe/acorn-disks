 NAME FSRTN PROG ; ; ENTRY ADDRINT ENTRY ADDR1 ENTRY ADDR2 ENTRY ADDR3 ENTRY ADDR4 ENTRY PUTSTR ENTRY GETSTR ENTRY GETSTRCR ENTRY CLI ENTRY MID$ ENTRY LAND ENTRY LO ENTRY HI ; ; ; FUNCTION ADDRn(VAR data:<type>):INTEGER ; ; This function is provided to overcome the limitation that a ; FUNCTION has to take parameters of fixed type. This is a problem ; particularly with data areas for RECEIVE and TRANSMIT ; An ADDR function is declared for each type that is to be used in ; this way, and simply returns the address of the variable ; These will usually be structured types to accept a whole packet. ; ; **************************************************************** ;          BEWARE!!! ; This routine CANNOT take an integer TYPE as parameter ; use ADDRINT instead (this removes the extra size byte from stack) ; **************************************************************** ; ;ADDR1ADDR2ADDR3ADDR4 POP H ;Return address POP D ;Return value XRA A ; A=0 to keep Pascal happy PCHL ;JP(HL) by another name! ; ;ADDRINT POP H INX SP ; Discard extra byte (size of integer) POP D XRA A ; A=0 to keep Pascal happy PCHL ; ; ; ; PROCEDURE PUTSTR(addr:INTEGER,VAR srce:$STRING0); ; ; Transfer string <srce> to memory at <addr>, reversing the order of bytes ; and transferring only the assigned length ;PUTSTR POP B ; Return addr POP H ; Pointer to string POP D ; Memory addr PUSH B MOV B,M ; LengthPUT1 DCX H ; Move down string - initially -> length MOV A,M STAX D INX D DJNZ PUT1 XRA A ; A=0 to keep Pascal happy RET ; ; ; ; PROCEDURE GETSTR(addr:INTEGER,length:BYTE,VAR dest:$STRING0); ; ; Reads <length> bytes into string <dest> from memory at <addr>, reversing ; byte order for Pascal convention. ; ;GETSTR POP B ; Return addr POP H ; String addr DCX SP ; push one byte garbage POP PSW ; Length to A, garbage to F POP D ; Mem addr PUSH B MOV B,A MOV M,A ; Set string lengthGET1 DCX H ; Point to next byte down string LDAX D MOV M,A INX D DJNZ GET1 XRA A ; A=0 to keep Pascal happy RET ; ; ; ; ; ; PROCEDURE GETSTRCR(addr:INTEGER;length:BYTE;VAR dest:$STRING0); ; ; Reads bytes into string <dest> from memory at <addr>, reversing ; byte order for Pascal convention. Stops when a CR is encountered, ; or <length> chars have been copied. (The CR is not put into the string) ; ;GETSTRCR POP B ; Return addr POP H ; String addr DCX SP ; push one byte garbage POP PSW ; Length to A, garbage to F POP D ; Mem addr PUSH B ; Put back return address PUSH H ; Needed to insert length MOV B,A ; Max length MVI C,0 ; Count of chars actually copiedGETCR1 DCX H ; Point to next byte down string LDAX D CPI 13 ; Check for CR JRZ GOTCR INR C ; Count MOV M,A INX D DJNZ GETCR1GOTCR POP H ; Addr of top of string - length byte MOV M,C ; Set string length XRA A ; A=0 to keep Pascal happy RET ; ; ; PROCEDURE Mid$(VAR text:$STRING0;start,length:BYTE); ; ; Sets the supplied string equal to the specified middle section ; allowing for out of range parameters, eg Mid$(a$,3,255) returns the ; rest of the string from position 3. The first position is 0. ;MID$ POP D ; Return adr POP B ; B=start, C=length POP H ; String addr PUSH D ; MOV A,C ; length ADD B CMP M ; Compare actual length with length required JRC ENOUGH ; String long enough MOV A,M ; Real lengthENOUGH SUB B ; Final length JRNC STARTOK XRA A ; If start position off end, final length=0STARTOK MOV M,A JRZ TRIVIAL ; Avoid moving no bytes (LDDR can be fatal) MOV C,A MOV E,B MVI B,0 MOV D,B ; DE=Start pos, BC=length DCX H ; Point to string not length PUSH H ORA A ; Clear Carry DSBC D ; HL=start of desired part of string POP D ; Destination=start of string memory LDDRTRIVIAL XRA A RET ; ; ; ; ; FUNCTION Land(a,b:Integer):Integer; ; ; Forms bitwise logical AND between two integers ;LAND POP H ; Return addr POP B POP D MOV A,B ANA D MOV D,A MOV A,C ANA E MOV E,A ; Result in DE XRA A PCHL ; Return ; ; ; ; ; FUNCTION Hi(A:Integer):BYTE; ; ; RTeturns high byte of 2 byte integer ;HI POP H ; Return addr POP D MOV E,D XRA A MOV D,A ; high byte of result PCHL ; Return ; ; ; ; ; FUNCTION Lo(A:Integer):BYTE; ; ; Returns low byte of 2 byte integer ;LO POP H ; Return addr POP D XRA A MOV D,A ; high byte of result PCHL ; Return ; ; ; ; ; ; ; ; ; ; FUNCTION CLI(VAR cmd:STRING 255):BYTE ; ; Examine string and return 'command code' for any command found ; using Acorn standard values : 8 signifying no command found. ; On return, the command text is removed from the string, leaving parameters. ;CLI POP B ; Return addr POP H ; String addr PUSH B PUSH H MOV B,M ; String lengthSKIPSP DCX H MOV A,M ; Next char CPI ' ' JRNZ DONESP DJNZ SKIPSPUNRECCMD POP H ; String addr XRA A ; A=0 MOV D,A MVI E,8 ; Return value RET ;DONESP XCHG ; String ptr to DE LXI H,CMDTAB ; Pointer to command tableNEXTCMD PUSH D ; Keep start of cmd text to try again PUSH BCHLOOP LDAX D ; Char from user ANI 05FH ; Case equate & kill top bit XRA M ; Unusual compare JRNZ NOTEQ INX H ; Next char of table DCX D ; and of user cmd DJNZ CHLOOP INX H BIT 7,M ; Almost at end of cmd? JRNZ GOTCMDENDTEXT POP B POP D ; Start again from startENDCMD INX H BIT 7,M JRZ ENDCMD INX H ; skip marker MOV A,M INR A ; A=0 If next cmd starts FF ie end of table JRNZ NEXTCMD JR UNRECCMD ;NOTEQ ; Gets here if mismatch found JM GOTCMD ; Top bit set in table <=> end of command XRA M ; Back to original text CPI 0EH ; Check dot abbreviation (<dot> AND &5F =&E) JRNZ ENDTEXT ; Go round againDOTLOOP INX H BIT 7,M ; Look for end of table JRZ DOTLOOP DCR B ; Character at (DE) is dot and hence not required DCX D ;GOTCMD MOV A,M ; Command code ANI 07FH STA TEMPBYTE POP H ; Skip old BC, DE on stack POP H POP H ; Addr of string start MOV M,B ; Save new string length DCX H ; Destination for rest of string is 1st byte XCHG ; ready for LDDR XRA A ; A=0 : remains so until RET CMP B ; LDDR with BC=0 is a bad idea JRZ NOMOVE MOV C,B MOV B,A LDDR ; Put rest of string at startNOMOVE LXI H,TEMPBYTE MOV E,M ; Return value MOV D,A RET ; A already 0 ; ; ;CMDTAB DBS 'CAT',3 ; DBS Sets top bit of last byte DBS 'SAVE',1 DBS 'LOAD',2 DBS 'INFO',4 DBS 'I',0,'AM',5 ; <space> AND &5F =0 DBS 'SDISC',6 DBS 'SDISK',6 DBS 'DIR',7 DBS 'LIB',9 DBS 'CDIR',252 DBS 'BYE',253 DBS 'DELETE',254 DB 0FFH ; DATATEMPBYTE DS 1 ; ; ;