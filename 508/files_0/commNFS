|\ commNFSNetwork filing systemFacilities provided by current NFS :|i2|mOPEN /CLOSE  Open for input/ output / update, close.  Implementation is as for BBC, except that communicator handles are 16-bit.  Close#0 is perhaps a problem.|mOSFILE type interfaceMachine readable version of *LOAD, *SAVE.  Could perhaps be implemented using Communicator memory handles, although it is not clear that this gives the ability to dynamically kill tasks which is the motivation for such a scheme.  Alternatively, leave current version with full addresses & suggest that load/save are for 'hacking' purposes only.Read / write catalogue information for named object.  Must be provided; no particular problems.Delete object & return catalogue information.  Rather an odd call - catalogue info is obsolete once the file is deleted!  This call used by Master OS for *DELETE, but this is a BAD idea; better to let the fileserver handle the command line.Create file (NEW on ANFS).  Implementation of fileserver end of this call is difficult / impossible; either the filespace is allocated & left untouched (intolerable on security grounds), or it is allocated & zeroed (takes too long and causes No Reply timeout from clients) or no space is allocated (defeats the whole purpose of the call.  No particular problems in implementing it on the communicator, but is it worth it?|mOSARGS type interfaceRead / Write file pointer & extent.  Presumably these calls already exist on communicator.  NB. write extent is a new ANFS feature.Read file size (ie. amount of disc occupied, which may be greater or smaller than 'extent' which is the logical size of the file).  No problems.Ensure file buffer to media.  No problems.Return handle information.  This new ANFS feature returns various obscure information about the given handle, some of it useful.  In particular, the translation from internal handles (16-bit on communicator) to fileserver 8-bit, 2^n handles is given; on earlier NFS versions this mapping was exthand=2^(inthand-32).  The mapping info is useful for programs which want to talk direct to the fileserver for some functions (eg. record locking) referencing objects which have been opened through the NFS.Return filing system type.  Redundant on communicator as there is no concept of currently selected FS? (or if there is, this is an OS function).Return address of command tail.  See discussion below on transients.Return NFS version.  Due to dud Acorn transients, BBC versions can only return two values; =2 => amazingly bug-laden version 3.34, =1 => all other versions.  Not really relavent on the comunicator, as the module version number is readily accessible?|mOSBGBP type interface.File read / write calls.  These seem to have been deleted from the communicator design on the grounds that BGET, BPUT are just as good if you have the blocking algorithms of ANFS.  This is not so, for two reasons : reading whole files via BGET is still not very efficient; and, more importantly, future fileservers which support multiple writers to an open file with record locking etc. are ruled out because the local buffers for BGET / BPUT may hold information which is out of date.  Reading a record that happens to be in a buffer will return a possibly old version, but writing a record that happens to be in a buffer may corrupt adjacent records if the record size is not equal to the buffer size.  On BBC ANFS, this problem is avoided by performing all access to such files via OSBGBP, which circumvents local buffering.Read disc title, boot option, CSD name, library name.  Not specially useful, but fairly easy to implement; need to transfer a moderate amount of results (20 bytes or so) - could use the CPUT/CGET type interface.Read filenames in directory - machine readable version of *CAT.  Could again use CPUT/CGET interface.|mBGET, BPUT  Already implemented in the obvious way.  EOF handling may need to be specified?|mMiscellaneous calls - formerly via OSWORD interface.Read / set fileserver station no.  See discussion below on contexts.  Write had the side-effect of ensuring all file buffers to the old fileserver on ANFS.Read / set context handles.  See discussion below on contexts.Read error number.  Formerly required because fileserver error numbers exceeded the range of available BBC error numbers; many errors were mapped onto one error number and this call could be used to find the original error.  Not relavent to communicator if we fix an error reporting scheme that has 16-bit error numbers.Read file handle concerned with last error (ANFS only).  Is this call useful?Read / write fileserver time.  Should be integrated with the communicator's concept of time?  {Why does the communicator have hardware RTC when all communicators have network interface??}Adjust timeouts for communication with fileserver.  Need for one setting per context? (I don't think so).Translate network number.  Converts station numbers supplied by the fileserver into station numbers suitable for direct use.  Needed because the fileserver's idea of 'on my local network' may not be the same as the client's.  Part of this function (that of converting full network numbers to zero when local) has been specified into the primitives on communicator, but knowlege of the fileserver's network number is obviously an NFS function.  Call could be provided, or the job could be left up to the user, as all the necessary information is available.  As this function is almost exclusively used after the 'where is "FRED"' fileserver call, we could put that function into the NFS instead - we could even make it interogate all known fileservers rather than the current context.FS call.  Passes an argument block of up to &50 bytes to the fileserver, with standard header filled in to suit the current environment.  Returns an undefined (possibly large) amount of information.  Used, mainly by transients, to implement any fileserver functions not provided by the NFS.  Communicator implementation might want to pass an environment handle?|mOSFSCM interface - converted from other calls by BBC OS*OPT 1 - display messages on load / save.  To be done by OS / Not wanted on communicator ??????*OPT 4 - set boot option.  To be passed through to FS.  No problems.EOF - no problems.*RUN - See transients.*CAT - Who decodes this ?Kill file system - N/A on communicator, as all filing systems can be active at once.Read handle range.  Different on communicator ?|m*COMMANDs - locally decoded*I AM - locally decoded AND passed to fileserver for decoding.  Effect on contexts?*BYE - Locally decoded to allow side effects (Eg. ensuring files)LCAT, FLIP, LEX - Contexts ?Many others are decoded locally simply to provide for local syntax checking and implementation of the & facility.  I don't approve of this (I think & should be done in the fileserver), because it limits future expansion of these commands at the fileserver end, but current Acorn implementations do so.|m*COMMANDs - decoded by fileserverDifferent fileservers decode a wide range of commands and perform them without further work by the client.  *INFO, *DIR, *SDISC, *I AM and *LIB are alll decoded by the fileserver, but pass back a reply requiring further action by the client.  In the case of *INFO, this means a line of text for display (note that other fileserver-decoded commands may pretend to be *INFO for the purpose of getting somthing displayed); all the others are passing back new context handles.|gcommTRA