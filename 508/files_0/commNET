.x||r90|\ commNET|u|cInterfaces between the Econet software & Communicator OS14 aug 86 A.R. GordonIt is proposed to divide the present Econet software into three modules on the Communicator.  These are : the Econet primitives, the network filing system, and the network printer driver.  The first two are already in existance on the communicator and will have to be split apart; the printer software has not yet been converted to 65816 code.  All three modules will have substantial changes to their software interfaces, in order to fit the constraints of communicator OS.  Existing code is not position-independant; it is proposed to convert the network primitives to be so, and also the NFS if time permits; the printer driver will be written position-independant from the beginning.Module names are required.  Users are familiar with "NET" meaning the network file system, although this would be a better name for the primitives.  If this cannot be changed, I suggest "NETPRIMS", "NET" and "NETPRINT".|uEconet PrimitivesRequires :A means of claiming NMI vectorSet soft station number (or read it if maintained by OS)  (BBC uses 'secret' utility)Must provide :Read station number  (BBC uses osword &13, shared with NFS functions)Network transmit & poll for success  (BBC uses osword &10, osbyte &32)Network open receive, poll for reception, read results, delete block.  (BBC uses osword &11, osbyte &33,&34 and, in recent versions, events)Read / Set protection status  (BBC uses osword &13, shared with NFS functions)Remote Procedure call & arguments  (BBC uses event plus osword &12 to read arguments)Remote Halt / Continue  (BBC sets a flag, then polls it (in IRQ rtn, IRQ enabled) until CONTINUEd)Remote JSR & arguments  (BBC does JSR to given address, which is expected to read args via oword &12)Remote OS procedure call  (BBC supports :     Insert char in input buffer (*NOTIFY)     Start a *REMOTE     Get screen mode, palette etc. (used by *VIEW)     Cause fatal error     Accept character in *REMOTE stream  )Remote Peek, Poke and Return machine type  (These are straightforward & already implemented correctly)Proposals :|i2|mRead station numberBy standard device driver read parameters|mNetwork transmit & poll for successProposed new TXCB format :  +-------------------------+  | Ctrl code               | 1 byte   MSB must be =1  +-------------------------+  | Port                    | 1        =0 for immediate ops  +-------------------------+  | Destination Station     | 2        Will be translated for local net no.  +-------------------------+  | Buffer memory handle    | 2        Gives start address of buffer  +-------------------------+  | Actual length required  | 2        Will be checked against handle's size  +-------------------------+  | Immediate op arguments  | 4        eg. remote peek address. N/A for std Tx.  +-------------------------+                       total  12Some sort of COP call for initiating a Tx - do we want a chain of tx blocks & handles & polling for completion (this goes a little beyond the BBC) or just simply a call that doesn't return until Tx complete?  Most BBC code goes REPEAT REPEAT trytotx UNTIL txavailable; REPEAT polltx UNTIL finished UNTIL successful OR timeout.  Perhaps we want a user defined number of retries.|mNetwork open receive, poll for reception, read results, delete block.Proposed new RXCB format :  +-------------------------+  | Ctrl code               | 1 byte   =&7F (or &04 for procedure call)  +-------------------------+  | Port                    | 1        =0 for wildcard  +-------------------------+  | Station                 | 2        =0 for wildcard, =&FFFF for broadcast  +-------------------------+  | Buffer memory handle    | 2        provides start addr of buffer & max size  +-------------------------+   | Actual length returned  | 2        Not provided when setting up call  +-------------------------+  | Module handle for event | 2        Module is entered when packet received  +-------------------------+  | Remote procedure no     | 2        =0 for wild (only present if ctrl=&04)  +-------------------------+                       total  12Some sort of COP call to set up and to read result - call with zero handle to set up and return handle, call with nonzero handle to read & delete.  Do we supply a poll for reception, or do we expect everyone to handle events?|mRead / Set protection statusBy standard device driver parameters.  Note that Remote procedure call no longer needs to be protectable against.  Default in ROM = all protected ???|mRemote Procedure call & argumentsSince events are now to be available on standard receive packets, it is suggested that remote procedure call be treated as for standard Rx.|mRemote Halt / ContinueAs BBC, except that I think this should be a reference count (although there is the problem of multiple reception)|mRemote JSR & argumentsCould be implemented BBC-style, but I suggest that a better implementation would allocate some memory for the 'arguments', which are assumed to be position-independant code, and would then execute them.  Non-standard implementation does not matter too much, as JSR addresses are highly machine dependant in any case.  BBC implementation requires that you Poke in some code at an address you assume to be available and then call it - remote JSR is no good for calling BBC OS routines.  Can we claim memory inside an NMI routine, or do we only allow one RJSR at once?  We seem to need a fixed buffer size, as you don't know how big a network packet is going to be until it has arrived.|mRemote OS procedure callExisting calls :  Insert char in input buffer (*NOTIFY) - could be supported  Start a *REMOTE - could be supported  *VIEW support - Not wanted / not entirely possible  Cause fatal error - not possible ?  Accept character in *REMOTE stream - support if supporting *REMOTEAlternatively, treat OS procedure call like user procedure call, allowing a future module to be written to support some / all / more of these.|mRemote Peek, Poke and Return machine typeImplemented as for BBC. Problem with crossing Bank boundaries?|iComments :Station ID is read from low 5 bits of hardware links. If zero, the soft (CMOS)  ID is used instead. Soft IDs are only valid in the range 100..200.  Software will inspect the hardware frequently to foil hackers who discover the address of the soft copy of the hardware statid.Existing code checks for invalid statid, no clock, or Econet module not present & will not initialise. Do we need to tolerate non-fitted hardware?  For the other two conditions, I think the code should initialise but lie dormant until the condition clears.How much of the code should be in bank zero?broadcast??Do we need to prohibit buffers spanning block boundaries?  If so, is it easy to test for?|w|gcommNFS