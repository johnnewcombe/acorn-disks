|\ commTRA|m*COMMANDs - unrecognised (ie. TRANSIENTs)Standard NFS implementations regard unrecognised *COMMANDs as equivalent to *RUN <commandname>.  This loads a file into memory at the address specified by the file and commences execution at an address also specified by the file's attributes.  These are known as transient commands, as they are reside in memory for a short time and then depart, allowing further transients to run.  Machine-code applications are also run in this way, although they are not transient in quite the same sense.  ANFS implements an extension to this scheme : if the execute address is 'silly' (ie. &FFFFFFFF), the file is *EXECed instead.  Files with a load address >= &FFFFFF00 are faulted unless the execute address is &FFFFFFFF.On the 6502, it is very difficult to write position independant code, so transients have to be assembled in particular places; this means that transients have to be compressed into the tiny areas that are likely to be available, and clashes occur (eg when using a fast exec transient to exec a file that calls up another transient).  On the communicator, any reasonable transient could be made position independant, and so a *RUN mechanism which claimed some memory and loaded the file into there would be much more satisfactory.  I suggest that we extend the special execute address convention such that &FFFFFFFF => *EXEC, &FFFFFFFE => position-independant; this means that we have the normal address range available either to support either position-dependant communicator code, or (as I prefer) to be regarded as 'BBC' code which can be rejected as it would crash the communicator.  The entry point for transients could be defined to lie at the beginning, or we could use the 'load' address as an offset.  Thought to be given to loading of modules in this way...Transients often wish to pick up parameters from the tail of the command line that loaded them.  This could be done (BBC style) by means of a separate call to return it, or could be passed in to the transient in registers when it is entered (my preference).  Thought to be given to the ownership of the memory containing the command line ....|mContextsThe network file system has the concept of a 'context', which comprises a fileserver station number, three file handles corresponding to the current directory (CSD), current library (LIB) and user's root directory / home directory (URD).  There is also further context information held in the fileserver (ownership rights, privilege etc.).Various *COMMANDs manipulate this context : *DIR, *LIB, *SDISC, *FLIP all modify the handles; *BYE invalidates a context; *I AM creates a new context, deleting any precious context on that fileserver, and *FS searches through the available handles trying to find a set that looks plausible to construct a context on the specified fileserver.  In addition, the user can open handles to directories in order to construct a new context, allowing such programs to flip rapidly between contexts - eg. for copy programs, or on Acorn fileservers, to prevent the loss of ownership when a full pathname is used to select a directory.  All file handles have their fileserver number recorded with them by ANFS, and it tries to ensure that data buffers are emptied to a fileserver before that context is lost.All this works adequately for a single task computer; but on a communicator there is already the concept of switching between contexts at the user level, and users will be unhappy when switching to a database in another task selects a different directory and so causes VIEW to foul up when he tries to save the document he was originally working on.  Also, the restriction of 5 user file handles per fileserver is very restrictive in a multi-task environment.A scheme has already been proposed for allowing multiple log-ons to a fileserver from one client; we need a way of integrating this into the communicator OS, and I think that these other 'context' concepts should be fitted into the same scheme.HOW???????????????????????