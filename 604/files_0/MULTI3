|\ multi3|a4|u2.5 InitialisationThe code generated by the compiler for a main program segment starts by branching to a library routine, which is expected to load the stack pointer and set up the heap (the return address is passed in a register).  The standard version of this routine obtains the address and length of the available memory from the operating system.  In the fileserver, as there is no underlying operating system, the addresses of the limits of program and COMMON data areas are implanted by the link editor and used in conjunction with knowlege of the memory map.  The initialisation routine allocates memory for a stack and a task control block for each task (the relavent number determined by a manifest), and initialises the heap to use the remaining memory between the end of the fixed data and the program code.  Each stack is initialised with a copy of the program counter and IX register value which the (single task) initialisation is expected to return, and all tasks are marked as ready to run.  The initialisation routine now jumps into the task scheduler, which selects the first task and activates it, effectively returning from the initialisation call.  When the first task suspends itself, the scheduler will activate one of the others, which will also appear to have just returned from the initialisation call : the initialisation routine has generated a number of instances of the same program.Although these tasks all start off in the same way, returning from the initialisation call and entering the main program body, they do not continue identically.  The scheduler maintains a global variable containing the current task number, and this is tested early in the main block.  The first task initialises the disc system, marks the disc read only, and starts a scan of the directory structure to build a free block map.  The second task starts up the printer server, while other tasks poll for client requests.|a4|u2.6 Debugging aidsSince this software has to run on the raw hardware, with no operating system assistance, some attention had to be given a development environment.  The compiler, assembler and link editor were used on a BBC micro (with Z80 second processor), generating object code ready to execute.  The fileserver itself has a small ROM in the main processor : the program in this usually loads the fileserver program from the disc and executes it directly, after which the ROM is switched off (the program for the I/O processor exists permanently in ROM).  In order to load the program into the machine (and hence onto disc), the network primitives are provided in the ROM.  A simple character stream protocol is used to attach another network station as a terminal : commands are available to read or write the disc, and to execute programs.  Network 'immediate operations' can now be used to write directly into the memory of the fileserver from the development BBC micro.In addition, there was a need to generate diagnostic output once the fileserver was running.  Earlier versions of the fileserver, running on simpler hardware, had used the printer port for this purpose, but in this case the need to communicate with the I/O processor to control the printer is a serious problem if those communications are suspect.  It would have been possible to use the network and the virtual terminal protocol, as described above, but this would clutter the network and confuse the display of the packet monitor program which is used to observe transactions between server and clients.  The small hardware effort required to provide a completely independent diagnostic channel was considered worthwhile to prevent interaction with other parts of the system.A spare I/O port on the main processor was used to provide an RS232 serial interface, to which a terminal could be attached.  Initially, this was used to display debugging output from statements inserted in the program, but later a more powerful facility was provided.  A simple monitor program was written, with commands to display and modify memory, access I/O ports etc.  This monitor was integrated into the fileserver as a task : it polls for keys typed on the terminal and suspend if none were available.  The basic commands allowed all the main data structures of the fileserver to be inspected while it was running, and extra commands were provided to set various global variables directly, controlling the quantity of diagnostic output produced.  In particular, the display of all communications with the I/O processor could be enabled only when required; it was previously impractical to display this level of detail, as the quantity of output produced while starting up could take over 15 minutes to display.Unfortunately, the lack of memory protection and this coroutine style of multi-tasking make it possible for system to loop, not running the debug task.  While such crashes were rare, it was useful to have a logic analyser available to take a 'snapshot' of processor activity.  The analyser was also used when a data structure was found to be corrupt, to detect which part of the program was writing the erroneous values.Overall, the effort expended on debugging aids was well repaid by increased speed of debugging.  In addition, more thorough testing was possible, as it could be verified that the program was in fact working in the way intended and not producing the correct results by coincidence.|w|gdata