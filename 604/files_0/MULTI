|\ multi|a4|u2. Multi-taskingThere are two possible ways in which multi-tasking could have been introduced : time slicing or coroutines.  Coroutines have three advantages over time slicing : no interrupts are required to schedule tasks, the frequency of task swapping is reduced (hence reducing the amount of processor time wasted in running the system), and the interlocking of updates to data structures is simplified.  The usual reason for time slicing, to prevent any one task from consuming an unfair share of resources, does not apply here : no task can run for very long without either requiring access to the disc or finishing a client request.  The system chosen for the fileserver is to allow any task run until it requires access to a peripheral, wherupon control transfers to other tasks until the peripheral controller indicates that the data is ready.  A circular priority scheme is operated : when a task has been suspended, it will not be re-started until all other tasks that are ready have been run.The introduction of multi-tasking into the existing fileserver imposes two main problems.  Neither standard Pascal, nor the implementation used, provide any form of multi tasking support or coroutines, so work is required in machine code to introduce this.  In addition, the program and data already occupy almost the whole 64K address space of the Z80, so the additional space required for multi-tasking control purposes and other planned enhancements requires some re-design.|a4|u2.1 Memory addressingThe most obvious solution to the memory addressing problem, given that the program is mostly written in a high level language, is to change to a processor which has a larger address space.  There are two reasons why this was not done, the most important being that the network primitive routines represent about two man-years of work, making the use of any new processor expensive either in development work or in hardware if an attached Z80 is used.  The second reason is that many 16 bit microprocessors, with large instruction formats, are not very efficient at the simple tasks of copying data and block I/O : a fast 8 bit microprocessor is more cost-effective way of providing the performance required.In this case, a fast Z80 is provided with 128K of RAM, which is configured in a way which minimises the overheads of bank switching.  The fileserver program falls into two parts : a collection of common subroutines (from multiplication of two numbers to opening a file), and a number of independent sections which process the different kinds of request which may come from a client.  The memory addressing is arranged such that a 48K section is permanently accessible, while the remaining 80 K is divided into 16K banks, only one of which can be active at once.  The fixed section is used to hold all the data structures, all the library routines, and the handlers for interrupts.  The program code for handling client requests is divided between the switchable banks, such that any interdependent procedures are in the same bank.  This means that changes from one bank to another are only required when a task starts processing a new request from a client, or when changing tasks.|a4|u2.2 Pascal object codeIt is intended to set up several tasks all running the same program code; to do this, it is necessary to understand the operation of the object code produced by the compiler, and the ways of interfacing to it.  In particular, separate copies of program variables must be provided for each task.The compiler generates object code in the form of relocatable modules; a link editor is available to combine these with the library routines of the run time system and produce executable code.  It is possible to compile the source code in several modules and link these together : EXTERNAL declarations (with the same syntax as FORWARD declarations in standard Pascal) generate external references to procedures to be resolved by the linker, while the entry points to all procedures are made available to the linker automatically.  This means that subroutines can be written in assembly language and used as if they were Pascal procedures.There are three classes of variables in Pascal programs : local variables of procedures, global variables, and variables stored in the 'heap', accessed by pointer.  With this compiler, these are stored as follows :|i5|vLocal|z variables are stored on the stack (the Z80 only has one stack pointer).  The stack also stores return link addresses for subroutine calls and interrupts, parameters to procedures, and temporary results.  An index register (IX) is used to address the current stack frame; stack frames are chained to allow access to free variables.|vGlobal|z variables are allocated fixed store locations, which are bound into the object code by the linker.  A system of named COMMONs (like Fortran) is used to allow separate modules to share global variables : variables declared by COMMON rather than VAR generate a common area with the same name as the variable.  As COMMONs are controlled by the linker, they are also accessible to modules written in assembler.  COMMON variables are directly addressed, usually making access to them more efficient than to local variables.|vPointers|z are implemented as 16 bit integers containing the machine address of the start of the allocated memory.  The standard procedures NEW and DISPOSE translate into calls to a library module, which can be modified if required.  The standard version has the base of the heap at the end of the global variable area, and adds new items at higher addresses, while the stack starts at the highest available address and grows towards the heap.  DISPOSEd areas of memory are linked together and re-used if possible.|i|a4|u2.3 Storage of variablesEach task clearly needs a separate stack, and so we must store the stack pointers for all dormant tasks in their task control blocks.  It is also useful to know the base address of each stack so that stack overflow can be detected.  The existing program makes little demand on the heap : a fixed amount of memory is claimed when the program is started, and there are no subsequent calls to NEW or DISPOSE.Global variables pose more of a problem.  Some of them are global across the whole system, such as the time of day or the pointer to the active user table; such variables can remain as globals at fixed addresses.  However, variables such as the station number of the client being serviced are clearly associated with individual tasks.  One option is to declare the current main program as a procedure, with the current global variables local to that procedure.  This would move the variables onto the stack, but would have disasterous consequences for efficiency of access from inner levels of procedure call nesting.  In addition, scope rules would make such variables inaccessible to procedures in other modules.The solution is to have a global variable which is a pointer to the task control block for the currently active task : the 'global' variables would now be fields of the task control block, and the pointer would be updated by the scheduler when swapping tasks.  However, there are three variables which are accessed so often that the extra indirection required to access the task control block would be a significant overhead.  The compromise adopted is to keep a copy of these variables in global storage, and to copy these to and from the task control blocks when swapping tasks.  The final declarations are reproduced below.|gmulti2