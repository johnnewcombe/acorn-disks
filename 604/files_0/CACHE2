|\ cache2Two extra details are revealed here : the handling of entries in transit, and a minor coding optimisation.  The problem with entries in transit is that we may wish to run other tasks while waiting for the data to arrive from disc.  The task initiating the transfer must hold a reference to the entry, as it might otherwise be re-used by some other task causing disastrous results when the data eventually arrived.  In addition, other tasks may request the same entry.  Such tasks must be able to identify the 'in transit' entry as the one that they want, as they would otherwise generate duplicate entries, but they must not proceed until the data has actually arrived.  The solution adopted is a minor abuse of the reference count : values greater than 127 are used to indicate 'in transit' entries.  The task generating the transfer sets the reference count to 128 (no other tasks can possibly hold references yet), and suspends until the transfer is complete, using the standard mechanism.  Other tasks which try to use the entry will observe this value, increment it to establish a reference (in case the entry should be arrive and depart again before they next run), and poll for the value dropping below 128 (suspending between each poll).  When the originating task is re-started, it subtracts 128 from the reference count, indicating that the data is available and still recording the references held by the other tasks.The specification for the cache lookup routine is optimised for use by tasks reading a number of entries in succession.  The reference count of the entry returned is not incremented; there is no danger of the entry disappearing until the task next suspends itself or requests another entry, and so there is often no need to formally hold a reference.  In addition, the pointer to the requested entry is not returned directly, but the head of list pointer is made accessible to other modules of the program : on exit from the lookup routine, the entry just found is always at the head of the list, and will stay there for as long as an entry is safe with a zero reference count is safe.  In this way, most operations can address the entry by use of the |Bc_ent|C global (faster than a local variable), and those wishing to hold an entry for longer will have to take a copy of the pointer and increment the reference count.  It can be seen that this rather 'dirty' piece of programming actually makes it easier to write correct code.|w|gconclus