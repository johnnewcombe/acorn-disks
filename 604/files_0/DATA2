|\ data2|i10|t6 1) Release any existing reference to the object.  The object must be prevented from deletion by either holding a lock on the parent directory, or by the normal mechanisms for preventing open files from being deleted.|t6 2) If the lock indicator is already set, increment the count of waiting tasks and wait for the lock to be released.  When the lock is released, the wait count can be decremented again (this is the same procedure as trying to reference a locked object).|t6 3) Increment the reference count, and set the lock indicator.|t6 4) Wait for the reference count to reach 1.|iHolders of references will either finish using them, or try to convert to a lock; in either event the reference will be released.  These reference holders can only be delayed by waiting for locks at this or lower levels : such locks cannot be held by tasks waiting to reference or lock the object in question, so deadlock is again avoided.This scheme has the important property that other tasks attempting to reference the object are locked out from the start : simpler schemes that waited for all existing references to be removed before asserting the lock would allow new references to be established during that time and so further delay the lock.  This would allow the original reference holder to complete a client request and begin to service another before the lock was established; potentially this could require another reference to the same object.  From an external viewpoint, this would mean that a pair of clients performing repeated catalogues of a directory could indefinitely delay an attempt by a third client to update that directory : this would lead to the client timing out and reporting an error to the user.|u3.4 The disadvantagesThis complex scheme has the serious problem that it cannot handle the rename operation.  When an object is renamed, a new directory entry is created with the target name, the remaining details and block list are copied from the original entry, and the original is then deleted.  The requirement that the object remains unchanged if any error prevents the rename means that both the source and destination directory need to be locked at once.  Since we have no knowledge about the relationship between the source and destination directories, the logic which guarantees to avoid deadlock no longer applies.  Any suggestion which involves establishing the locks in sequence cannot guarantee to avoid deadlock, and the alternative of waiting for an oppertunity to lock both directories at once suffers from the problem of potentially being locked out indefinitely.Another disadvantage of the original scheme was its complexity.  There are so many parts of the fileserver which manipulate directory entries that it would have been very difficult to demonstrate that the interlock system was correctly implemented and covered all contingencies; in addition, future maintenance or development of the program would require great care.  While this does not rule out such a system, it is a strong disincentive.|a4|u3.5 Final schemeThe scheme finally adopted is very simple : a flag is set when any critical operation is in progress, to prevent the task from being suspended.  Taken at face value, this would seem to discard almost all the advantages to be gained from multi-tasking.  However, it can be arranged that before each critical operation all the blocks that may be required are already loaded into the cache : the block list for the relevant directory is passed to the I/O processor, and the task suspends until the blocks are all available.  This means that any disc requests made while task switches are disabled will be serviced very rapidly indeed, and so very little time is wasted.|w|gprinter