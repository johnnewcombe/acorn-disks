|\ data|u3. Data structures & interlocksThere are two data structures which are global to the whole fileserver : the directory structure on the disc, and the user table in main memory.  The full details of the disc format are given in appendix I, but the important features are described below.  The user table is organised as a linked list of entries, with one entry per client station.  'User' here is strictly a misnomer, as a single human user may be using more than one station at once, but this is not important.  The list is maintained in sorted order, with the most recently active user at the head : this speeds up the search process : many users are inactive for very long periods.The directory system on the fileserver is a strict hierarchy.  Each directory has a descriptor entry in some other directory, with the same format as the entry for a file; the disc address of the descriptor for the root directory is fixed (at offset 0 in block 0).  Each entry contains a number of fields, including the name, access controls, and length.  Some fields depend upon the type of the entry : directories have the disc address of the descriptor for their parent, while files have load and execution addresses for use by the client.  Each entry also has a list of 16 disc block numbers; these blocks either contain the data - for a directory or short file - or for a large file they contain the block numbers of the blocks holding the file data.  If the entry describes a directory, the first entry of the first block contains a hash table giving the start of the chain for each letter of the alphabet : remaining entries are assembled into linked lists in alphabetical order.'Object' is used in this discussion as shorthand for 'file or directory'.  Any object can be uniquely identified by a disc address : this is the drive number, block number, and entry offset in that block of the describing entry.|u3.1 Simple interlocksThe fileserver design requires three independent forms of interlock : a high level interlock on updates to files which is visible to users, and two interlocks to prevent corruption of the directory structure or user table caused by two tasks simultaneously updating the same entry.  This latter interlocking is invisible to users; they expect such operations to be performed in sequence, but we wish to overlap the disc transfers for one operation with the processing of another if there is no conflict.The file interlocks are achieved by holding a file control block for each open file in the memory of the file server.  This holds the disc address of the directory entry describing the file and the access requested (read, read/write or extend).  Any attempt to delete or open a file causes a search of all active file control blocks for references to that file; prohibited operations (such as deleting an open file) are reported to the user.Each client's current directory, user root directory (or 'home' directory) and library are also allocated file control blocks; this prevents these directories from being deleted and so allows disc addresses to be stored rather than interpreting the whole path name for each access.  Clients can also open other directories and use them to change rapidly between 'current' directories.The Econet protocols enforce a maximum of 8 file control blocks per user, and in this file server each client has the full allocation available.  This means that each client requires about 140 bytes of memory.Updates to the active user table are straightforward.  As the table is in main memory, most updates can be completed without the possibility of other tasks becoming active.  The only type of update which requires care is when a file is opened, as this requires disc transfers.  In this case, it is important that the file be found first, so that the file control block can be opened in a single step (on exit from the Find routine, no further disc transfers are required, so there is no risk of the file being deleted before it is protected by an open FCB).|u3.2 Directory interlocksThe low level interlocks are required to prevent conflicts caused by one task modifying a directory while another is suspended waiting for disc transfers in the middle of an operation on that directory.  The following operations are performed on directories :|i10|t6 1) Display catalogue.|t6 2) Find a named object prior to some operation on that object (eg. OPEN, *info)|t6 3) Create object.|t6 4) Delete object.|t6 5) Rename object (objects may be renamed from one directory to another).|i|u3.3 Complex schemeInitially, it was intended that updates could occur to more than one directory at once; only multiple updates to the same directory were to be locked out.  The following scheme was invented to achieve this, based on a table of object addresses, each having an associated |vreference count|z for 'reads' or an exclusive |vlock|z for 'writes'.  A count of the number of tasks waiting for a lock is also required.Any number of tasks may hold references to an object, and a task may hold references to more than one object.  Any task holding a lock on an object will also hold a reference to that object.  An attempt to establish a reference to an object which is already locked causes the task to suspend itself until the lock is released.  These locks are used in two ways :|i10|t7a) A directory must be locked when deleting or creating objects within it.  This means that a catalogue or name look-up operation can be protected by holding a reference to the directory; there can be more than one such operation in progress at once.|t7b) Objects may not be deleted if there are any references to them.  This may be used to protect files which are having complex operations performed on them without actually being opened.|iDeadlock between two tasks waiting to reference objects locked by the other is avoided by two rules relating to the directory hierarchy (with the root being considered as the |vtop|z) :|i10|t6 1) Any attempt to establish a new lock must be at a lower level than any reference already held by that task.|t6 2) Any new reference must be at a lower level than any locks held and either at the same level or lower than the lowest existing reference.|iWhen waiting to reference an object that is locked, any objects locked by that task will be at higher levels than the object in question.  Similarly, the task holding the lock can only reference objects at lower levels, and so there can never be a loop of dependencies causing deadlock.When attempting to lock an object, there is a problem that we cannot hold a reference to the object while waiting for other references to be removed, as there may be more than one task attempting to lock the same object.  Clearly, if the object is already unlocked and there are no references to it, it can be locked immediately.  Under other circumstances, the task has to proceed as follows : |gdata2