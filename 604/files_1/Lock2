|\ Lock2The low level interlocks are required to prevent conflicts caused by one task modifying a directory while another is suspended waiting for disc transfers in the middle of an operation on that directory which is meant to be atomic.  The following operations are performed on directories :|i10|t6 1) Display catalogue.|t6 2) Find a named object prior to some operation on that object (eg. OPEN, *info)|t6 3) Create object.|t6 4) Delete object.|t6 5) Rename object.These varying requirements are met by two forms of interlock : a |vreference count|z of 'read' accesses, and an exclusive |vlock|z for 'write' access.  Any number of tasks may hold references to an object, and a task may hold references to more than one object.  Any task holding a lock on an object will also hold a reference to that object.  A side-effect of holding a reference to an object is that it is guaranteed to remain in the internal cache until the reference is released; to prevent the cache becoming full of such objects and causing deadlock, each task is restricted to holding at most 3 references.The interlock system is integrated into the design of the internal cache : this results in greater efficiency than the use of a separate table of interlock information, as the same hash table look-up finds both the object data and the associated lock state.  If an object is requested from the cache and is found to be locked, the task is suspended until the lock is released.  Since the fileserver only swaps tasks when requested by the task that is running (rather than under the control of interrupts) there is no need to hold a reference to a single entry : objects are returned by the cache with the reference count unchanged, and tasks need only increment the count if they do not wish to release the reference when requesting another object.  Objects inspected during a directory search are hence automatically discarded with no cost at all.  Similarly, there is usually no need to hold references to individual files after creation or look-up, since the OPEN operation can be performed without further reference to disc.These locks are used as follows :|i10|t7a) A directory must be locked when deleting or creating objects within it.  This means that a catalogue or name look-up operation can be protected by holding a reference to the directory; there can be more than one such operation in progress at once.|t7b) Objects may not be deleted if there are any references to them.  This may be used to protect files which are having complex operations performed on them without actually being opened.|iDeadlock between two tasks waiting to reference objects locked by the other is avoided by two rules relating to the directory hierarchy :|i10|t6 1) Any attempt to establish a new lock must be at a lower level than any reference already held by that task.|t6 2) Any new reference must be at a lower level than any locks held and either at the same level or lower than the lowest existing reference.|iWhen waiting to reference an object that is locked, any objects locked by us, or locked by other tasks waiting for us, will be at higher levels than the object in question.  Similarly, the task holding the lock can only reference objects at lower levels, and if waiting for a locked item to be released the holder of that lock can only reference objects at still lower levels.  Hence a task will never be waiting for an object whose release requires the release of a lock held by that task, and so deadlock is avoided.  For efficiency, a count of those waiting for a locked object is maintained : this prevents the object in question from being flushed out of the cache, and so avoids the overhead of locating the object each time it is polled for the state of the lock.When attempting to lock an object, there is a problem that we cannot hold a reference to the object while waiting for other references to be removed, as there may be more than one task attempting to lock the same object.  Clearly, if the object is already unlocked and there are no other references to it, we can immediately lock it.  Under other circumstances, we proceed as follows : |i10|t6 1) Release any existing reference to the object.  The object must be prevented from deletion by either holding a lock on the parent directory, or by the normal mechanisms for preventing open files from being deleted.|t6 2) If the lock indicator is already set, increment the count of waiting tasks and wait for the lock to be released.  When the lock is released, the wait count can be decremented again (this is the same procedure as trying to reference a locked object).|t6 3) Increment the reference count, and set the lock indicator.|t6 4) Wait for the reference count to reach 1.|iHolders of references will either finish using them, or try to convert to a lock; in either event the reference will be released.  These reference holders can only be delayed by waiting for locks at this or lower levels : such locks cannot be held by tasks waiting to reference or lock the object in question, so deadlock is again avoided.This scheme has the important property that other tasks attempting to reference the object are locked out from the start : simpler schemes that waited for all existing references to be removed before asserting the lock would allow new references to be established during that time and so further delay the lock.  This would allow the original reference holder to complete a client request and begin to service another before the lock was established; potentially this could require another reference to the same object.  From an external viewpoint, this would mean that a pair of clients performing repeated catalogues of a directory could indefinitely delay an attempt by a third client to update that directory : this would lead to the client timing out and reporting an error to the user.For diagnostic purposes, a count is kept of the number of tasks waiting for locks : if this equals the total number of tasks, the system has failed to prevent deadlock and the lock details should be printed out for analysis.A slight exception to the hierarchical locking system concerns various 'ex-directory' objects.  The most important of these is the table of disc space account balances.  It is necessary to update this table while holding a lock elsewhere : in particular the cost of a create operation is variable, and so the decision to commit or reject a create transaction must be made while the directory in question is locked.  To resolve this, tasks are permitted to reference the account table while holding locks elsewhere, but may never lock the account table at all.