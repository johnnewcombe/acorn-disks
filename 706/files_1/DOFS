{  DOFS  File Server main code }External FS::dofs(9);{$E+  Extended error messages}{$C- No ctrl-C check}{$L- No list}Procedure Dofs;CONSTprint_size=256*4; {print buffer size}print_port=13*16+1;{port D1}prx_size=128;tim_delay=20000; {timeout delay}VARtime_out,a,blk_len,print_stn,print_space,print_ptr:Integer;  {<print_space> points to free space in the print buffer, <print ptr> points   to the next byte to be printed}print_block,next_seq,rx_seq:Byte;old_type,print_waiting,print_active:Boolean;print_buff:array[1..print_size] OF byte;printRx:array[1..prx_size] OF byte;dum$:message;Procedure Print(var txt:message);{Procedure to place contents of string into print buffer. If buffer doesnot have enough free space, it is purged first}VARa:byte;BEGINWhile ((print_space-print_ptr+print_size)MOD print_size) {no of chrs in buffer}  > (print_size-length(txt)) DO BEGIN  List_out(print_buff[print_ptr]);  If print_ptr=print_size THEN print_ptr:=1 ELSE print_ptr:=succ(print_ptr)END;For a:=1 TO length(txt) DO BEGIN  print_buff[print_space]:=ord(txt[a]);  IF print_space=print_size THEN print_space:=1  ELSE print_space:=succ(print_space)ENDEND;Procedure Instructions;BEGIN{writeln(' SJ Research File Server version ',verA:1,'.',verB:1,verC:1);} writeln('Very Dubious ARGO Server version ',verA:1,'.',verB:1,verC:1);writeln;Writeln('Operator commands :');Writeln;Writeln('Esc - allow discs to be changed');Writeln('F   - flush printer buffer');Writeln('M   - messages off/on');Writeln('Q   - quit');WritelnEND;Procedure Finish_print;BEGINPrint(end_text);print_active:=false;Msg('Station ');Msg(Stn$(client_stn));Msgln(' print terminated'); {Now acknowledge final packet}Transmit(rx_seq,print_port,print_stn,addrint(printRx[prx_size]),1 ,dummy);print_stn:=0 {Only non-0 if we are talking to someone}END;BEGINInstructions;cache_init;messages:=TRUE;print_ptr:=1;print_space:=1;print_stn:=0; {Only non-0 if we are talking to someone}time_out:=0;print_active:=false;print_waiting:=false; {If TRUE, we have an RxCB open}pre_text:=' ';post_text:=chr(13);append(post_text,chr(10)); {CR,LF}banner:='***  SJ Research Econet ';no_banner:=false;end_text:=chr(12);stop:=FALSE;{True means exit FS}FOR user_no:=1 TO no_users DO With user_info[user_no] DO BEGIN  logged_on:=FALSE;  FOR a:=1 TO 8 DO fcbs[a].in_use:=FALSEEND;Writeln('Ready',chr(17)); {ctrl-Q disables page wait on RML}REPEAT {Main operating loop}  RXSET(blockno,cmdport,0,ADDR2(mainRX),min_size+5);  WHILE NOT (RXREAD(blockno,dummybyte,dummybyte,client_stn,dummy) OR stop)    DO BEGIN    {Idle time in here!}{Handle operator commands}    CASE Land(Inkey,95) OF  {95=&5F ie. case equate}        0:{do nothing};       27:BEGIN Writeln('Change disc(s) then press a key');                REPEAT UNTIL Inkey<>0;                Disc_reset; {Reset the disc system, so not R/O}                Writeln('Ready')          END;       70:BEGIN {Flush print buffer}                print_ptr:=1;                print_space:=1          END;       77:BEGIN                messages:=NOT messages;                Write('messages ');                CASE messages OF                  TRUE:Writeln('On');                  FALSE:Writeln('Off');                END          END;       81:stop:=TRUE;     ELSE:Instructions    END; {of Case}    Cache_idle;{Attempt to empty print buffer}    IF (print_ptr<>print_space) AND List_ready THEN BEGIN      List_out(print_buff[print_ptr]);      IF print_ptr=print_size THEN print_ptr:=1  {wrap around buffer}       ELSE print_ptr:=succ(print_ptr)    END;{Attempt to fill print buffer}    IF print_waiting THEN IF      RXread(print_block,rx_seq,dummy,client_stn,blk_len) THEN BEGIN      print_waiting:=FALSE;      IF print_active OR (client_stn=print_stn) THEN BEGIN         {Either still printing or timed out & re-started}        print_active:=TRUE;        IF Land(rx_seq,1)=next_seq THEN BEGIN          next_seq:=Land(succ(next_seq),1); {Increment sequence no}          IF (NOT old_type) AND (Land(rx_seq,4)=4) THEN blk_len:=pred(blk_len);            {Control byte indicates last block, but there is a             spurious ctrl-C at the end as well }          a:=prx_size;          WHILE a>prx_size-blk_len DO BEGIN                {Transfer data to output buffer}            IF old_type AND (printRx[a]=3) THEN Finish_print             {Old type block terminator}            ELSE BEGIN {normal byte}              print_buff[print_space]:=printRx[a];              IF print_space=print_size THEN print_space:=1               ELSE print_space:=succ(print_space)            END;            a:=pred(a)          END; {while}          IF (NOT old_type) AND (Land(rx_seq,4)=4) THEN Finish_print           {Usual terminator}        END      END ELSE BEGIN {Not active, so should be log-on}        IF print_stn<>0 THEN Finish_print;         {Terminate timed-out user}        Msg('Print starting : stn =');Msg(Stn$(client_stn));        old_type:=printRx[prx_size]<>0; {Character sent indicates protocol}        If messages THEN writeln('Old protocol =',old_type);        print_stn:=client_stn;        IF NOT no_banner THEN Print(pre_text);        Print(banner);        IF NOT no_banner THEN BEGIN          dum$:=' ***  Station ';          append(dum$,stn$(print_stn));          Append(dum$,' (');          IF User_ok THEN Append(dum$,user_info[user_no].user_ID)            ELSE Append(dum$,'No name');          append(dum$,')  ***');          Print(dum$);          Print(post_text)        END;        next_seq:=Land(succ(Rx_seq),1); {Initialise sequence no (=0 or =1) }        print_active:=TRUE      END    END;    If (NOT print_waiting) AND      (((print_space-print_ptr+print_size)MOD print_size)      < (print_size-prx_size)) THEN BEGIN      { There is room in the buffer for another recieve block }      print_waiting:=TRUE;      If print_active THEN       Rxset(print_bl,print_po,print_stn,addrint(printRx[1]),prx_size)      ELSE Rxset(print_block,print_port,0,addrint(printRx[1]),prx_size);       { Acknowledge if appropriate }      If print_active THEN Transmit(rx_seq,print_port,print_stn,        addrint(printRx[prx_size]),1,dummy);      time_out:=tim_delay    END;    If print_waiting AND print_active THEN time_out:=pred(time_out);    If print_active AND (time_out=0) THEN BEGIN      Rxdel(print_block);      Rxset(print_block,print_port,0,addrint(printRx[1]),prx_size);      Msgln('Print timeout');      print_active:=false    END  END;{ Drops through here when a packet arrives on the FS command port }IF NOT stop THEN BEGIN  IF messages THEN WRITELN('FN=',mainRX.FN:3,' Stn=',Stn$(client_stn));   {Check if logged on or *cmd which could be *I AM }  IF (mainRx.fn=0) OR User_ok THEN  CASE mainRX.fn OF    0:Starcmd;    1:Save;    2:Load;    3:Cat;    5:Load;   18:Read_info;   21:User_envir;   23:Log_off;  ELSE:ReplyOK  END {of case}  ELSE Err_message(191) {'Who are U?' }END;UNTIL stopEND;.