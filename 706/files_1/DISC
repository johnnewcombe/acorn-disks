 NAME DISC PROG ; ; ENTRY PUT ENTRY GET ENTRY SIZE ENTRY BLOCK ENTRY OPEN ENTRY CLOSE ENTRY DELETE ENTRY DIR_FIRST ENTRY DIR_NEXT ENTRY DISC_RES ; ;BDOS EQU 0005HFCBoff EQU 36 ; Length of FCB - offset to start ; ; ; PROCEDURE BLOCK(VAR fblk,CSD:fcb;VAR fname:$STRING0;VAR error:BYTE); ; ; Inserts file name into FCB sorting out drive,extnt,etc. ;BLOCK POP B ; Return addr INX SP ; Size of error no variable POP D ; addr. of error no. SDED temp1 POP H ; String address POP D ; CSD fcb address CALL FCBtrans SDED csd_add POP D ; FCB addr to DE PUSH B ; return addr back on stack ; CALL FCBtrans SDED temp2 ; For routines <FNAME> and <TIDYUP> ; ; ; In general, B= no of chars left EXCLUDING (HL) ; (HL)=the character just finished with ; MOV B,M ; Length of stringDESPACE DCX H DCR B ; Count the 1st char JM BADNAME MOV A,M CPI ' ' JRZ DESPACE ; CPI ':' ; Is there a drive name? PUSH H LHLD CSD_add MOV A,M ; Value for default drive POP H JRNZ NODSC ; Z flag still from compare DCX H DCR B ; Skip the : JM BADNAME JZ BADNAME ; Null drive name also illegal MOV C,M ; Disc nameSKIP MOV A,M CPI '.' JRZ ENDDSC DCX H DJNZ SKIPToBAD JMP BADNAMEENDDSC MOV A,C ; Get back disc name DCX H DCR B JM BADNAMENODSC ANI 0FH ; Put in range 1..15 STAX D ; Store drive no. in FCB ; ; At this point, the 'previous' character [(HL)] is still valid ; ; Now check if there is a '.' in the file name ; <=> is there a directory name ; MOV A,B ; Check for only 1 char => can't be a dir ORA A JRZ NODIR2 ; PUSH B ; Save to return here to extract name or dir. PUSH H ; MOV A,M ; Check for leading dot & ignore it CPI '.' JRNZ FINDDOT ; Normal route DCX H DCR B ; Skip the dot JM BADNAME POP PSW ; Discard old saved values POP PSW JMP NODIR2 ; This entry pt. doesn't expect HL,BC on stack ; ;FINDDOT MOV A,M CPI '.' JRZ GOTDOT CPI ' ' ; Space is a terminator of name (eg *PS 210) JRZ NODIR DCX H DJNZ FINDDOT ; ; Falls through if no dots - hence no directory name ;NODIR POP H POP B ; Restore pointer to start of nameNODIR2 CALL FNAME ; Get file NAME into FCB from current position in string LHLD CSD_add ; Fill in current dir name MVI B,3 ; No of charsDEFDIR INX H ; 1st byte is drive MOV A,M CPI '$' ; Dir $ is root : this translates to all spaces JRNZ NOROOT MVI A,' ' DCX H ; So we see the $ next time roundNOROOT STAX D INX D DJNZ DEFDIR JR TIDYUP ; ;GOTDOT DCX H ; Found a dot, so skip it DCR B CALL FNAME POP H POP B ; Get back to start of string (=dir name) MVI B,3DODIR MOV A,M CPI '$' ; Treat $ as Root - ie dir name all nulls JRZ DOLLAR CPI '.' JRNZ NODOTDOLLAR INX H ; So we see it next time as well MVI A,' 'NODOT CALL CASE ; Case Equate STAX D INX D DCX H DJNZ DODIR ;TIDYUP LDED temp2 ; FCB LXI H,0CH ; Offset to 1st byte to zero DAD D MVI B,23 ; No of bytes to zero XRA AZEROFCB MOV M,A INX H DJNZ ZEROFCB XRA A LHLD temp1 ; Error location MOV M,A ; Set to 0 RET ; ; ; ; Routine to put the filename in the FCB, starting with ; the char at (HL) ;FNAME LDED temp2 ; FCB Address INX D MVI C,8 ; Count the bytes actually stored INR B ; Un-count the 1st char INX H MOV A,B CMP C ; Max meaningful value JRC DONAME MOV B,C ; If too long, only use 8 bytes (C=8)DONAME DCX H MOV A,M CPI ' ' ; Space is terminator of name (eg *ps 210) JRZ SPACEOUT DCR C CALL CASE ; Case equate STAX D INX D DJNZ DONAME ;SPACEOUT MVI A,' ' DCR C ; Count out the spaces to fill up name RM ; *EXIT THIS RTN* STAX D INX D JR SPACEOUT ; ;CASE ANI 7FH ; Kill top bit CPI 20H ; Check for control JRNC NOCTRL MVI A,'-'NOCTRL CPI 'a' RC ; Return if upper case ANI 5FH RET ; ;BADNAME LHLD temp1 MVI A,0CCH ; Bad file name MOV M,A ; Set error no. XRA A RET ; ; ; PROCEDURE OPEN(VAR fblk:fcb;rw:R_W;VAR error:BYTE); ; ; Activates FCB previously set up by <BLOCK> ;OPEN POP B ; Return addr INX SP ; Size of error no variable POP H ; addr. of error no. SHLD temp1 DCX SP ; Push 1 byte of garbage POP H ; L is garbage, H is R/W POP D PUSH B ; fcb address to DE, return addr back on stack CALL FCBtrans ; get START of FCB SDED temp2 ; MOV A,H ; R/W value ORA A JRZ READ MVI C,13H ; First delete file in case already exists CALL BDOS LDED temp2 ; FCB addr back MVI C,016H ; Make file CALL BDOS INR A JRNZ RETURNOK MVI A,0B3H ; Directory full LHLD temp1 MOV M,A XRA A RET ;READ MVI C,0FH ; Open(in) file PUSH X PUSH Y CALL BDOS POP Y POP X INR A JRNZ RETURNOK MVI A,0D6H ; File not found LHLD temp1 MOV M,A XRA A RET ; ;RETURNOK MVI A,0 ; Error code LDED temp1 STAX D XRA A; For Pascal RET ; ; ; ; ; PROCEDURE DELETE(VAR fblk:fcb;VAR error:BYTE); ; ; Deletes file specified in FCB ;DELETE POP B ; Return addr INX SP ; Size of error no variable POP H ; addr. of error no. SHLD temp1 POP D PUSH B ; FCB address to DE, return addr back on stack CALL FCBtrans ; get addr. of START of FCB ; MVI C,13H ; Delete file function code CALL BDOS INR A JRNZ RETURNOK MVI A,0D6H ;  File not found LHLD temp1 MOV M,A XRA A RET ; ; ; PROCEDURE PUT(VAR fblk:fcb;addr,length:INTEGER;VAR error:BYTE); ; ; write disc sectors from memory at <addr> (multiples of 128 bytes only) ; from the file given by <handle>. Error no. is zero if no error. ;PUT POP H ; Return addr INX SP ; Discard integer size POP B ; addr of error no. POP D ; Length SDED temp1 POP D ; Memory address SDED temp3 XTHL ; FCB addr to HL, return addr back on stack XCHG ; FCB to DE CALL FCBtrans ; get addr. of START of FCB SDED temp2 PUSH B ; Save error no. addr ;PLOOP LHLD temp3 LXI D,080H ; Size of a sector DAD D SHLD temp3 DSBC D ; Carry guaranteed clear from DAD XCHG ; Original back in DE MVI C,01AH ; Set DMA addr CALL BDOS LDED temp2 ; FCB MVI C,015H ; Write sequential CALL BDOS ORA A JRNZ DISCFULL LHLD temp1 ; Length LXI D,080H ORA A ; C=0 DSBC D SHLD temp1 JRC PFIN ; Not finished JRNZ PLOOPPFIN POP H ; Addr of error no. XRA A MOV M,A RET ; ; ;DISCFULL POP H MVI A,0C6H ; Error no. for disc full MOV M,A XRA A RET ; ; ; PROCEDURE GET(VAR fblk:fcb;addr,length:INTEGER;VAR error:BYTE); ; ; Read disc sectors to memory at <addr> (multiples of 128 bytes only) ; from the file given by <handle>. Error no. is zero if no error ;GET POP H ; Return addr INX SP ; Discard integer size POP B ; addr of error no. POP D ; Length SDED temp1 POP D ; Memory address SDED temp3 XTHL ; FCB addr to HL, return addr back on stack XCHG ; FCB to DE CALL FCBtrans ; get addr. of START of FCB SDED temp2 PUSH B ; Save error no. addr ;GLOOP LHLD temp3 LXI D,080H ; Size of a sector DAD D SHLD temp3 DSBC D ; Carry guaranteed clear from DAD XCHG ; Original back in DE MVI C,01AH ; Set DMA addr CALL BDOS LDED temp2 ; FCB MVI C,014H ; Read sequential CALL BDOS ORA A JRNZ EOF LHLD temp1 ; Length LXI D,080H ORA A ; C=0 DSBC D SHLD temp1 JRC GFIN ; Not finished JRNZ GLOOPGFIN POP H ; Addr of error no. XRA A MOV M,A RET ;EOF POP H ; Error no addr MVI A,0DFH ; EOF error MOV M,A XRA A RET ; ;