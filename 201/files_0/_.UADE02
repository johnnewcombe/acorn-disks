 :    ********************************* :    *                               * :    * FILE :UADE02                  * :    *                               * :    * PROGRAM :BBC TELESOFT DECODER * :    *                               * :    * DISK :4 LINE DEC              * :    *                               * :    * AUTHOR :MEL                   * :    *                               * :    * DATE CREATED :28/9/81         * :    *                               * :    * DATE CHANGED :8/1/82          * :    *                               * :    * CONTENTS :INIT                * :    *           BMPROW              * :    *           RDCTRL              * :    *           TRANSF              * :    *           RDMRAG              * :    ********************************* : : :   INITIALISE THE DECODER FOR READING :   TELETEXT AND SET UP THE SCREEN : :INIT LDAIM $16     SET SCREEN MODE 7 : JSR OSWRCH : LDAIM $07 : JSR OSWRCH : LDAIM CLEAR  : JSR OSWRCH     RESET THE RACK : JSR CLRALL  USE THE INTERNAL CLEAR : CLD    SET UP FOR THE WHOLE PROGRAM : LDAIM $00  SET UP THE ROW TO ZERO : STAZ RDROW  IN BOTH MEMORY AND : STA DATSTA  THE DECODER : STAZ SWITCH  ALSO SET NORMAL DECODER MODE : LDAIM $04  ENABLE TELETEXT : STA DATFLG : RTS : :    ((END OF INIT : : : :   BUMP THE DECODER ADDRESS COUNTER :   TO THE START OF THE NEXT ROW :   THIS IS MOVING UP TO NEXT 64 BYTE :   BOUNDARY :    **NEW DECODER** :   THIS INCREMENTS THE ROW :   COUNTER AND UPDATES :   THE ROW REGISTER IN THE DECODER : :   INPUTS RDROW POINTER : :   OUTPUTS RDROW UPDATED :           DATSTA UPDATED : : :BMPROW INCZ RDROW   : LDAZ RDROW   NOW MASK BOTTOM 4 BITS : ANDIM $0F : STA DATSTA : RTS : :   ((END OF BMPROW : : : : : : : :   READ CONTROL BYTES :   THE 8 CONTROL BYTES AFTER :   THE MRAG IN A HEADER ARE :   READ , DECODED AND STORED :   NOTE THAT AT PRESENT THE SUBROUTINE :   REPLACES A FAIL WITH ZERO :   BUT THIS MAY NOT BE DESIRABLE : :   INPUTS - :   OUTPUTS - : :   REGISTERS USED : A , X , Y : :RDCTRL LDYIM $00  USE Y TO INDEX : :RCLA LDX DATINP  THE DESTINATION : LDAAX HAMTAB  USE BYTE AS INDEX - DECODE : CMPIM $FF  DID IT FAIL : BNE RCLB  NO THEN GO INDEX : LDAIM $00  OTHER USE ZERO : :RCLB STAAY PUNRD  SAVE START HERE : INY  MOVE TO NEXT BYTE POSN : CPYIM $08  DONE THEM ALL : BNE RCLA : RTS : : :   ((END OF RDCTRL : : : :   TRANSFER A SEQUENCE OF BYTES :   FROM THE DECODER TO A MEMORY :   LOCATION ( USUALLY VDU RAM ) : :   INPUTS XFRCNT CONTAINS BYTE COUNT :          SOURCE ADDRESS IN RDROW :          DEST ADD IN DSTADD : :   OUTPUTS  - : :   REGISTERS USED : A , X , Y : : :TRANSF LDYIM $00  START INDEX AT ZERO : :TNFA LDA DATINP  GET THE NEXT BYTE : STAIY DSTADD  TRANSFER TO VDU : INY : CPY XFRCNT : BCC TNFA  LOOP UNTIL ALL BYTES : RTS : :   ((END OF TRANSF : : :   READ MAGAZINE - ROW ADDRESS GROUP :   THIS ROUTINE FINDS THE NEXT VALID :   LINE FROM THE BUFFER , DECODES  :   THE TWO HAMMING BYTES AND PRODUCES :   TWO VALUES ; MAGAZINE AND ROW :   IF THE LINE IS INVALID THEN THE :   FAILURE IS FLAGGED ON EXIT IN THE :   ACCUMULATOR :    IT DOESN'T RETURN UNTIL A ROW IS FOUND :    BOTH ACC AND THE STATUS BYTE CONTAIN THE ROW NUMBER : : :   INPUTS - :   OUTPUTS - ACC CONTAINS THE ROW NUMBER : :   REGISTERS USED A, X, Y : :RDMRAG   RDMRAG STA DATCLR   Clear status (kimcoder) :MRAGGG BIT DATFLG  WAIT FOR INT : BPL MRAGGG : : LDA RDROW  CURRENT ROW : STA DATSTA & reset row pointer, column counter : : : LDA DATINP  GET THE NEXT BYTE IN : BNE RMGA  IF ZERO THEN IT'S BEEN READ : :    **NEW DECODER** :RMGG LDX RCOUNT : DEX : STX RCOUNT  Save new count : BNE RMGGA   Not zero so no action : STX RDROW : STX DATSTA : STA DATCLR  If 16 dud rows, get some better ones. : LDXIM $10 : STX RCOUNT   Prepare to count down again : JMP RDMRAG  Wait for new rows to arrive. :RMGGA INCZ RDROW  MOVE TO NEW ROW : LDAZ RDROW  CHECK STILL IN RANGE : ANDIM $0F  BY LEAVING BOTTOM 4 BITS : STA DATSTA  NOW UPDATE ROW REG : JMP MRAGGG  AND LOOP :   NOW CLEAR OUT THE FIRST BYTE :   IN THE DECODER BUFFER - THIS IS :   THE FRAMING CODE AND IS USED AS :   A FLAG BYTE : :   **NEW DECODER** :RMGA     RMGA  CMPIM $27   CHECK REAL FRAME :    Kimcoder doesn't always store  framing code :    BNE RMGG   IF NOT IGNORE : LDXIM $10  We have a good row, so reset bad row count : STX RCOUNT : LDAZ RDROW  RESET TO START OF LINE : STA DATSTA  BY WRITING THE ROW : LDAIM $00  NOW LOAD A ZERO INTO : STA DATINP  THE FIRST BYTE : :RMGB LDX DATINP : LDAAX HAMTAB  READ AND DECODE FIRST : CMPIM $FF  BYTE OF MRAG : BEQ RMGG  IF SUCCESSFUL LOAD IT(BNE RMGC) :    OTHERWISE IGNORE WHOLE LINE :    AND GO GET NEXT ONE :   LDAIM $00  SUBSTITIUTE 0 FOR A FAIL : :RMGC CMPIM $08  OF THE ROW NUMBER : BCC RMGD  IF ZERO THEN DON'T ADD TO ROW : SEC : SBCIM $08  STRIP OFF TOP BIT : STAZ MAGZRD : LDAIM $01  AND PUT 1 INTO ROW : JMP RMGE : :RMGD STAZ MAGZRD  NO TOP BIT : LDAIM $00 : :RMGE STAZ ROWRD  SO ZERO ROW : LDX DATINP  GET THE BYTE : LDAAX HAMTAB  CHECK FOR HAM TYPE : CMPIM $FF  FAILED (BNE RMGF) : BEQ RMGG  NO THEN CONTINUE : :   NOTE THIS LINE PRESENTLY A COMMENT :   LDAIM $00  OTHERWISE PRETEND ZERO : :RMGF ASLA  DOUBLE THE ROW NUMBER : CLC : ADCZ ROWRD  AND ADD IN LOW BIT : STAZ ROWRD : STAZ STATUS  SAVE HERE ? : RTS : :    ((END OF RDMRAG : :